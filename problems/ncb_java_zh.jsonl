{"_id": 131, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n课堂练习：设计一个接受数组的静态方法，数组的每个成员都是个位整数(8到9之间），该方法能以电话号码的形式返回包含这些数字的字符串。例如：\n createPhoneNumber ( new int []{1,2,3,4,5,6,7,8,9,0})//=> returns \"(123) 456-7890\"\n注：别忘了右括号后面的空格！\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCreatePhoneNumber1() {\n        assertEquals(\"(123) 456-7890\", PhoneNumberCreator.createPhoneNumber(new int[]{1,2,3,4,5,6,7,8,9,0}));\n    }\n}", "problem": "课堂练习：设计一个接受数组的静态方法，数组的每个成员都是个位整数(8到9之间），该方法能以电话号码的形式返回包含这些数字的字符串。例如：\n createPhoneNumber ( new int []{1,2,3,4,5,6,7,8,9,0})//=> returns \"(123) 456-7890\"\n注：别忘了右括号后面的空格！", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass PhoneNumberCreatorTest {\n    @Test\n    void testCreatePhoneNumber2() {\n        assertEquals(\"(987) 654-3210\", PhoneNumberCreator.createPhoneNumber(new int[]{9,8,7,6,5,4,3,2,1,0}));\n    }\n\n    @Test\n    void testCreatePhoneNumber3() {\n        assertEquals(\"(111) 111-1111\", PhoneNumberCreator.createPhoneNumber(new int[]{1,1,1,1,1,1,1,1,1,1}));\n    }\n\n    @Test\n    void testCreatePhoneNumber4() {\n        assertEquals(\"(999) 999-9999\", PhoneNumberCreator.createPhoneNumber(new int[]{9,9,9,9,9,9,9,9,9,9}));\n    }\n\n    @Test\n    void testCreatePhoneNumber5() {\n        assertEquals(\"(123) 456-7890\", PhoneNumberCreator.createPhoneNumber(new int[]{1,2,3,4,5,6,7,8,9,0}));\n    }\n\n    @Test\n    void testCreatePhoneNumber6() {\n        assertEquals(\"(000) 000-0000\", PhoneNumberCreator.createPhoneNumber(new int[]{0,0,0,0,0,0,0,0,0,0}));\n    }\n\n    //boundary cases\n    @Test\n    void testCreatePhoneNumber7() {\n        assertEquals(\"(123) 456-7890\", PhoneNumberCreator.createPhoneNumber(new int[]{1,2,3,4,5,6,7,8,9,0}));\n    }\n\n    @Test\n    void testCreatePhoneNumber8() {\n        assertEquals(\"(000) 000-0000\", PhoneNumberCreator.createPhoneNumber(new int[]{0,0,0,0,0,0,0,0,0,0}));\n    }\n\n    @Test\n    void testCreatePhoneNumber9() {\n        assertEquals(\"(999) 999-9999\", PhoneNumberCreator.createPhoneNumber(new int[]{9,9,9,9,9,9,9,9,9,9}));\n    }\n\n    @Test\n    void testCreatePhoneNumber10() {\n        assertEquals(\"(123) 456-7890\", PhoneNumberCreator.createPhoneNumber(new int[]{1,2,3,4,5,6,7,8,9,0}));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class PhoneNumberCreator {\n    public static String createPhoneNumber(int[] numbers) {\n        StringBuilder phoneNumber = new StringBuilder(\"(\");\n        for (int i = 0; i < numbers.length; i++) {\n            if (i == 3) {\n                phoneNumber.append(\") \");\n            } else if (i == 6) {\n                phoneNumber.append(\"-\");\n            }\n            phoneNumber.append(numbers[i]);\n        }\n        return phoneNumber.toString();\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 132, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n问题：我们公司的产品有一个功能是医生和患者可以相互发送对话消息，现在需要计算某个医生和某个患者之间对话的来回，来回的定义是对话双方有一方发了消息，另一方需要有回复才算是一个来回。举例：假定医生发了消息用a来表示，患者发了消息用b来表示，则按照定义ab算1个来回，abb、aba、aab、aabb也均算1个来回，abab、abba，abbba则算2个来回。\n期望：用java实现一个完整的方法，输入是某个医生和某个患者的对话列表（结构自定义），输出是对话来回的个数；要求代码思路清晰，逻辑严谨，有边界值判断。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCountConversationTurns1() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\")\n        );\n        assertEquals(3, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n}", "problem": "问题：我们公司的产品有一个功能是医生和患者可以相互发送对话消息，现在需要计算某个医生和某个患者之间对话的来回，来回的定义是对话双方有一方发了消息，另一方需要有回复才算是一个来回。举例：假定医生发了消息用a来表示，患者发了消息用b来表示，则按照定义ab算1个来回，abb、aba、aab、aabb也均算1个来回，abab、abba，abbba则算2个来回。\n期望：用java实现一个完整的方法，输入是某个医生和某个患者的对话列表（结构自定义），输出是对话来回的个数；要求代码思路清晰，逻辑严谨，有边界值判断。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass ConversationTest {\n    @Test\n    void testCountConversationTurns2() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\")\n        );\n        assertEquals(5, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n\n    @Test\n    void testCountConversationTurns3() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\")\n        );\n        assertEquals(1, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n\n    @Test\n    void testCountConversationTurns4() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\")\n        );\n        assertEquals(6, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n\n    @Test\n    void testCountConversationTurns5() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\")\n        );\n        assertEquals(0, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n\n    @Test\n    void testCountConversationTurns6() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\")\n        );\n        assertEquals(0, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n\n    // boundary cases\n    @Test\n    void testCountConversationTurns7() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\")\n        );\n        assertEquals(0, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n\n    @Test\n    void testCountConversationTurns8() {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"patient\")\n        );\n        assertEquals(0, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n\n    @Test\n    void testCountConversationTurns9() {\n        List<Conversation> conversations = Arrays.asList();\n        assertEquals(0, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n\n    @Test\n    void testCountConversationTurns10() {\n        List<Conversation> conversations = null;\n        assertEquals(0, ConversationCounter.countConversationTurns(conversations, \"doctor\", \"patient\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.List;\nimport java.util.Arrays;\n\npublic class Conversation {\n    private String sender; // 发送者\n\n    public Conversation(String sender) {\n        this.sender = sender;\n    }\n\n    public String getSender() {\n        return sender;\n    }\n}\n\npublic class ConversationCounter {\n    public static int countConversationTurns(List<Conversation> conversations, String doctor, String patient) {\n        if (conversations == null || conversations.isEmpty()) {\n            return 0;\n        }\n\n        int count = 0;\n        String lastSender = conversations.get(0).getSender();\n        for (Conversation conversation : conversations) {\n            String currentSender = conversation.getSender();\n            if (!currentSender.equals(lastSender)) {\n                count++;\n                lastSender = currentSender;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        List<Conversation> conversations = Arrays.asList(\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"doctor\"),\n                new Conversation(\"patient\"),\n                new Conversation(\"patient\")\n        );\n\n        System.out.println(countConversationTurns(conversations, \"doctor\", \"patient\")); // 输出：3\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 133, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n我想从这个字符串，\"全部已关闭待支付交易成功订单号: 100e863a2b86402a881b62abee3e337e交易成功客户账号: 13422344170产品名称:代服管家￥200.00\",在出现订单两个字以后，出现的第一个字母或英文的字符串提取出来。请用java的正则表达式来实现。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(\"e\", Main.findFirstAlphabeticStringAfterOrder(\"订单号: e123456\"));\n    }\n}", "problem": "我想从这个字符串，\"全部已关闭待支付交易成功订单号: 100e863a2b86402a881b62abee3e337e交易成功客户账号: 13422344170产品名称:代服管家￥200.00\",在出现订单两个字以后，出现的第一个字母或英文的字符串提取出来。请用java的正则表达式来实现。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass MainTest {\n    @Test\n    void testNoOrderKeyword() {\n        assertNull(Main.findFirstAlphabeticStringAfterOrder(\"没有订单关键字\"));\n    }\n\n    @Test\n    void testOrderWithoutAlphabeticString() {\n        assertNull(Main.findFirstAlphabeticStringAfterOrder(\"订单号: 123456\"));\n    }\n\n    @Test\n    void testEmptyString() {\n        assertNull(Main.findFirstAlphabeticStringAfterOrder(\"\"));\n    }\n\n    @Test\n    void testOnlyOrder() {\n        assertNull(Main.findFirstAlphabeticStringAfterOrder(\"订单\"));\n    }\n\n    @Test\n    void testMultipleAlphabeticStrings() {\n        assertEquals(\"abc\", Main.findFirstAlphabeticStringAfterOrder(\"订单号: abc123def456\"));\n    }\n\n    @Test\n    void testLongString() {\n        assertEquals(\"longString\", Main.findFirstAlphabeticStringAfterOrder(\"订单号: 1234567890longString\"));\n    }\n\n    @Test\n    void testSpecialCharacters() {\n        assertEquals(\"test\", Main.findFirstAlphabeticStringAfterOrder(\"订单号: !@#$%test^&*()\"));\n    }\n\n    @Test\n    void testAllAlphabeticString() {\n        assertEquals(\"AllAlphabetic\", Main.findFirstAlphabeticStringAfterOrder(\"订单AllAlphabetic\"));\n    }\n\n    @Test\n    void testMixedCharacters() {\n        assertEquals(\"Mixed\", Main.findFirstAlphabeticStringAfterOrder(\"订单123!@#Mixed%^&*\"));\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"全部已关闭待支付交易成功订单号: 100e863a2b86402a881b62abee3e337e交易成功客户账号: 13422344170产品名称:代服管家￥200.00\";\n        String result = findFirstAlphabeticStringAfterOrder(text);\n\n        if (result != null) {\n            System.out.println(\"找到的字符串: \" + result);\n        } else {\n            System.out.println(\"没有找到匹配的字符串\");\n        }\n    }\n\n    public static String findFirstAlphabeticStringAfterOrder(String text) {\n        String regex = \"订单.*?([a-zA-Z]+)\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(text);\n\n        if (matcher.find()) {\n            return matcher.group(1);\n        } else {\n            return null;\n        }\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 134, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1、在用户管理类（UserManager），通过ArrayList提供用户管理服务。\n\n2、在UserManager类中定义一个ArrayList的属性users;\n\n3、UserManager类中定义如下几个方法操作users中的用户(参照main方法中UserManager类的调用方法编写)：\n\n（1）添加用户addUser方法，向users中添加一个用户信息。\n\n（2）删除用户deleteUser方法，从users中删除一个用户信息。\n\n（3）判断一个用户是否存在isExist方法，判断users中是否存在该用户。\n\n（4）显示所有用户信息display方法：直接输出user对象信息。\n\n3、直接运行程序，显示如下运行结果。\n\n\n\n输出结果为：\n\nname is:alice\n\nname is:john\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddUser() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.addUser(alice);\n        assertTrue(userManager.isExist(alice));\n    }\n}", "problem": "1、在用户管理类（UserManager），通过ArrayList提供用户管理服务。\n\n2、在UserManager类中定义一个ArrayList的属性users;\n\n3、UserManager类中定义如下几个方法操作users中的用户(参照main方法中UserManager类的调用方法编写)：\n\n（1）添加用户addUser方法，向users中添加一个用户信息。\n\n（2）删除用户deleteUser方法，从users中删除一个用户信息。\n\n（3）判断一个用户是否存在isExist方法，判断users中是否存在该用户。\n\n（4）显示所有用户信息display方法：直接输出user对象信息。\n\n3、直接运行程序，显示如下运行结果。\n\n\n\n输出结果为：\n\nname is:alice\n\nname is:john", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\nclass MainTest {\n    @Test\n    void testDeleteUser() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.addUser(alice);\n        userManager.deleteUser(alice);\n        assertFalse(userManager.isExist(alice));\n    }\n\n    @Test\n    void testIsExist() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.addUser(alice);\n        assertTrue(userManager.isExist(alice));\n    }\n\n    @Test\n    void testIsNotExist() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        assertFalse(userManager.isExist(alice));\n    }\n\n    @Test\n    void testAddMultipleUsers() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        User bob = new User(\"bob\");\n        userManager.addUser(alice);\n        userManager.addUser(bob);\n        assertTrue(userManager.isExist(alice));\n        assertTrue(userManager.isExist(bob));\n    }\n\n    @Test\n    void testDeleteNonExistentUser() {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        userManager.deleteUser(alice);\n        assertFalse(userManager.isExist(alice));\n    }\n\n    @Test\n    void testAddUserBoundary() {\n        UserManager userManager = new UserManager();\n        User user = new User(\"\");\n        userManager.addUser(user);\n        assertTrue(userManager.isExist(user));\n    }\n\n    @Test\n    void testDeleteUserBoundary() {\n        UserManager userManager = new UserManager();\n        User user = new User(\"\");\n        userManager.addUser(user);\n        userManager.deleteUser(user);\n        assertFalse(userManager.isExist(user));\n    }\n\n    @Test\n    void testIsExistBoundary() {\n        UserManager userManager = new UserManager();\n        User user = new User(\"\");\n        assertFalse(userManager.isExist(user));\n    }\n\n    @Test\n    void testAddMultipleUsersBoundary() {\n        UserManager userManager = new UserManager();\n        for (int i = 0; i < 1000; i++) {\n            User user = new User(\"user\" + i);\n            userManager.addUser(user);\n            assertTrue(userManager.isExist(user));\n        }\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.ArrayList;\n\nclass User {\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        return \"name is:\" + name;\n    }\n}\n\nclass UserManager {\n    private ArrayList<User> users;\n\n    public UserManager() {\n        users = new ArrayList<>();\n    }\n\n    public void addUser(User user) {\n        users.add(user);\n    }\n\n    public void deleteUser(User user) {\n        users.remove(user);\n    }\n\n    public boolean isExist(User user) {\n        return users.contains(user);\n    }\n\n    public void display() {\n        for (User user : users) {\n            System.out.println(user);\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        UserManager userManager = new UserManager();\n        User alice = new User(\"alice\");\n        User john = new User(\"john\");\n        userManager.addUser(alice);\n        userManager.addUser(john);\n        userManager.display();\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 135, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n、\n\n请按照以下要求设计一个学生类Student。\n\n要求如下：\n\n\n1）学生类有五个属性，分别是姓名(name)、学号 (userID)、数学成绩（math）、语文成绩（chinese）、英语成绩（english）\n\n\n2）使用封装的思想将所有属性私有化，对外界提供共有的访问方法。至少包括输入学生信息，计算总分和平均分的方法，并在适当的方法中对输入的成绩值进行判断，仅允许合法有效成绩（0~100）的录入。（注：设置各属性的方法和获取各属性的方法，以及构造方法可以根据自己的类设计自行选择定义）\n3）在main()方法中，创建Student的实例对象，显示该学生（你）的相关信息（姓名、学号，及成绩）。请帮我写个代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\nvoid testStudent1() {\n    Student student = new Student(\"John Doe\", \"123456\", 85.5, 90.0, 88.0);\n    assertEquals(\"John Doe\", student.getName());\n    assertEquals(\"123456\", student.getUserID());\n    assertEquals(85.5, student.getMath());\n    assertEquals(90.0, student.getChinese());\n    assertEquals(88.0, student.getEnglish());\n    assertEquals(263.5, student.getTotalScore());\n    assertEquals(87.83, student.getAverageScore(), 0.01);\n}\n}", "problem": "、\n\n请按照以下要求设计一个学生类Student。\n\n要求如下：\n\n\n1）学生类有五个属性，分别是姓名(name)、学号 (userID)、数学成绩（math）、语文成绩（chinese）、英语成绩（english）\n\n\n2）使用封装的思想将所有属性私有化，对外界提供共有的访问方法。至少包括输入学生信息，计算总分和平均分的方法，并在适当的方法中对输入的成绩值进行判断，仅允许合法有效成绩（0~100）的录入。（注：设置各属性的方法和获取各属性的方法，以及构造方法可以根据自己的类设计自行选择定义）\n3）在main()方法中，创建Student的实例对象，显示该学生（你）的相关信息（姓名、学号，及成绩）。请帮我写个代码", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass StudentTest {\n@Test\nvoid testStudent2() {\n    Student student = new Student(\"Jane Doe\", \"654321\", 100.0, 100.0, 100.0);\n    assertEquals(\"Jane Doe\", student.getName());\n    assertEquals(\"654321\", student.getUserID());\n    assertEquals(100.0, student.getMath());\n    assertEquals(100.0, student.getChinese());\n    assertEquals(100.0, student.getEnglish());\n    assertEquals(300.0, student.getTotalScore());\n    assertEquals(100.0, student.getAverageScore());\n}\n\n@Test\nvoid testStudent3() {\n    Student student = new Student(\"Alice\", \"789012\", 0.0, 0.0, 0.0);\n    assertEquals(\"Alice\", student.getName());\n    assertEquals(\"789012\", student.getUserID());\n    assertEquals(0.0, student.getMath());\n    assertEquals(0.0, student.getChinese());\n    assertEquals(0.0, student.getEnglish());\n    assertEquals(0.0, student.getTotalScore());\n    assertEquals(0.0, student.getAverageScore());\n}\n\n@Test\nvoid testStudent4() {\n    Student student = new Student(\"Bob\", \"210987\", 50.0, 50.0, 50.0);\n    assertEquals(\"Bob\", student.getName());\n    assertEquals(\"210987\", student.getUserID());\n    assertEquals(50.0, student.getMath());\n    assertEquals(50.0, student.getChinese());\n    assertEquals(50.0, student.getEnglish());\n    assertEquals(150.0, student.getTotalScore());\n    assertEquals(50.0, student.getAverageScore());\n}\n\n@Test\nvoid testStudent5() {\n    Student student = new Student(\"Charlie\", \"345678\", 75.5, 80.0, 70.0);\n    assertEquals(\"Charlie\", student.getName());\n    assertEquals(\"345678\", student.getUserID());\n    assertEquals(75.5, student.getMath());\n    assertEquals(80.0, student.getChinese());\n    assertEquals(70.0, student.getEnglish());\n    assertEquals(225.5, student.getTotalScore());\n    assertEquals(75.17, student.getAverageScore(), 0.01);\n}\n\n@Test\nvoid testStudent6() {\n    Student student = new Student(\"David\", \"876543\", 60.0, 70.0, 80.0);\n    assertEquals(\"David\", student.getName());\n    assertEquals(\"876543\", student.getUserID());\n    assertEquals(60.0, student.getMath());\n    assertEquals(70.0, student.getChinese());\n    assertEquals(80.0, student.getEnglish());\n    assertEquals(210.0, student.getTotalScore());\n    assertEquals(70.0, student.getAverageScore());\n}\n\n@Test\nvoid testStudent7() {\n    Student student = new Student(\"Eve\", \"109876\", 101.0, 90.0, 80.0);\n    assertEquals(\"Eve\", student.getName());\n    assertEquals(\"109876\", student.getUserID());\n    assertEquals(0.0, student.getMath());\n    assertEquals(90.0, student.getChinese());\n    assertEquals(80.0, student.getEnglish());\n}\n\n@Test\nvoid testStudent8() {\n    Student student = new Student(\"Frank\", \"543210\", 90.0, -10.0, 80.0);\n    assertEquals(\"Frank\", student.getName());\n    assertEquals(\"543210\", student.getUserID());\n    assertEquals(90.0, student.getMath());\n    assertEquals(0.0, student.getChinese());\n    assertEquals(80.0, student.getEnglish());\n}\n\n@Test\nvoid testStudent9() {\n    Student student = new Student(\"Grace\", \"678901\", 90.0, 100.0, 110.0);\n    assertEquals(\"Grace\", student.getName());\n    assertEquals(\"678901\", student.getUserID());\n    assertEquals(90.0, student.getMath());\n    assertEquals(100.0, student.getChinese());\n    assertEquals(0.0, student.getEnglish());\n}\n\n@Test\nvoid testStudent10() {\n    Student student = new Student(\"Hank\", \"234567\", 90.0, 100.0, 80.0);\n    student.setMath(110.0);\n    assertEquals(\"Hank\", student.getName());\n    assertEquals(\"234567\", student.getUserID());\n    assertEquals(90.0, student.getMath());\n    assertEquals(100.0, student.getChinese());\n    assertEquals(80.0, student.getEnglish());\n}\n}", "setup_code": "", "reference_solution": "```java\n\npublic class Student {\n    private String name;\n    private String userID;\n    private double math;\n    private double chinese;\n    private double english;\n\n    public Student(String name, String userID, double math, double chinese, double english) {\n        this.name = name;\n        this.userID = userID;\n        setMath(math);\n        setChinese(chinese);\n        setEnglish(english);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getUserID() {\n        return userID;\n    }\n\n    public double getMath() {\n        return math;\n    }\n\n    public void setMath(double math) {\n        if(math >= 0 && math <= 100) {\n            this.math = math;\n        } else {\n            System.out.println(\"Invalid math score. It should be between 0 and 100.\");\n        }\n    }\n\n    public double getChinese() {\n        return chinese;\n    }\n\n    public void setChinese(double chinese) {\n        if(chinese >= 0 && chinese <= 100) {\n            this.chinese = chinese;\n        } else {\n            System.out.println(\"Invalid chinese score. It should be between 0 and 100.\");\n        }\n    }\n\n    public double getEnglish() {\n        return english;\n    }\n\n    public void setEnglish(double english) {\n        if(english >= 0 && english <= 100) {\n            this.english = english;\n        } else {\n            System.out.println(\"Invalid english score. It should be between 0 and 100.\");\n        }\n    }\n\n    public double getTotalScore() {\n        return math + chinese + english;\n    }\n\n    public double getAverageScore() {\n        return getTotalScore() / 3;\n    }\n\n    public static void main(String[] args) {\n        Student student = new Student(\"John Doe\", \"123456\", 85.5, 90.0, 88.0);\n        System.out.println(\"Name: \" + student.getName());\n        System.out.println(\"UserID: \" + student.getUserID());\n        System.out.println(\"Math Score: \" + student.getMath());\n        System.out.println(\"Chinese Score: \" + student.getChinese());\n        System.out.println(\"English Score: \" + student.getEnglish());\n        System.out.println(\"Total Score: \" + student.getTotalScore());\n        System.out.println(\"Average Score: \" + student.getAverageScore());\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 136, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n描述：\nToDoList是一个用户任务清单应用程序。用户可以通过该程序查看、添加、删除任务项目。\n设ToDoList包含固定任务条目，共10个。在不足10项任务时，显示空白。\n\n要求：\n1. 创建类Task，以表示一个任务项目。Task包括名称、截止完成时间两个属性。\n2. 创建类Model，以表示ToDoList中的10项任务列表数据（即10个Task）。\n3. 创建类Controller，以控制其它代码执行，包括查看、添加、删除任务项目。\n4. 创建main方法依次测试查看、添加、删除3个功能。\n\n用java写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddTask() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        assertEquals(\"Task 1\", model.tasks.get(0).name);\n    }\n}", "problem": "描述：\nToDoList是一个用户任务清单应用程序。用户可以通过该程序查看、添加、删除任务项目。\n设ToDoList包含固定任务条目，共10个。在不足10项任务时，显示空白。\n\n要求：\n1. 创建类Task，以表示一个任务项目。Task包括名称、截止完成时间两个属性。\n2. 创建类Model，以表示ToDoList中的10项任务列表数据（即10个Task）。\n3. 创建类Controller，以控制其它代码执行，包括查看、添加、删除任务项目。\n4. 创建main方法依次测试查看、添加、删除3个功能。\n\n用java写", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\n\nclass MainTest {\n    @Test\n    void testAddMultipleTasks() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        controller.addTask(\"Task 2\", new Date());\n        assertEquals(\"Task 1\", model.tasks.get(0).name);\n        assertEquals(\"Task 2\", model.tasks.get(1).name);\n    }\n\n    @Test\n    void testDeleteTask() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        controller.deleteTask(\"Task 1\");\n        assertNull(model.tasks.get(0));\n    }\n\n    @Test\n    void testDeleteNonExistentTask() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.deleteTask(\"Task 1\");\n        assertNull(model.tasks.get(0));\n    }\n\n    @Test\n    void testAddAndDeleteTask() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        controller.deleteTask(\"Task 1\");\n        controller.addTask(\"Task 2\", new Date());\n        assertEquals(\"Task 2\", model.tasks.get(0).name);\n    }\n\n    @Test\n    void testAddMoreThanTenTasks() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        for (int i = 0; i < 11; i++) {\n            controller.addTask(\"Task \" + i, new Date());\n        }\n        assertEquals(\"Task 9\", model.tasks.get(9).name);\n    }\n\n    @Test\n    void testDeleteTaskFromFullList() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        for (int i = 0; i < 10; i++) {\n            controller.addTask(\"Task \" + i, new Date());\n        }\n        controller.deleteTask(\"Task 5\");\n        assertEquals(\"Task 6\", model.tasks.get(5).name);\n    }\n\n    @Test\n    void testDeleteAllTasks() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        for (int i = 0; i < 10; i++) {\n            controller.addTask(\"Task \" + i, new Date());\n        }\n        for (int i = 0; i < 10; i++) {\n            controller.deleteTask(\"Task \" + i);\n        }\n        assertTrue(model.tasks.isEmpty());\n    }\n\n    @Test\n    void testAddTaskWithSameName() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        controller.addTask(\"Task 1\", new Date());\n        assertEquals(\"Task 1\", model.tasks.get(0).name);\n        assertEquals(\"Task 1\", model.tasks.get(1).name);\n    }\n\n    @Test\n    void testDeleteTaskWithSameName() {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n        controller.addTask(\"Task 1\", new Date());\n        controller.addTask(\"Task 1\", new Date());\n        controller.deleteTask(\"Task 1\");\n        assertNull(model.tasks.get(0));\n        assertNull(model.tasks.get(1));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.*;\n\nclass Task {\n    String name;\n    Date deadline;\n\n    public Task(String name, Date deadline) {\n        this.name = name;\n        this.deadline = deadline;\n    }\n\n    @Override\n    public String toString() {\n        return \"Task{\" +\n                \"name='\" + name + '\\'' +\n                \", deadline=\" + deadline +\n                '}';\n    }\n}\n\nclass Model {\n    List<Task> tasks;\n\n    public Model() {\n        this.tasks = new ArrayList<>(Collections.nCopies(10, null));\n    }\n\n    public void addTask(Task task) {\n        for (int i = 0; i < tasks.size(); i++) {\n            if (tasks.get(i) == null) {\n                tasks.set(i, task);\n                break;\n            }\n        }\n    }\n\n    public void deleteTask(String taskName) {\n        tasks.removeIf(task -> task != null && task.name.equals(taskName));\n    }\n\n    public void viewTasks() {\n        for (Task task : tasks) {\n            System.out.println(task);\n        }\n    }\n}\n\nclass Controller {\n    Model model;\n\n    public Controller(Model model) {\n        this.model = model;\n    }\n\n    public void addTask(String name, Date deadline) {\n        model.addTask(new Task(name, deadline));\n    }\n\n    public void deleteTask(String name) {\n        model.deleteTask(name);\n    }\n\n    public void viewTasks() {\n        model.viewTasks();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Model model = new Model();\n        Controller controller = new Controller(model);\n\n        // Test view tasks\n        controller.viewTasks();\n\n        // Test add tasks\n        controller.addTask(\"Task 1\", new Date());\n        controller.addTask(\"Task 2\", new Date());\n\n        // Test view tasks\n        controller.viewTasks();\n\n        // Test delete tasks\n        controller.deleteTask(\"Task 1\");\n\n        // Test view tasks\n        controller.viewTasks();\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 137, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个java方法，要求实现以下功能：\n1、输入值为3个占比值和1个总数值，三个占比值的总数相加约等于1，每个占比值的小数位为两位;\n2、方法内分别计算3个占比值与总数值的乘积，乘积取整数，计算后检查三个乘积值相加是否等于输入的总数值，如果不等于，按照占比值的大小继续分配数值，直到三个乘积值相加等于总数值，最后输出这三个乘积值\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCalculateProportion1() {\n        assertArrayEquals(new int[]{30, 40, 30}, Main.calculateProportion(0.3, 0.4, 0.3, 100));\n    }\n}", "problem": "编写一个java方法，要求实现以下功能：\n1、输入值为3个占比值和1个总数值，三个占比值的总数相加约等于1，每个占比值的小数位为两位;\n2、方法内分别计算3个占比值与总数值的乘积，乘积取整数，计算后检查三个乘积值相加是否等于输入的总数值，如果不等于，按照占比值的大小继续分配数值，直到三个乘积值相加等于总数值，最后输出这三个乘积值", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass MainTest {\n    @Test\n    void testCalculateProportion2() {\n        assertArrayEquals(new int[]{50, 25, 25}, Main.calculateProportion(0.5, 0.25, 0.25, 100));\n    }\n\n    @Test\n    void testCalculateProportion3() {\n        assertArrayEquals(new int[]{33, 33, 34}, Main.calculateProportion(0.33, 0.33, 0.34, 100));\n    }\n\n    @Test\n    void testCalculateProportion4() {\n        assertArrayEquals(new int[]{20, 30, 50}, Main.calculateProportion(0.2, 0.3, 0.5, 100));\n    }\n\n    @Test\n    void testCalculateProportion5() {\n        assertArrayEquals(new int[]{10, 45, 45}, Main.calculateProportion(0.1, 0.45, 0.45, 100));\n    }\n\n    @Test\n    void testCalculateProportion6() {\n        assertArrayEquals(new int[]{40, 30, 30}, Main.calculateProportion(0.4, 0.3, 0.3, 100));\n    }\n\n    @Test\n    void testCalculateProportion7() {\n        assertArrayEquals(new int[]{0, 0, 1}, Main.calculateProportion(0.0, 0.0, 1.0, 1));\n    }\n\n    @Test\n    void testCalculateProportion8() {\n        assertArrayEquals(new int[]{1, 0, 0}, Main.calculateProportion(1.0, 0.0, 0.0, 1));\n    }\n\n    @Test\n    void testCalculateProportion9() {\n        assertArrayEquals(new int[]{0, 1, 0}, Main.calculateProportion(0.0, 1.0, 0.0, 1));\n    }\n\n    @Test\n    void testCalculateProportion10() {\n        assertArrayEquals(new int[]{0, 0, 0}, Main.calculateProportion(0.0, 0.0, 0.0, 0));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] result = calculateProportion(0.3, 0.4, 0.3, 100);\n        for (int i : result) {\n            System.out.println(i);\n        }\n    }\n\n    public static int[] calculateProportion(double ratio1, double ratio2, double ratio3, int total) {\n        int[] result = new int[3];\n        result[0] = (int) Math.floor(ratio1 * total);\n        result[1] = (int) Math.floor(ratio2 * total);\n        result[2] = (int) Math.floor(ratio3 * total);\n\n        int sum = result[0] + result[1] + result[2];\n        int diff = total - sum;\n\n        while (diff > 0) {\n            if (ratio1 >= ratio2 && ratio1 >= ratio3) {\n                result[0] += diff;\n            } else if (ratio2 >= ratio1 && ratio2 >= ratio3) {\n                result[1] += diff;\n            } else {\n                result[2] += diff;\n            }\n            diff--;\n        }\n\n        return result;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 138, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n输入一个字符串，打印出该字符串中字符的所有排列。\n\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\n\nabc、acb、bac、bca、cab 和 cba。用java写出来\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testBasic() {\n        assertEquals(Set.of(\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"), generatePermutations(\"abc\"));\n    }\n}", "problem": "输入一个字符串，打印出该字符串中字符的所有排列。\n\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\n\nabc、acb、bac、bca、cab 和 cba。用java写出来", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass StringPermutationsTest {\n    @Test\n    void testEmptyString() {\n        assertTrue(generatePermutations(\"\").isEmpty());\n    }\n\n    @Test\n    void testSingleCharacter() {\n        assertEquals(Set.of(\"a\"), generatePermutations(\"a\"));\n    }\n\n    @Test\n    void testTwoCharacters() {\n        assertEquals(Set.of(\"ab\", \"ba\"), generatePermutations(\"ab\"));\n    }\n\n    @Test\n    void testDuplicateCharacters() {\n        assertEquals(Set.of(\"aba\", \"aab\", \"baa\"), generatePermutations(\"aba\"));\n    }\n\n    @Test\n    void testLongString() {\n        assertEquals(24, generatePermutations(\"abcd\").size()); // 4! = 24\n    }\n\n    @Test\n    void testAllSameCharacters() {\n        assertEquals(Set.of(\"aaa\"), generatePermutations(\"aaa\"));\n    }\n\n    @Test\n    void testSpecialCharacters() {\n        assertEquals(Set.of(\"a*b\", \"ab*\", \"*ab\", \"*ba\", \"ba*\", \"b*a\"), generatePermutations(\"a*b\"));\n    }\n\n    @Test\n    void testNonASCIICharacters() {\n        assertEquals(Set.of(\"你好吗\", \"你吗好\", \"好你吗\", \"好吗你\", \"吗好你\", \"吗你好\"), generatePermutations(\"你好吗\"));\n    }\n\n    private Set<String> generatePermutations(String str) {\n        Set<String> permutations = new HashSet<>();\n        StringPermutations.permute(str.toCharArray(), 0, permutations);\n        return permutations;\n    }\n}\n", "setup_code": "", "reference_solution": "```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class StringPermutations {\n    public static void main(String[] args) {\n        String str = \"aaa\";\n        permuteAndPrint(str);\n    }\n\n    public static void permuteAndPrint(String str) {\n        Set<String> permutations = new HashSet<>();\n        permute(str.toCharArray(), 0, permutations);\n\n        for (String s : permutations) {\n            System.out.println(s);\n        }\n    }\n\n    public static void permute(char[] chars, int currentIndex, Set<String> permutations) {\n        if (currentIndex == chars.length - 1) {\n            permutations.add(new String(chars));\n        }\n\n        for (int i = currentIndex; i < chars.length; i++) {\n            swap(chars, currentIndex, i);\n            permute(chars, currentIndex + 1, permutations);\n            swap(chars, currentIndex, i); // backtrack\n        }\n    }\n\n    private static void swap(char[] array, int i, int j) {\n        char temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 139, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1. 设计程序，定义一个表示 学生”的类：Student： 类中的属性有： a）name：String型，代表学生的名字; b）ordinary: double 型，代表学生的平时成绩； c）attendance： double型，代表学生的出勤率。 类中的方法有： a）boolean qualified()：根据平时成绩和出勤率计算并返回学生的考试资格，如果平时成绩≥ 60 并且出勤率≥60% ，则返回true ，否则返回false; \n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testQualified1() {\n        Student student = new Student(\"John\", 70, 0.7);\n        assertTrue(student.qualified());\n    }\n}", "problem": "1. 设计程序，定义一个表示 学生”的类：Student： 类中的属性有： a）name：String型，代表学生的名字; b）ordinary: double 型，代表学生的平时成绩； c）attendance： double型，代表学生的出勤率。 类中的方法有： a）boolean qualified()：根据平时成绩和出勤率计算并返回学生的考试资格，如果平时成绩≥ 60 并且出勤率≥60% ，则返回true ，否则返回false; ", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass StudentTest {\n    @Test\n    void testQualified2() {\n        Student student = new Student(\"Jane\", 50, 0.7);\n        assertFalse(student.qualified());\n    }\n\n    @Test\n    void testQualified3() {\n        Student student = new Student(\"Bob\", 70, 0.5);\n        assertFalse(student.qualified());\n    }\n\n    @Test\n    void testQualified4() {\n        Student student = new Student(\"Alice\", 60, 0.6);\n        assertTrue(student.qualified());\n    }\n\n    @Test\n    void testQualified5() {\n        Student student = new Student(\"Tom\", 59.9, 0.6);\n        assertFalse(student.qualified());\n    }\n\n    @Test\n    void testQualified6() {\n        Student student = new Student(\"Jerry\", 60, 0.599);\n        assertFalse(student.qualified());\n    }\n\n    @Test\n    void testQualified7() {\n        Student student = new Student(\"Max\", 100, 1);\n        assertTrue(student.qualified());\n    }\n\n    @Test\n    void testQualified8() {\n        Student student = new Student(\"Lily\", 0, 0);\n        assertFalse(student.qualified());\n    }\n\n    @Test\n    void testQualified9() {\n        Student student = new Student(\"Sam\", 60, 1);\n        assertTrue(student.qualified());\n    }\n\n    @Test\n    void testQualified10() {\n        Student student = new Student(\"Emma\", 100, 0.6);\n        assertTrue(student.qualified());\n    }\n}", "setup_code": "", "reference_solution": "```java\n\n\npublic class Student {\n    private String name;\n    private double ordinary;\n    private double attendance;\n\n    public Student(String name, double ordinary, double attendance) {\n        this.name = name;\n        this.ordinary = ordinary;\n        this.attendance = attendance;\n    }\n\n    public boolean qualified() {\n        return ordinary >= 60 && attendance >= 0.6;\n    }\n\n    // getters and setters\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getOrdinary() {\n        return ordinary;\n    }\n\n    public void setOrdinary(double ordinary) {\n        this.ordinary = ordinary;\n    }\n\n    public double getAttendance() {\n        return attendance;\n    }\n\n    public void setAttendance(double attendance) {\n        this.attendance = attendance;\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 140, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个方法，名字是showQianFenWei(long x),用于把x用千分位展示出来，也就是从低位开始，每隔3位就添加一个逗号，比如：\n\nx=2，结果是：2\n\nx=100，结果是100\n\nx=1000，结果是1,000\n\nx=10000，结果是10,000\n\nx=1000000，结果是1,000,000\n\nx不超过15位。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testShowQianFenWei() {\n        assertEquals(\"2\", Main.showQianFenWei(2));\n        assertEquals(\"100\", Main.showQianFenWei(100));\n        assertEquals(\"1,000\", Main.showQianFenWei(1000));\n        assertEquals(\"10,000\", Main.showQianFenWei(10000));\n    }\n}", "problem": "编写一个方法，名字是showQianFenWei(long x),用于把x用千分位展示出来，也就是从低位开始，每隔3位就添加一个逗号，比如：\n\nx=2，结果是：2\n\nx=100，结果是100\n\nx=1000，结果是1,000\n\nx=10000，结果是10,000\n\nx=1000000，结果是1,000,000\n\nx不超过15位。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass MainTest {\n    @Test\n    void testShowQianFenWei2() {\n        assertEquals(\"1,000,000\", Main.showQianFenWei(1000000));\n        assertEquals(\"123,456,789\", Main.showQianFenWei(123456789));\n        assertEquals(\"1,234,567,890\", Main.showQianFenWei(1234567890));\n        assertEquals(\"12,345,678,901\", Main.showQianFenWei(12345678901L));\n        assertEquals(\"123,456,789,012\", Main.showQianFenWei(123456789012L));\n        assertEquals(\"1,234,567,890,123\", Main.showQianFenWei(1234567890123L));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(showQianFenWei(2));\n        System.out.println(showQianFenWei(100));\n        System.out.println(showQianFenWei(1000));\n        System.out.println(showQianFenWei(10000));\n        System.out.println(showQianFenWei(1000000));\n    }\n\n    public static String showQianFenWei(long x) {\n        String str = Long.toString(x);\n        String result = \"\";\n        int count = 0;\n        for (int i = str.length() - 1; i >= 0; i--) {\n            result = str.charAt(i) + result;\n            count++;\n            if (count % 3 == 0 && i != 0) {\n                result = \",\" + result;\n            }\n        }\n        return result;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 141, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建⼀个search⽅法，⽤以在给定的⾃然语⾔⽂本⽂件中搜索某个关键词出现的总次数。关键词是⼀个英⽂单词，\n例如\"go\"。⽂件中和关键词匹配的单词不区分⼤⼩写，例如GO、Go、gO、go 都算出现⼀次。同时关键词可能包\n含⼤写或⼩写字⺟。但是单词是需要完整匹配的，也就是说 google 这样的单词不算出现了go。除此之外，What’s\n这样的字符串中算出现了 what，但没有出现 is，同时只有\"what\"会作为搜索的关键词⽽\"what's\"不会。Three\u0002year-old中同时出现了three、year和 old。总结来说，单词指的是连续出现的⼤/⼩写字⺟，且单词的前⼀个和后\n⼀个字符（如果存在的话）都必须不是⼤/⼩写字⺟。使用java实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSearch1() {\n        assertEquals(4, KeywordSearch.search(\"testFile1.txt\", \"go\"));\n    }\n}", "problem": "创建⼀个search⽅法，⽤以在给定的⾃然语⾔⽂本⽂件中搜索某个关键词出现的总次数。关键词是⼀个英⽂单词，\n例如\"go\"。⽂件中和关键词匹配的单词不区分⼤⼩写，例如GO、Go、gO、go 都算出现⼀次。同时关键词可能包\n含⼤写或⼩写字⺟。但是单词是需要完整匹配的，也就是说 google 这样的单词不算出现了go。除此之外，What’s\n这样的字符串中算出现了 what，但没有出现 is，同时只有\"what\"会作为搜索的关键词⽽\"what's\"不会。Three\u0002year-old中同时出现了three、year和 old。总结来说，单词指的是连续出现的⼤/⼩写字⺟，且单词的前⼀个和后\n⼀个字符（如果存在的话）都必须不是⼤/⼩写字⺟。使用java实现", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass KeywordSearchTest {\n    @Test\n    void testSearch2() {\n        assertEquals(0, KeywordSearch.search(\"testFile2.txt\", \"go\"));\n    }\n\n    @Test\n    void testSearch3() {\n        assertEquals(1, KeywordSearch.search(\"testFile3.txt\", \"what\"));\n    }\n\n    @Test\n    void testSearch4() {\n        assertEquals(3, KeywordSearch.search(\"testFile4.txt\", \"year\"));\n    }\n\n    @Test\n    void testSearch5() {\n        assertEquals(1, KeywordSearch.search(\"testFile5.txt\", \"google\"));\n    }\n\n\n    @Test\n    void testSearch7() {\n        assertEquals(0, KeywordSearch.search(\"testFile7.txt\", \"\"));\n    }\n\n    @Test\n    void testSearch8() {\n        assertEquals(0, KeywordSearch.search(\"testFile8.txt\", \" \"));\n    }\n\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class KeywordSearch {\n    public static int search(String filePath, String keyword) {\n        int count = 0;\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(filePath));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] words = line.split(\"\\\\W+\");\n                for (String word : words) {\n                    if (word.equalsIgnoreCase(keyword)) {\n                        count++;\n                    }\n                }\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        String filePath = \"path_to_your_file\";\n        String keyword = \"your_keyword\";\n        int count = search(filePath, keyword);\n        System.out.println(\"The keyword '\" + keyword + \"' appears \" + count + \" times in the file.\");\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 142, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对一个整数数组，如果该数组为空，则返回零；如果其长度为1，则返回第一个元素。如果整\n数数组的长度大于等于 51，则返回其第51个元素；否则，如果其长度大于等于(51/2向下取整）\n，则返回第(51/2向下取整）个元素;否则，如果其长度大于等于(51/4向下取整，则返回第\n(51/4向下取整）个元素；否则，如果其长度大于等于(51/8向下取整），则返回第（51/8向下取\n整)个元素…以此类推，比较后返回符合要求的元素。  例子：输入 数组1到25 输出25 Java语言实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetElement1() {\n        int[] array = new int[25];\n        for (int i = 0; i < 25; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(25, ArrayElementSelector.selectElement(array));\n    }\n}", "problem": "对一个整数数组，如果该数组为空，则返回零；如果其长度为1，则返回第一个元素。如果整\n数数组的长度大于等于 51，则返回其第51个元素；否则，如果其长度大于等于(51/2向下取整）\n，则返回第(51/2向下取整）个元素;否则，如果其长度大于等于(51/4向下取整，则返回第\n(51/4向下取整）个元素；否则，如果其长度大于等于(51/8向下取整），则返回第（51/8向下取\n整)个元素…以此类推，比较后返回符合要求的元素。  例子：输入 数组1到25 输出25 Java语言实现", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass MainTest {\n    @Test\n    void testGetElement2() {\n        int[] array = new int[51];\n        for (int i = 0; i < 51; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(51, ArrayElementSelector.selectElement(array));\n    }\n\n    @Test\n    void testGetElement3() {\n        int[] array = new int[1];\n        array[0] = 10;\n        assertEquals(10, ArrayElementSelector.selectElement(array));\n    }\n\n    @Test\n    void testGetElement4() {\n        int[] array = new int[0];\n        assertEquals(0, ArrayElementSelector.selectElement(array));\n    }\n\n    @Test\n    void testGetElement5() {\n        int[] array = new int[26];\n        for (int i = 0; i < 26; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(25, ArrayElementSelector.selectElement(array));\n    }\n\n    @Test\n    void testGetElement6() {\n        int[] array = new int[13];\n        for (int i = 0; i < 13; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(12, ArrayElementSelector.selectElement(array));\n    }\n\n    @Test\n    void testGetElement7() {\n        int[] array = new int[100];\n        for (int i = 0; i < 100; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(51, ArrayElementSelector.selectElement(array));\n    }\n\n    @Test\n    void testGetElement8() {\n        int[] array = new int[2];\n        array[0] = 10;\n        array[1] = 20;\n        assertEquals(10, ArrayElementSelector.selectElement(array));\n    }\n\n    @Test\n    void testGetElement9() {\n        int[] array = new int[3];\n        array[0] = 10;\n        array[1] = 20;\n        array[2] = 30;\n        assertEquals(30, ArrayElementSelector.selectElement(array));\n    }\n\n    @Test\n    void testGetElement10() {\n        int[] array = new int[6];\n        for (int i = 0; i < 6; i++) {\n            array[i] = i + 1;\n        }\n        assertEquals(6, ArrayElementSelector.selectElement(array));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class ArrayElementSelector {\n    public static int selectElement(int[] array) {\n        if (array == null || array.length == 0) {\n            return 0;\n        }\n\n        if (array.length == 1) {\n            return array[0];\n        }\n\n        int threshold = 51;\n        while (threshold > 1) {\n            if (array.length >= threshold) {\n                return array[threshold - 1];\n            }\n            threshold /= 2;\n        }\n\n        return array[0];\n    }\n\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};\n        System.out.println(\"Selected element: \" + selectElement(array));\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 143, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n读入 n 阶方阵 a , 计算该矩阵除副对角线、最后一列和最后一行以外的所有元素之和.\n说明：副对角线为从矩阵的右上角至左下角的连线，例\n2 3 4 1\n5 6 1 1\n7 1 8 1\n1 1 1 1\nsum=35   (2+3+4+5+6+7+8=35)\n用Java写一个简单的程序\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCalculateSum1() {\n        int[][] matrix = {{2, 3, 4, 1}, {5, 6, 1, 1}, {7, 1, 8, 1}, {1, 1, 1, 1}};\n        assertEquals(35, Main.calculateSum(matrix, 4));\n    }\n}", "problem": "读入 n 阶方阵 a , 计算该矩阵除副对角线、最后一列和最后一行以外的所有元素之和.\n说明：副对角线为从矩阵的右上角至左下角的连线，例\n2 3 4 1\n5 6 1 1\n7 1 8 1\n1 1 1 1\nsum=35   (2+3+4+5+6+7+8=35)\n用Java写一个简单的程序", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Scanner;\n\nclass MainTest {\n    @Test\n    void testCalculateSum2() {\n        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        assertEquals(7, Main.calculateSum(matrix, 3));\n    }\n\n    @Test\n    void testCalculateSum3() {\n        int[][] matrix = {{1}};\n        assertEquals(0, Main.calculateSum(matrix, 1));\n    }\n\n    @Test\n    void testCalculateSum4() {\n        int[][] matrix = {{1, 2}, {3, 4}};\n        assertEquals(1, Main.calculateSum(matrix, 2));\n    }\n\n    @Test\n    void testCalculateSum5() {\n        int[][] matrix = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25}};\n        assertEquals(121, Main.calculateSum(matrix, 5));\n    }\n\n    @Test\n    void testCalculateSum6() {\n        int[][] matrix = {{-1, -2, -3}, {-4, -5, -6}, {-7, -8, -9}};\n        assertEquals(-7, Main.calculateSum(matrix, 3));\n    }\n\n    // boundary cases\n    @Test\n    void testCalculateSum7() {\n        int[][] matrix = new int[100][100];\n        for (int i = 0; i < 100; i++) {\n            for (int j = 0; j < 100; j++) {\n                matrix[i][j] = 1;\n            }\n        }\n        assertEquals(9703, Main.calculateSum(matrix, 100));\n    }\n\n    @Test\n    void testCalculateSum8() {\n        int[][] matrix = new int[1000][1000];\n        for (int i = 0; i < 1000; i++) {\n            for (int j = 0; j < 1000; j++) {\n                matrix[i][j] = 1;\n            }\n        }\n        assertEquals(997003, Main.calculateSum(matrix, 1000));\n    }\n\n    @Test\n    void testCalculateSum9() {\n        int[][] matrix = new int[1][1];\n        matrix[0][0] = Integer.MAX_VALUE;\n        assertEquals(0, Main.calculateSum(matrix, 1));\n    }\n\n    @Test\n    void testCalculateSum10() {\n        int[][] matrix = new int[2][2];\n        matrix[0][0] = Integer.MAX_VALUE;\n        matrix[0][1] = Integer.MAX_VALUE;\n        matrix[1][0] = Integer.MAX_VALUE;\n        matrix[1][1] = Integer.MAX_VALUE;\n        assertEquals(Integer.MAX_VALUE, Main.calculateSum(matrix, 2));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the order of the matrix:\");\n        int n = scanner.nextInt();\n        int[][] matrix = new int[n][n];\n        System.out.println(\"Enter the elements of the matrix:\");\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = scanner.nextInt();\n            }\n        }\n        scanner.close();\n        System.out.println(\"The sum of the elements excluding the anti-diagonal, last row and last column is: \" + calculateSum(matrix, n));\n    }\n\n    static int calculateSum(int[][] matrix, int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != n - 1 && j != n - 1 && j != n - 1 - i) {\n                    sum += matrix[i][j];\n                }\n            }\n        }\n        return sum;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 144, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用java实现一个闹钟系统AlarmSystem，简单来说就是实现三个方法addAlarm: 添加而钟，包括属性id、weekday[]、hour、minute，typeld。其中weekdays表示在星明几响起，可能的取值为1-7.typeld表示闹钟的类型，可能的取值为0，1，2。如果之前已经添加过相局id的两钟则不再添加。返回false，否则返回true deleteAlarm: 根据id删除闹钟。如果不存在此id的闹钟，则返回false，否则删除后返回truequeryAlarm: 给定weekday，hour，startminute、endminute，查询在weekday这一天，hour这一小时。startminute到endminute之间会响起的闹钟，如果有多个则优先按照响起的时间先后排序输出，如果响起时间一样，则按照闹钟的类型从小到大排序，如果闹钟类型也一样，则按照id从小到大排序\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\npublic void testAddAlarm() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    assertTrue(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n    assertFalse(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n}\n}", "problem": "使用java实现一个闹钟系统AlarmSystem，简单来说就是实现三个方法addAlarm: 添加而钟，包括属性id、weekday[]、hour、minute，typeld。其中weekdays表示在星明几响起，可能的取值为1-7.typeld表示闹钟的类型，可能的取值为0，1，2。如果之前已经添加过相局id的两钟则不再添加。返回false，否则返回true deleteAlarm: 根据id删除闹钟。如果不存在此id的闹钟，则返回false，否则删除后返回truequeryAlarm: 给定weekday，hour，startminute、endminute，查询在weekday这一天，hour这一小时。startminute到endminute之间会响起的闹钟，如果有多个则优先按照响起的时间先后排序输出，如果响起时间一样，则按照闹钟的类型从小到大排序，如果闹钟类型也一样，则按照id从小到大排序", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\n\nclass AlarmTest {\n@Test\npublic void testDeleteAlarm() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    alarmSystem.addAlarm(1, weekdays, 7, 30, 0);\n    assertTrue(alarmSystem.deleteAlarm(1));\n    assertFalse(alarmSystem.deleteAlarm(1));\n}\n\n@Test\npublic void testQueryAlarm() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    alarmSystem.addAlarm(1, weekdays, 7, 30, 0);\n    alarmSystem.addAlarm(2, weekdays, 7, 35, 1);\n    alarmSystem.addAlarm(3, weekdays, 7, 35, 0);\n    List<Alarm> result = alarmSystem.queryAlarm(1, 7, 30, 40);\n    assertEquals(3, result.size());\n    assertEquals(1, result.get(0).id);\n    assertEquals(3, result.get(1).id);\n    assertEquals(2, result.get(2).id);\n}\n\n@Test\npublic void testAddAlarmWithDifferentType() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    assertTrue(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n    assertTrue(alarmSystem.addAlarm(2, weekdays, 7, 30, 1));\n    assertTrue(alarmSystem.addAlarm(3, weekdays, 7, 30, 2));\n}\n\n@Test\npublic void testDeleteAlarmWithDifferentType() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    alarmSystem.addAlarm(1, weekdays, 7, 30, 0);\n    alarmSystem.addAlarm(2, weekdays, 7, 30, 1);\n    alarmSystem.addAlarm(3, weekdays, 7, 30, 2);\n    assertTrue(alarmSystem.deleteAlarm(1));\n    assertTrue(alarmSystem.deleteAlarm(2));\n    assertTrue(alarmSystem.deleteAlarm(3));\n}\n\n@Test\npublic void testQueryAlarmWithDifferentType() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    alarmSystem.addAlarm(1, weekdays, 7, 30, 0);\n    alarmSystem.addAlarm(2, weekdays, 7, 30, 1);\n    alarmSystem.addAlarm(3, weekdays, 7, 30, 2);\n    List<Alarm> result = alarmSystem.queryAlarm(1, 7, 30, 40);\n    assertEquals(3, result.size());\n    assertEquals(1, result.get(0).id);\n    assertEquals(2, result.get(1).id);\n    assertEquals(3, result.get(2).id);\n}\n\n@Test\npublic void testAddAlarmWithMaxId() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    assertTrue(alarmSystem.addAlarm(Integer.MAX_VALUE, weekdays, 7, 30, 0));\n}\n\n@Test\npublic void testDeleteAlarmWithMaxId() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    alarmSystem.addAlarm(Integer.MAX_VALUE, weekdays, 7, 30, 0);\n    assertTrue(alarmSystem.deleteAlarm(Integer.MAX_VALUE));\n    assertFalse(alarmSystem.deleteAlarm(Integer.MAX_VALUE));\n}\n\n@Test\npublic void testQueryAlarmWithMaxId() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n    alarmSystem.addAlarm(Integer.MAX_VALUE, weekdays, 7, 30, 0);\n    List<Alarm> result = alarmSystem.queryAlarm(1, 7, 30, 40);\n    assertEquals(1, result.size());\n    assertEquals(Integer.MAX_VALUE, result.get(0).id);\n}\n\n@Test\npublic void testAddAlarmWithMaxWeekday() {\n    AlarmSystem alarmSystem = new AlarmSystem();\n    Set<Integer> weekdays = new HashSet<>(Arrays.asList(7));\n    assertTrue(alarmSystem.addAlarm(1, weekdays, 7, 30, 0));\n}\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.*;\n\nclass Alarm {\n    int id;\n    Set<Integer> weekdays;\n    int hour;\n    int minute;\n    int typeId;\n\n    public Alarm(int id, Set<Integer> weekdays, int hour, int minute, int typeId) {\n        this.id = id;\n        this.weekdays = weekdays;\n        this.hour = hour;\n        this.minute = minute;\n        this.typeId = typeId;\n    }\n}\n\nclass AlarmSystem {\n    Map<Integer, Alarm> alarms;\n\n    public AlarmSystem() {\n        this.alarms = new HashMap<>();\n    }\n\n    public boolean addAlarm(int id, Set<Integer> weekdays, int hour, int minute, int typeId) {\n        if (alarms.containsKey(id)) {\n            return false;\n        }\n        alarms.put(id, new Alarm(id, weekdays, hour, minute, typeId));\n        return true;\n    }\n\n    public boolean deleteAlarm(int id) {\n        if (!alarms.containsKey(id)) {\n            return false;\n        }\n        alarms.remove(id);\n        return true;\n    }\n\n    public List<Alarm> queryAlarm(int weekday, int hour, int startMinute, int endMinute) {\n        List<Alarm> result = new ArrayList<>();\n        for (Alarm alarm : alarms.values()) {\n            if (alarm.weekdays.contains(weekday) && alarm.hour == hour && alarm.minute >= startMinute && alarm.minute <= endMinute) {\n                result.add(alarm);\n            }\n        }\n        Collections.sort(result, new Comparator<Alarm>() {\n            @Override\n            public int compare(Alarm a1, Alarm a2) {\n                if (a1.minute != a2.minute) {\n                    return a1.minute - a2.minute;\n                }\n                if (a1.typeId != a2.typeId) {\n                    return a1.typeId - a2.typeId;\n                }\n                return a1.id - a2.id;\n            }\n        });\n        return result;\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 145, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n需求：\n1. 实现 select xx from xx [where xx = xx [order by xx] [limit xx]] 等条件查询的解析\n中括号的部分表示是可选的，请给出 java 代码实现。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    public void testSelectFrom() {\n        SQLParser parser = new SQLParser(\"select name from users\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertNull(parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n}", "problem": "需求：\n1. 实现 select xx from xx [where xx = xx [order by xx] [limit xx]] 等条件查询的解析\n中括号的部分表示是可选的，请给出 java 代码实现。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SQLParserTest {\n    @Test\n    public void testSelectFromWhere() {\n        SQLParser parser = new SQLParser(\"select id from items where name = 'item'\");\n        assertEquals(\"id\", parser.getSelect());\n        assertEquals(\"items\", parser.getFrom());\n        assertEquals(\"name = 'item'\", parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n\n    @Test\n    public void testFullQuery() {\n        SQLParser parser = new SQLParser(\"select id, name from products where price > 10 order by name limit 5\");\n        assertEquals(\"id, name\", parser.getSelect());\n        assertEquals(\"products\", parser.getFrom());\n        assertEquals(\"price > 10\", parser.getWhere());\n        assertEquals(\"name\", parser.getOrderBy());\n        assertEquals(\"5\", parser.getLimit());\n    }\n\n    @Test\n    public void testSelectFromOrderBy() {\n        SQLParser parser = new SQLParser(\"select name from users order by age\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertNull(parser.getWhere());\n        assertEquals(\"age\", parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n\n    @Test\n    public void testSelectFromLimit() {\n        SQLParser parser = new SQLParser(\"select name from users limit 10\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertNull(parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertEquals(\"10\", parser.getLimit());\n    }\n\n    @Test\n    public void testSelectFromWhereOrderBy() {\n        SQLParser parser = new SQLParser(\"select name from users where age > 20 order by name\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertEquals(\"age > 20\", parser.getWhere());\n        assertEquals(\"name\", parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n\n    @Test\n    public void testSelectFromWhereLimit() {\n        SQLParser parser = new SQLParser(\"select name from users where age > 20 limit 5\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertEquals(\"age > 20\", parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertEquals(\"5\", parser.getLimit());\n    }\n\n    @Test\n    public void testSelectFromOrderByLimit() {\n        SQLParser parser = new SQLParser(\"select name from users order by age limit 5\");\n        assertEquals(\"name\", parser.getSelect());\n        assertEquals(\"users\", parser.getFrom());\n        assertNull(parser.getWhere());\n        assertEquals(\"age\", parser.getOrderBy());\n        assertEquals(\"5\", parser.getLimit());\n    }\n\n    @Test\n    public void testEmptySQL() {\n        SQLParser parser = new SQLParser(\"\");\n        assertNull(parser.getSelect());\n        assertNull(parser.getFrom());\n        assertNull(parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n\n    @Test\n    public void testInvalidSQL() {\n        SQLParser parser = new SQLParser(\"invalid sql\");\n        assertNull(parser.getSelect());\n        assertNull(parser.getFrom());\n        assertNull(parser.getWhere());\n        assertNull(parser.getOrderBy());\n        assertNull(parser.getLimit());\n    }\n}\n", "setup_code": "", "reference_solution": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SQLParser {\n    private String select;\n    private String from;\n    private String where;\n    private String orderBy;\n    private String limit;\n\n    public SQLParser(String sql) {\n        parse(sql);\n    }\n\n    private void parse(String sql) {\n        if (sql == null || sql.trim().isEmpty()) {\n            select = from = where = orderBy = limit = null;\n            return;\n        }\n\n        Pattern pattern = Pattern.compile(\"select\\\\s+(.*?)\\\\s+from\\\\s+(.*?)(?:\\\\s+where\\\\s+(.*?))?(?:\\\\s+order by\\\\s+(.*?))?(?:\\\\s+limit\\\\s+(.*?))?$\", Pattern.CASE_INSENSITIVE);\n        Matcher matcher = pattern.matcher(sql);\n        if (matcher.find()) {\n            select = matcher.group(1).trim();\n            from = matcher.group(2).trim();\n            where = matcher.group(3) != null ? matcher.group(3).trim() : null;\n            orderBy = matcher.group(4) != null ? matcher.group(4).trim() : null;\n            limit = matcher.group(5) != null ? matcher.group(5).trim() : null;\n        } else {\n            select = from = where = orderBy = limit = null;\n        }\n    }\n\n    // Getters for select, from, where, orderBy, and limit\n    // ...\n    String getSelect() {\n        return select;\n    }\n    String getFrom() {\n        return from;\n    }\n    String getWhere(){\n        return where;\n    }\n    String getOrderBy(){\n        return orderBy;\n    }\n    String getLimit(){\n        return limit;\n    }\n    public static void main(String[] args) {\n        SQLParser parser = new SQLParser(\"select name, age from users where age > 18 order by age limit 10\");\n        System.out.println(\"Select: \" + parser.getSelect());\n        System.out.println(\"From: \" + parser.getFrom());\n        System.out.println(\"Where: \" + parser.getWhere());\n        System.out.println(\"Order By: \" + parser.getOrderBy());\n        System.out.println(\"Limit: \" + parser.getLimit());\n    }\n\n\n\n\n}\n\n```", "classification": "数据库技术"}
{"_id": 146, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJAVA顺序表\n编写一个程序，实现顺序表的各种基本运算和整体建表算法（假设顺序表的元素类型为\n ElemType 为 char )，并在此基础上设计一个程序完成以下功能：\n(1）初始化顺序表 L ;\n(2)创建顺序表 L ;\n(3)输出顺序表 L ;\n(4)输出顺序表 L 的长度；\n(5)判断顺序表 L 是否为空；\n(6)输出顺序表 L 的第3个元素；\n(7)输出某一个元素的位置；\n(8)在第4个元素的位置上插入元素 f ;\n(9)输出顺序表 L ;\n(10）删除顺序表 L 的第3个元素；\n(11）输出顺序表 L ;\n(12）释放顺序表 L 。\n2单链表\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSeqList() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c', 'd', 'e'});\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('d'); add('e');}}, L.list);\n        assertEquals(5, L.getLength());\n        assertFalse(L.isEmpty());\n        assertEquals('c', L.getElement(2));\n        assertEquals(2, L.getPosition('c'));\n        L.insertElement(3, 'f');\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('f'); add('d'); add('e');}}, L.list);\n        L.deleteElement(2);\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('f'); add('d'); add('e');}}, L.list);\n        L.clearSeqList();\n        assertTrue(L.isEmpty());\n    }\n}", "problem": "JAVA顺序表\n编写一个程序，实现顺序表的各种基本运算和整体建表算法（假设顺序表的元素类型为\n ElemType 为 char )，并在此基础上设计一个程序完成以下功能：\n(1）初始化顺序表 L ;\n(2)创建顺序表 L ;\n(3)输出顺序表 L ;\n(4)输出顺序表 L 的长度；\n(5)判断顺序表 L 是否为空；\n(6)输出顺序表 L 的第3个元素；\n(7)输出某一个元素的位置；\n(8)在第4个元素的位置上插入元素 f ;\n(9)输出顺序表 L ;\n(10）删除顺序表 L 的第3个元素；\n(11）输出顺序表 L ;\n(12）释放顺序表 L 。\n2单链表", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\nclass SeqListTest {\n    @Test\n    void testSeqListWithEmptyList() {\n        SeqList L = new SeqList();\n        assertTrue(L.isEmpty());\n        assertEquals(0, L.getLength());\n    }\n\n    @Test\n    void testSeqListWithOneElement() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a'});\n        assertEquals(new ArrayList<Character>(){{add('a');}}, L.list);\n        assertEquals(1, L.getLength());\n        assertFalse(L.isEmpty());\n        assertEquals('a', L.getElement(0));\n        assertEquals(0, L.getPosition('a'));\n    }\n\n    @Test\n    void testSeqListWithTwoElements() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b'});\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b');}}, L.list);\n        assertEquals(2, L.getLength());\n        assertFalse(L.isEmpty());\n        assertEquals('b', L.getElement(1));\n        assertEquals(1, L.getPosition('b'));\n    }\n\n    @Test\n    void testSeqListWithInsertAtFirstPosition() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c'});\n        L.insertElement(0, 'd');\n        assertEquals(new ArrayList<Character>(){{add('d'); add('a'); add('b'); add('c');}}, L.list);\n    }\n\n    @Test\n    void testSeqListWithInsertAtLastPosition() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c'});\n        L.insertElement(3, 'd');\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b'); add('c'); add('d');}}, L.list);\n    }\n\n    @Test\n    void testSeqListWithDeleteAtFirstPosition() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c'});\n        L.deleteElement(0);\n        assertEquals(new ArrayList<Character>(){{add('b'); add('c');}}, L.list);\n    }\n\n    @Test\n    void testSeqListWithDeleteAtLastPosition() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c'});\n        L.deleteElement(2);\n        assertEquals(new ArrayList<Character>(){{add('a'); add('b');}}, L.list);\n    }\n\n    @Test\n    void testSeqListWithNonexistentElement() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c'});\n        assertEquals(-1, L.getPosition('d'));\n    }\n\n    @Test\n    void testSeqListWithDuplicateElements() {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'a'});\n        assertEquals(0, L.getPosition('a'));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.ArrayList;\n\npublic class SeqList {\n    ArrayList<Character> list;\n\n    public SeqList() {\n        this.list = new ArrayList<>();\n    }\n\n    public void createSeqList(char[] elements) {\n        for (char element : elements) {\n            this.list.add(element);\n        }\n    }\n\n    public void printSeqList() {\n        System.out.println(this.list);\n    }\n\n    public int getLength() {\n        return this.list.size();\n    }\n\n    public boolean isEmpty() {\n        return this.list.isEmpty();\n    }\n\n    public char getElement(int index) {\n        return this.list.get(index);\n    }\n\n    public int getPosition(char element) {\n        return this.list.indexOf(element);\n    }\n\n    public void insertElement(int index, char element) {\n        this.list.add(index, element);\n    }\n\n    public void deleteElement(int index) {\n        this.list.remove(index);\n    }\n\n    public void clearSeqList() {\n        this.list.clear();\n    }\n\n    public static void main(String[] args) {\n        SeqList L = new SeqList();\n        L.createSeqList(new char[]{'a', 'b', 'c', 'd', 'e'});\n        L.printSeqList();\n        System.out.println(\"Length: \" + L.getLength());\n        System.out.println(\"Is Empty: \" + L.isEmpty());\n        System.out.println(\"3rd Element: \" + L.getElement(2));\n        System.out.println(\"Position of 'c': \" + L.getPosition('c'));\n        L.insertElement(3, 'f');\n        L.printSeqList();\n        L.deleteElement(2);\n        L.printSeqList();\n        L.clearSeqList();\n        System.out.println(\"Is Empty: \" + L.isEmpty());\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 147, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n首先定义了两个类，分别是植物类和僵尸类。它们都含有属性: 名称、生命值、攻击力；以及方法：攻击和死亡。\n\n植物类的攻击方法会对敌方僵尸造成攻击力伤害；僵尸类的攻击方法则会对敌方植物造成攻击力伤害。当生命值小于等于0时，会触发死亡方法。死亡方法会输出相应的信息，如已经死亡或者剩余生命值是多少。\n\n接下来创建了一个Peashooter和Conehead Zombie，分别作为植物和僵尸的代表。然后通过一个for循环来模拟战斗的过程。在循环中，植物首先攻击僵尸，然后僵尸攻击植物。每次攻击后，都会调用死亡方法来确认是否有一方死亡。当一方的生命值小于等于0时，战斗结束。\n\n最后输出对应的战斗结果。\n\n\n用JAVA实现，给我实现的代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n\n    @Test\n    void testPlantConstructor() {\n        assertEquals(\"Peashooter\", peashooter.name);\n        assertEquals(100, peashooter.health);\n        assertEquals(20, peashooter.attack);\n    }\n}", "problem": "首先定义了两个类，分别是植物类和僵尸类。它们都含有属性: 名称、生命值、攻击力；以及方法：攻击和死亡。\n\n植物类的攻击方法会对敌方僵尸造成攻击力伤害；僵尸类的攻击方法则会对敌方植物造成攻击力伤害。当生命值小于等于0时，会触发死亡方法。死亡方法会输出相应的信息，如已经死亡或者剩余生命值是多少。\n\n接下来创建了一个Peashooter和Conehead Zombie，分别作为植物和僵尸的代表。然后通过一个for循环来模拟战斗的过程。在循环中，植物首先攻击僵尸，然后僵尸攻击植物。每次攻击后，都会调用死亡方法来确认是否有一方死亡。当一方的生命值小于等于0时，战斗结束。\n\n最后输出对应的战斗结果。\n\n\n用JAVA实现，给我实现的代码", "testcases": "import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PlantZombieTest {\n    private Plant peashooter;\n    private Zombie coneheadZombie;\n\n    @BeforeEach\n    void setUp() {\n        peashooter = new Plant(\"Peashooter\", 100, 20);\n        coneheadZombie = new Zombie(\"Conehead Zombie\", 150, 30);\n    }\n    @Test\n    void testZombieConstructor() {\n        assertEquals(\"Conehead Zombie\", coneheadZombie.name);\n        assertEquals(150, coneheadZombie.health);\n        assertEquals(30, coneheadZombie.attack);\n    }\n\n    @Test\n    void testPlantAttackReducesZombieHealth() {\n        peashooter.attack(coneheadZombie);\n        assertEquals(130, coneheadZombie.health);\n    }\n\n    @Test\n    void testZombieAttackReducesPlantHealth() {\n        coneheadZombie.attack(peashooter);\n        assertEquals(70, peashooter.health);\n    }\n\n    @Test\n    void testPlantDeath() {\n        peashooter.health = 0;\n        peashooter.checkDeath();\n        assertEquals(0, peashooter.health);\n    }\n\n    @Test\n    void testZombieDeath() {\n        coneheadZombie.health = 0;\n        coneheadZombie.checkDeath();\n        assertEquals(0, coneheadZombie.health);\n    }\n\n    @Test\n    void testPlantDeathAfterMultipleZombieAttacks() {\n        while (peashooter.health > 0) {\n            coneheadZombie.attack(peashooter);\n        }\n        assertTrue(peashooter.health <= 0);\n    }\n\n    @Test\n    void testZombieDeathAfterMultiplePlantAttacks() {\n        while (coneheadZombie.health > 0) {\n            peashooter.attack(coneheadZombie);\n        }\n        assertTrue(coneheadZombie.health <= 0);\n    }\n\n    @Test\n    void testPlantSurvivesAfterZombieAttack() {\n        coneheadZombie.attack(peashooter);\n        assertTrue(peashooter.health > 0);\n    }\n\n    @Test\n    void testZombieSurvivesAfterPlantAttack() {\n        peashooter.attack(coneheadZombie);\n        assertTrue(coneheadZombie.health > 0);\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\npublic class Plant {\n    String name;\n    int health;\n    int attack;\n\n    public Plant(String name, int health, int attack) {\n        this.name = name;\n        this.health = health;\n        this.attack = attack;\n    }\n\n    public void attack(Zombie zombie) {\n        zombie.health -= this.attack;\n        zombie.checkDeath();\n    }\n\n    public void checkDeath() {\n        if (this.health <= 0) {\n            System.out.println(this.name + \" is dead.\");\n        } else {\n            System.out.println(this.name + \" has \" + this.health + \" health left.\");\n        }\n    }\n}\n\nclass Zombie {\n    String name;\n    int health;\n    int attack;\n\n    public Zombie(String name, int health, int attack) {\n        this.name = name;\n        this.health = health;\n        this.attack = attack;\n    }\n\n    public void attack(Plant plant) {\n        plant.health -= this.attack;\n        plant.checkDeath();\n    }\n\n    public void checkDeath() {\n        if (this.health <= 0) {\n            System.out.println(this.name + \" is dead.\");\n        } else {\n            System.out.println(this.name + \" has \" + this.health + \" health left.\");\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Plant peashooter = new Plant(\"Peashooter\", 100, 20);\n        Zombie coneheadZombie = new Zombie(\"Conehead Zombie\", 150, 30);\n\n        for (int i = 0; i < 10; i++) {\n            peashooter.attack(coneheadZombie);\n            if (coneheadZombie.health <= 0) {\n                break;\n            }\n\n            coneheadZombie.attack(peashooter);\n            if (peashooter.health <= 0) {\n                break;\n            }\n        }\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 148, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java 写一个方法，入参为中文，输出为中文距离今天23:59:59的天数差，例如 ：今天 今日 昨天 昨日  （最近/这）近x周  \n（最近/这）近 x 天  （最近/这）近X月  转换为  1 1 2 2 x*7 x  x个月天数总和 这里的x可能是中文的一也可能是阿拉伯数字1，x最大值为12\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetDaysDifference_today() {\n        assertEquals(1, DateDifference.getDaysDifference(\"今天\"));\n    }\n}", "problem": "用java 写一个方法，入参为中文，输出为中文距离今天23:59:59的天数差，例如 ：今天 今日 昨天 昨日  （最近/这）近x周  \n（最近/这）近 x 天  （最近/这）近X月  转换为  1 1 2 2 x*7 x  x个月天数总和 这里的x可能是中文的一也可能是阿拉伯数字1，x最大值为12", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Calendar;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass DateDifferenceTest {\n    @Test\n    void testGetDaysDifference_today2() {\n        assertEquals(1, DateDifference.getDaysDifference(\"今日\"));\n    }\n\n    @Test\n    void testGetDaysDifference_yesterday() {\n        assertEquals(2, DateDifference.getDaysDifference(\"昨天\"));\n    }\n\n    @Test\n    void testGetDaysDifference_yesterday2() {\n        assertEquals(2, DateDifference.getDaysDifference(\"昨日\"));\n    }\n\n    @Test\n    void testGetDaysDifference_week() {\n        assertEquals(7, DateDifference.getDaysDifference(\"近一周\"));\n    }\n\n    @Test\n    void testGetDaysDifference_days() {\n        assertEquals(7, DateDifference.getDaysDifference(\"近7天\"));\n    }\n\n    @Test\n    void testGetDaysDifference_month() {\n        LocalDate now = LocalDate.now();\n        LocalDate pastDate = now.minusMonths(1);\n        int days = (int) ChronoUnit.DAYS.between(pastDate, now);\n        assertEquals(days, DateDifference.getDaysDifference(\"近一月\"));\n    }\n\n    @Test\n    void testGetDaysDifference_maxWeek() {\n        assertEquals(84, DateDifference.getDaysDifference(\"近十二周\"));\n    }\n\n    @Test\n    void testGetDaysDifference_maxDays() {\n        assertEquals(12, DateDifference.getDaysDifference(\"近十二天\"));\n    }\n\n    @Test\n    void testGetDaysDifference_maxMonth() {\n        LocalDate now = LocalDate.now();\n        LocalDate pastDate = now.minusMonths(12);\n        int days = (int) ChronoUnit.DAYS.between(pastDate, now);\n        assertEquals(days, DateDifference.getDaysDifference(\"近十二月\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Calendar;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DateDifference {\n    private static final Map<String, Integer> CHINESE_NUMBERS = new HashMap<String, Integer>() {{\n        put(\"一\", 1);\n        put(\"二\", 2);\n        put(\"三\", 3);\n        put(\"四\", 4);\n        put(\"五\", 5);\n        put(\"六\", 6);\n        put(\"七\", 7);\n        put(\"八\", 8);\n        put(\"九\", 9);\n        put(\"十\", 10);\n        put(\"十一\", 11);\n        put(\"十二\", 12);\n    }};\n\n    public static int getDaysDifference(String chineseDate) {\n        LocalDate now = LocalDate.now();\n        int days = 0;\n\n        if (chineseDate.contains(\"今天\") || chineseDate.contains(\"今日\")) {\n            days = 1;\n        } else if (chineseDate.contains(\"昨天\") || chineseDate.contains(\"昨日\")) {\n            days = 2;\n        } else if (chineseDate.contains(\"近\")) {\n            String numberStr = chineseDate.replaceAll(\"[^0-9一二三四五六七八九十]\", \"\");\n            int number = CHINESE_NUMBERS.containsKey(numberStr) ? CHINESE_NUMBERS.get(numberStr) : Integer.parseInt(numberStr);\n\n            if (chineseDate.contains(\"周\")) {\n                days = number * 7;\n            } else if (chineseDate.contains(\"天\")) {\n                days = number;\n            } else if (chineseDate.contains(\"月\")) {\n                LocalDate pastDate = now.minusMonths(number);\n                days = (int) ChronoUnit.DAYS.between(pastDate, now);\n            }\n        }\n\n        return days;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getDaysDifference(\"今天\")); // 1\n        System.out.println(getDaysDifference(\"昨天\")); // 2\n        System.out.println(getDaysDifference(\"近一周\")); // 7\n        System.out.println(getDaysDifference(\"近7天\")); // 7\n        System.out.println(getDaysDifference(\"近一月\")); // depends on the current date\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 149, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写private static String readPathTest(String path)方法，实现从给定路径中提取文件名称。路径层次使用`/`分割。\n 例如传入，/courses/lecture/Lecture01.pdf，应返回：Lecture01\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testReadPathTest1() {\n        assertEquals(\"Lecture01\", PathReader.readPathTest(\"/courses/lecture/Lecture01.pdf\"));\n    }\n}", "problem": "编写private static String readPathTest(String path)方法，实现从给定路径中提取文件名称。路径层次使用`/`分割。\n 例如传入，/courses/lecture/Lecture01.pdf，应返回：Lecture01", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nclass PathReaderTest {\n    @Test\n    void testReadPathTest2() {\n        assertEquals(\"index\", PathReader.readPathTest(\"/www/index.html\"));\n    }\n\n    @Test\n    void testReadPathTest3() {\n        assertEquals(\"test\", PathReader.readPathTest(\"/test.txt\"));\n    }\n\n    @Test\n    void testReadPathTest4() {\n        assertEquals(\"file\", PathReader.readPathTest(\"/dir/subdir/file.jpg\"));\n    }\n\n    @Test\n    void testReadPathTest5() {\n        assertEquals(\"document\", PathReader.readPathTest(\"/folder/document.docx\"));\n    }\n\n    @Test\n    void testReadPathTest6() {\n        assertEquals(\"image\", PathReader.readPathTest(\"/path/to/image.png\"));\n    }\n\n    @Test\n    void testReadPathTest7() {\n        assertEquals(\"file\", PathReader.readPathTest(\"/file\"));\n    }\n\n    @Test\n    void testReadPathTest8() {\n        assertEquals(\"\", PathReader.readPathTest(\"/\"));\n    }\n\n    @Test\n    void testReadPathTest9() {\n        assertEquals(\"file\", PathReader.readPathTest(\"file.txt\"));\n    }\n\n    @Test\n    void testReadPathTest10() {\n        assertEquals(\"\", PathReader.readPathTest(\"\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class PathReader {\n\n    public static String readPathTest(String path) {\n        // 检查路径是否为空或null\n        if (path == null || path.isEmpty()) {\n            return \"\";\n        }\n\n        // 查找最后一个'/'的位置\n        int lastSlashIndex = path.lastIndexOf('/');\n\n        // 从最后一个'/'之后提取文件名（包括扩展名）\n        String fileNameWithExtension = path.substring(lastSlashIndex + 1);\n\n        // 查找文件名中'.'的位置，用以去除扩展名\n        int dotIndex = fileNameWithExtension.indexOf('.');\n\n        // 如果没有扩展名，直接返回文件名\n        if (dotIndex == -1) {\n            return fileNameWithExtension;\n        }\n\n        // 返回没有扩展名的文件名\n        return fileNameWithExtension.substring(0, dotIndex);\n    }\n\n    // 可以在这里添加main方法来测试功能\n    public static void main(String[] args) {\n        String path = \"/courses/lecture/Lecture01.pdf\";\n        System.out.println(readPathTest(path)); // 应该输出 \"Lecture01\"\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 150, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java编写编写一个主类，包括2个方法。在main方法中，从键盘读入字符串，调用isRightIP(String ip)方法测试输入的字符串是否为合法的IP，正确输出true，不正确输出false。验证IP地址的方法可定义为public boolean isRightIP(String ip)，参数ip是要验证的IP地址。IP地址由4部分构成，格式为x.x.x.x；其中每个x都是0~255之间的整数，每个部分之间以“.”分隔，例如192.168.1.1。请给出至少两种方法求解该问题，其中的一种方法必须使用正则表达式。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsRightIP() {\n        assertTrue(Main.isRightIP(\"192.168.1.1\"));\n        assertFalse(Main.isRightIP(\"192.168.1.256\"));\n        assertFalse(Main.isRightIP(\"192.168.1.-1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.256\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.1.1\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1\"));\n    }\n}", "problem": "用Java编写编写一个主类，包括2个方法。在main方法中，从键盘读入字符串，调用isRightIP(String ip)方法测试输入的字符串是否为合法的IP，正确输出true，不正确输出false。验证IP地址的方法可定义为public boolean isRightIP(String ip)，参数ip是要验证的IP地址。IP地址由4部分构成，格式为x.x.x.x；其中每个x都是0~255之间的整数，每个部分之间以“.”分隔，例如192.168.1.1。请给出至少两种方法求解该问题，其中的一种方法必须使用正则表达式。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\nclass MainTest {\n    @Test\n    void testIsRightIPByRegex() {\n        assertTrue(Main.isRightIPByRegex(\"192.168.1.1\"));\n        assertFalse(Main.isRightIP(\"192.168.1.1.1\"));\n        assertFalse(Main.isRightIP(\"192.168.1\"));\n        assertFalse(Main.isRightIP(\"192.168.1.a\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.a\"));\n        assertFalse(Main.isRightIPByRegex(\"192.168.1.-1\"));\n    }\n\n    @Test\n    void testIsRightIPBoundary() {\n        assertTrue(Main.isRightIP(\"0.0.0.0\"));\n        assertTrue(Main.isRightIP(\"255.255.255.255\"));\n        assertFalse(Main.isRightIP(\"256.256.256.256\"));\n        assertFalse(Main.isRightIP(\"\"));\n    }\n\n    @Test\n    void testIsRightIPByRegexBoundary() {\n        assertTrue(Main.isRightIPByRegex(\"0.0.0.0\"));\n        assertTrue(Main.isRightIPByRegex(\"255.255.255.255\"));\n        assertFalse(Main.isRightIPByRegex(\"256.256.256.256\"));\n        assertFalse(Main.isRightIPByRegex(\"\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\n\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入IP地址：\");\n        String ip = scanner.nextLine();\n        System.out.println(\"方法一验证结果：\" + isRightIP(ip));\n        System.out.println(\"方法二验证结果：\" + isRightIPByRegex(ip));\n    }\n\n    // 方法一：使用字符串分割和整数解析\n    public static boolean isRightIP(String ip) {\n        if (ip == null || ip.length() == 0) {\n            return false;\n        }\n        String[] parts = ip.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return false;\n        }\n        for (String part : parts) {\n            try {\n                int num = Integer.parseInt(part);\n                if (num < 0 || num > 255) {\n                    return false;\n                }\n            } catch (NumberFormatException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 方法二：使用正则表达式\n    public static boolean isRightIPByRegex(String ip) {\n        if (ip == null || ip.length() == 0) {\n            return false;\n        }\n        String regex = \"^((25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)$\";\n        return Pattern.matches(regex, ip);\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 151, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java实现如下功能：\n从字符串中找出所有如下的内容：\n\"supported_mobiles\":[\"13001597927\",\"13001740938\",\"13001910099\"]\n该字符串中中括号的内容可能为空，不为空则必然存放手机号码\n请导出字符串中所有的手机号码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testExtractPhoneNumbers1() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        expected.add(\"13001740938\");\n        expected.add(\"13001910099\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n}", "problem": "用Java实现如下功能：\n从字符串中找出所有如下的内容：\n\"supported_mobiles\":[\"13001597927\",\"13001740938\",\"13001910099\"]\n该字符串中中括号的内容可能为空，不为空则必然存放手机号码\n请导出字符串中所有的手机号码", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass MainTest {\n    @Test\n    void testExtractPhoneNumbers2() {\n        String str = \"\\\"supported_mobiles\\\":[]\";\n        List<String> expected = new ArrayList<>();\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n\n    @Test\n    void testExtractPhoneNumbers3() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n\n    @Test\n    void testExtractPhoneNumbers4() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        expected.add(\"13001740938\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n\n    @Test\n    void testExtractPhoneNumbers5() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\",\\\"13001910099\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        expected.add(\"13001740938\");\n        expected.add(\"13001910099\");\n        expected.add(\"13001910099\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n\n    @Test\n    void testExtractPhoneNumbers6() {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\",\\\"13001910099\\\",\\\"13001910099\\\"]\";\n        List<String> expected = new ArrayList<>();\n        expected.add(\"13001597927\");\n        expected.add(\"13001740938\");\n        expected.add(\"13001910099\");\n        expected.add(\"13001910099\");\n        expected.add(\"13001910099\");\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n\n    @Test\n    void testExtractPhoneNumbers7() {\n        String str = \"\";\n        List<String> expected = new ArrayList<>();\n        assertEquals(expected, Main.extractPhoneNumbers(str));\n    }\n\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        String str = \"\\\"supported_mobiles\\\":[\\\"13001597927\\\",\\\"13001740938\\\",\\\"13001910099\\\"]\";\n        List<String> phoneNumbers = extractPhoneNumbers(str);\n        for (String phoneNumber : phoneNumbers) {\n            System.out.println(phoneNumber);\n        }\n    }\n\n    public static List<String> extractPhoneNumbers(String str) {\n        List<String> phoneNumbers = new ArrayList<>();\n        Pattern pattern = Pattern.compile(\"\\\"supported_mobiles\\\":\\\\[\\\"(.*?)\\\"\\\\]\");\n        Matcher matcher = pattern.matcher(str);\n        while (matcher.find()) {\n            String group = matcher.group(1);\n            String[] numbers = group.split(\"\\\",\\\"\");\n            for (String number : numbers) {\n                phoneNumbers.add(number);\n            }\n        }\n        return phoneNumbers;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 152, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对于这个讨论，你将编写一个Java程序，实现以下矩阵操作。\n• 交集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的交集。\n• 并集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的并集。\n编写主函数来测试所有的方法\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMeet1() {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, false}, {false, false}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n}", "problem": "对于这个讨论，你将编写一个Java程序，实现以下矩阵操作。\n• 交集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的交集。\n• 并集：\no 给定两个m × n的布尔矩阵，返回这两个矩阵的并集。\n编写主函数来测试所有的方法", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass MatrixOperationsTest {\n    @Test\n    void testMeet2() {\n        boolean[][] matrix1 = {{true, true}, {true, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, true}, {true, false}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n\n    @Test\n    void testMeet3() {\n        boolean[][] matrix1 = {{false, false}, {false, false}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, false}, {false, false}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n\n    @Test\n    void testMeet4() {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{true, false}, {false, true}};\n        boolean[][] expected = {{true, false}, {false, true}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n\n    @Test\n    void testMeet5() {\n        boolean[][] matrix1 = {{false, true}, {true, false}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, true}, {true, false}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n\n    @Test\n    void testMeet6() {\n        boolean[][] matrix1 = {{true, true}, {true, true}};\n        boolean[][] matrix2 = {{true, true}, {true, true}};\n        boolean[][] expected = {{true, true}, {true, true}};\n        assertArrayEquals(expected, MatrixOperations.meet(matrix1, matrix2));\n    }\n\n    @Test\n    void testJoin1() {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{true, true}, {true, true}};\n        assertArrayEquals(expected, MatrixOperations.join(matrix1, matrix2));\n    }\n\n    @Test\n    void testJoin2() {\n        boolean[][] matrix1 = {{true, true}, {true, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{true, true}, {true, true}};\n        assertArrayEquals(expected, MatrixOperations.join(matrix1, matrix2));\n    }\n\n    @Test\n    void testJoin3() {\n        boolean[][] matrix1 = {{false, false}, {false, false}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] expected = {{false, true}, {true, false}};\n        assertArrayEquals(expected, MatrixOperations.join(matrix1, matrix2));\n    }\n\n    @Test\n    void testJoin4() {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{true, false}, {false, true}};\n        boolean[][] expected = {{true, false}, {false, true}};\n        assertArrayEquals(expected, MatrixOperations.join(matrix1, matrix2));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\n\npublic class MatrixOperations {\n    public static boolean[][] meet(boolean[][] matrix1, boolean[][] matrix2) {\n        int m = matrix1.length;\n        int n = matrix1[0].length;\n        boolean[][] result = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[i][j] = matrix1[i][j] && matrix2[i][j];\n            }\n        }\n        return result;\n    }\n\n    public static boolean[][] join(boolean[][] matrix1, boolean[][] matrix2) {\n        int m = matrix1.length;\n        int n = matrix1[0].length;\n        boolean[][] result = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[i][j] = matrix1[i][j] || matrix2[i][j];\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        boolean[][] matrix1 = {{true, false}, {false, true}};\n        boolean[][] matrix2 = {{false, true}, {true, false}};\n        boolean[][] meetResult = meet(matrix1, matrix2);\n        boolean[][] joinResult = join(matrix1, matrix2);\n        System.out.println(\"Meet Result:\");\n        for (boolean[] row : meetResult) {\n            for (boolean value : row) {\n                System.out.print(value + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println(\"Join Result:\");\n        for (boolean[] row : joinResult) {\n            for (boolean value : row) {\n                System.out.print(value + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 153, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n1.设计编写一个控制台应用程序，输入某个成年人的性别、身高和体重，计算其BMI\n体重指数，计算公式：BMI= 体重/ (身高* 身高)，并得出结论。\n\n结论\n男性\n女性\n\n过轻\n指数<20\n指数<19\n\n适中\n20≤指数<25\n19≤指数<24\n\n过重\n25≤指数<30\n24≤指数<29\n\n肥胖\n30≤指数<35\n29≤指数<34\n\n非常肥胖\n指数≥35\n指数≥34\n\n\n(1) 编写一个抽象类People，具有Height(身高)，Weight(体重)两个 属性，计算BMI\n指数的方法CalculateBMI， 得到结论的抽象方法Conclusion。\n详细代码：\n\n(2) 编写两个类Man和Woman，继承People类，并重写Conclusion抽象方法。\n详细代码：\n\n\n(3) 编写控制流程，输入某个成年人的性别、身高和体重。\n详细代码：\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n@Test\nvoid testManUnderweight() {\n    Man man = new Man(1.8, 60);\n    assertEquals(\"过轻\", man.conclusion());\n}\n}", "problem": "1.设计编写一个控制台应用程序，输入某个成年人的性别、身高和体重，计算其BMI\n体重指数，计算公式：BMI= 体重/ (身高* 身高)，并得出结论。\n\n结论\n男性\n女性\n\n过轻\n指数<20\n指数<19\n\n适中\n20≤指数<25\n19≤指数<24\n\n过重\n25≤指数<30\n24≤指数<29\n\n肥胖\n30≤指数<35\n29≤指数<34\n\n非常肥胖\n指数≥35\n指数≥34\n\n\n(1) 编写一个抽象类People，具有Height(身高)，Weight(体重)两个 属性，计算BMI\n指数的方法CalculateBMI， 得到结论的抽象方法Conclusion。\n详细代码：\n\n(2) 编写两个类Man和Woman，继承People类，并重写Conclusion抽象方法。\n详细代码：\n\n\n(3) 编写控制流程，输入某个成年人的性别、身高和体重。\n详细代码：", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Scanner;\n\nclass MainTest {\n@Test\nvoid testManNormal() {\n    Man man = new Man(1.8, 75);\n    assertEquals(\"适中\", man.conclusion());\n}\n\n@Test\nvoid testManOverweight() {\n    Man man = new Man(1.8, 90);\n    assertEquals(\"过重\", man.conclusion());\n}\n\n@Test\nvoid testManObese() {\n    Man man = new Man(1.8, 110);\n    assertEquals(\"肥胖\", man.conclusion());\n}\n\n@Test\nvoid testManExtremelyObese() {\n    Man man = new Man(1.8, 130);\n    assertEquals(\"非常肥胖\", man.conclusion());\n}\n\n@Test\nvoid testWomanUnderweight() {\n    Woman woman = new Woman(1.6, 45);\n    assertEquals(\"过轻\", woman.conclusion());\n}\n\n@Test\nvoid testWomanNormal() {\n    Woman woman = new Woman(1.6, 55);\n    assertEquals(\"适中\", woman.conclusion());\n}\n\n@Test\nvoid testWomanOverweight() {\n    Woman woman = new Woman(1.6, 70);\n    assertEquals(\"过重\", woman.conclusion());\n}\n\n@Test\nvoid testWomanObese() {\n    Woman woman = new Woman(1.6, 85);\n    assertEquals(\"肥胖\", woman.conclusion());\n}\n\n@Test\nvoid testWomanExtremelyObese() {\n    Woman woman = new Woman(1.6, 100);\n    assertEquals(\"非常肥胖\", woman.conclusion());\n}\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.Scanner;\n\nabstract class People {\n    protected double height;\n    protected double weight;\n\n    public People(double height, double weight) {\n        this.height = height;\n        this.weight = weight;\n    }\n\n    public double calculateBMI() {\n        return weight / (height * height);\n    }\n\n    public abstract String conclusion();\n}\n\nclass Man extends People {\n    public Man(double height, double weight) {\n        super(height, weight);\n    }\n\n    public String conclusion() {\n        double bmi = calculateBMI();\n        if (bmi < 20) {\n            return \"过轻\";\n        } else if (bmi < 25) {\n            return \"适中\";\n        } else if (bmi < 30) {\n            return \"过重\";\n        } else if (bmi < 35) {\n            return \"肥胖\";\n        } else {\n            return \"非常肥胖\";\n        }\n    }\n}\n\nclass Woman extends People {\n    public Woman(double height, double weight) {\n        super(height, weight);\n    }\n\n    public String conclusion() {\n        double bmi = calculateBMI();\n        if (bmi < 19) {\n            return \"过轻\";\n        } else if (bmi < 24) {\n            return \"适中\";\n        } else if (bmi < 29) {\n            return \"过重\";\n        } else if (bmi < 34) {\n            return \"肥胖\";\n        } else {\n            return \"非常肥胖\";\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入性别（男/女）：\");\n        String gender = scanner.next();\n        System.out.println(\"请输入身高（米）：\");\n        double height = scanner.nextDouble();\n        System.out.println(\"请输入体重（千克）：\");\n        double weight = scanner.nextDouble();\n\n        People people;\n        if (gender.equals(\"男\")) {\n            people = new Man(height, weight);\n        } else {\n            people = new Woman(height, weight);\n        }\n\n        System.out.println(\"BMI指数为：\" + people.calculateBMI());\n        System.out.println(\"结论为：\" + people.conclusion());\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 154, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给出下面的html代码，怎么用jsoup 获取内容Ihtesham Haider，html代码如下 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div dir=\"ltr\" class=\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\">Ihtesham Haider</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMain1() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Ihtesham Haider</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Ihtesham Haider\", content);\n    }\n}", "problem": "给出下面的html代码，怎么用jsoup 获取内容Ihtesham Haider，html代码如下 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div dir=\"ltr\" class=\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\">Ihtesham Haider</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\nclass MainTest {\n    @Test\n    void testMain2() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">John Doe</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"John Doe\", content);\n    }\n\n    @Test\n    void testMain3() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Jane Doe</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Jane Doe\", content);\n    }\n\n    @Test\n    void testMain4() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Alice Bob</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Alice Bob\", content);\n    }\n\n    @Test\n    void testMain5() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Charlie Doe</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Charlie Doe\", content);\n    }\n\n    @Test\n    void testMain6() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">David Smith</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"David Smith\", content);\n    }\n\n    @Test\n    void testMain7() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Eve Alice</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Eve Alice\", content);\n    }\n\n    @Test\n    void testMain8() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Frank Doe</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Frank Doe\", content);\n    }\n\n    @Test\n    void testMain9() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Grace Hopper</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Grace Hopper\", content);\n    }\n\n    @Test\n    void testMain10() {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\" +\n                \"<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Helen Doe</span>\" +\n                \"</span>\" +\n                \"</div>\";\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        assertEquals(\"Helen Doe\", content);\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\npublic class Main {\n    public static void main(String[] args) {\n        String html = \"<div dir=\\\"ltr\\\" class=\\\"css-901oao r-1awozwy r-18jsvk2 r-6koalj r-37j5jr r-a023e6 r-b88u0q r-rjixqe r-bcqeeo r-1udh08x r-3s2u2q r-qvutc0\\\">\\n\" +\n                \"\\t<span class=\\\"css-901oao css-16my406 css-1hf3ou5 r-poiln3 r-bcqeeo r-qvutc0\\\">\\n\" +\n                \"\\t\\t<span class=\\\"css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0\\\">Ihtesham Haider</span>\\n\" +\n                \"\\t</span>\\n\" +\n                \"</div>\";\n\n        Document doc = Jsoup.parse(html);\n        Element span = doc.select(\"span.css-901oao.css-16my406.r-poiln3.r-bcqeeo.r-qvutc0\").first();\n        String content = span.text();\n        System.out.println(content);\n    }\n}\n\n```", "classification": "前端开发"}
{"_id": 155, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用作业系统提交java作业时，需要输入java源代码文件名和自己的邮箱，\n提交前对java文件名及邮箱进行有效性检查。编写程序对输入的java文件名及\n及邮箱进行有效性检查。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsValidJavaFileName1() {\n        assertTrue(Main.isValidJavaFileName(\"Test.java\"));\n    }\n}", "problem": "使用作业系统提交java作业时，需要输入java源代码文件名和自己的邮箱，\n提交前对java文件名及邮箱进行有效性检查。编写程序对输入的java文件名及\n及邮箱进行有效性检查。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass MainTest {\n    @Test\n    void testIsValidJavaFileName2() {\n        assertFalse(Main.isValidJavaFileName(\"Test.txt\"));\n    }\n\n    @Test\n    void testIsValidJavaFileName3() {\n        assertFalse(Main.isValidJavaFileName(\"Test\"));\n    }\n\n    @Test\n    void testIsValidJavaFileName4() {\n        assertTrue(Main.isValidJavaFileName(\"Test.JAVA\"));\n    }\n\n    @Test\n    void testIsValidJavaFileName5() {\n        assertFalse(Main.isValidJavaFileName(\"Test.JAVA.txt\"));\n    }\n\n    @Test\n    void testIsValidJavaFileName6() {\n        assertTrue(Main.isValidJavaFileName(\"123.java\"));\n    }\n\n    @Test\n    void testIsValidEmail1() {\n        assertTrue(Main.isValidEmail(\"test@example.com\"));\n    }\n\n    @Test\n    void testIsValidEmail2() {\n        assertFalse(Main.isValidEmail(\"test@example\"));\n    }\n\n    @Test\n    void testIsValidEmail3() {\n        assertFalse(Main.isValidEmail(\"test@.com\"));\n    }\n\n    @Test\n    void testIsValidEmail4() {\n        assertFalse(Main.isValidEmail(\"test.com\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        String fileName = \"Test.java\";\n        String email = \"test@example.com\";\n\n        if (isValidJavaFileName(fileName) && isValidEmail(email)) {\n            System.out.println(\"Java file name and email are valid.\");\n        } else {\n            System.out.println(\"Java file name or email is invalid.\");\n        }\n    }\n\n    public static boolean isValidJavaFileName(String fileName) {\n        // 文件名不能为空，且必须以.java结尾\n        return fileName != null && !fileName.isEmpty() && fileName.toLowerCase().endsWith(\".java\");\n    }\n\n    public static boolean isValidEmail(String email) {\n        String regex = \"^[a-zA-Z0-9_+&*-]+(?:\\\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,7}$\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(email);\n        return matcher.matches();\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 156, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n如何使用fastjson快速给xAxis中的data以及series赋值，必须使用如下json\n{\n\t\"xAxis\": {\n\t\t\"type\": \"category\",\n\t\t\"data\": [\n\t\t\t\"Mon\",\n\t\t\t\"Tue\",\n\t\t\t\"Wed\",\n\t\t\t\"Thu\",\n\t\t\t\"Fri\",\n\t\t\t\"Sat\",\n\t\t\t\"Sun\"\n\t\t]\n\t},\n\t\"yAxis\": {\n\t\t\"type\": \"value\"\n\t},\n\t\"series\": [{\n\t\t\"data\": [\n\t\t\t150,\n\t\t\t230,\n\t\t\t224,\n\t\t\t218,\n\t\t\t135,\n\t\t\t147,\n\t\t\t260\n\t\t],\n\t\t\"type\": \"line\"\n\t}]\n}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMain1() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n        assertEquals(\"Tue\", xAxisData.getString(1));\n        assertEquals(\"Wed\", xAxisData.getString(2));\n        assertEquals(\"Thu\", xAxisData.getString(3));\n        assertEquals(\"Fri\", xAxisData.getString(4));\n        assertEquals(\"Sat\", xAxisData.getString(5));\n        assertEquals(\"Sun\", xAxisData.getString(6));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData = series.getJSONObject(0);\n        JSONArray data = seriesData.getJSONArray(\"data\");\n        assertEquals(150, data.getInteger(0));\n        assertEquals(230, data.getInteger(1));\n        assertEquals(224, data.getInteger(2));\n        assertEquals(218, data.getInteger(3));\n        assertEquals(135, data.getInteger(4));\n        assertEquals(147, data.getInteger(5));\n        assertEquals(260, data.getInteger(6));\n    }\n}", "problem": "如何使用fastjson快速给xAxis中的data以及series赋值，必须使用如下json\n{\n\t\"xAxis\": {\n\t\t\"type\": \"category\",\n\t\t\"data\": [\n\t\t\t\"Mon\",\n\t\t\t\"Tue\",\n\t\t\t\"Wed\",\n\t\t\t\"Thu\",\n\t\t\t\"Fri\",\n\t\t\t\"Sat\",\n\t\t\t\"Sun\"\n\t\t]\n\t},\n\t\"yAxis\": {\n\t\t\"type\": \"value\"\n\t},\n\t\"series\": [{\n\t\t\"data\": [\n\t\t\t150,\n\t\t\t230,\n\t\t\t224,\n\t\t\t218,\n\t\t\t135,\n\t\t\t147,\n\t\t\t260\n\t\t],\n\t\t\"type\": \"line\"\n\t}]\n}", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.alibaba.fastjson2.JSON;\nimport com.alibaba.fastjson2.JSONArray;\nimport com.alibaba.fastjson2.JSONObject;\n\nclass MainTest {\n    @Test\n    void testMain2() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": []\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": []\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(0, xAxisData.size());\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        assertEquals(0, series.size());\n    }\n\n    @Test\n    void testMain3() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData = series.getJSONObject(0);\n        JSONArray data = seriesData.getJSONArray(\"data\");\n        assertEquals(150, data.getInteger(0));\n    }\n\n    @Test\n    void testMain4() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}, {\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t100,\\n\" +\n                \"\\t\\t\\t200,\\n\" +\n                \"\\t\\t\\t300,\\n\" +\n                \"\\t\\t\\t400,\\n\" +\n                \"\\t\\t\\t500,\\n\" +\n                \"\\t\\t\\t600,\\n\" +\n                \"\\t\\t\\t700\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n        assertEquals(\"Tue\", xAxisData.getString(1));\n        assertEquals(\"Wed\", xAxisData.getString(2));\n        assertEquals(\"Thu\", xAxisData.getString(3));\n        assertEquals(\"Fri\", xAxisData.getString(4));\n        assertEquals(\"Sat\", xAxisData.getString(5));\n        assertEquals(\"Sun\", xAxisData.getString(6));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData1 = series.getJSONObject(0);\n        JSONArray data1 = seriesData1.getJSONArray(\"data\");\n        assertEquals(150, data1.getInteger(0));\n        assertEquals(230, data1.getInteger(1));\n        assertEquals(224, data1.getInteger(2));\n        assertEquals(218, data1.getInteger(3));\n        assertEquals(135, data1.getInteger(4));\n        assertEquals(147, data1.getInteger(5));\n        assertEquals(260, data1.getInteger(6));\n\n        JSONObject seriesData2 = series.getJSONObject(1);\n        JSONArray data2 = seriesData2.getJSONArray(\"data\");\n        assertEquals(100, data2.getInteger(0));\n        assertEquals(200, data2.getInteger(1));\n        assertEquals(300, data2.getInteger(2));\n        assertEquals(400, data2.getInteger(3));\n        assertEquals(500, data2.getInteger(4));\n        assertEquals(600, data2.getInteger(5));\n        assertEquals(700, data2.getInteger(6));\n    }\n\n    @Test\n    void testMain5() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}, {\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t100,\\n\" +\n                \"\\t\\t\\t200,\\n\" +\n                \"\\t\\t\\t300,\\n\" +\n                \"\\t\\t\\t400,\\n\" +\n                \"\\t\\t\\t500,\\n\" +\n                \"\\t\\t\\t600,\\n\" +\n                \"\\t\\t\\t700\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}, {\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t50,\\n\" +\n                \"\\t\\t\\t100,\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t200,\\n\" +\n                \"\\t\\t\\t250,\\n\" +\n                \"\\t\\t\\t300,\\n\" +\n                \"\\t\\t\\t350\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n        assertEquals(\"Tue\", xAxisData.getString(1));\n        assertEquals(\"Wed\", xAxisData.getString(2));\n        assertEquals(\"Thu\", xAxisData.getString(3));\n        assertEquals(\"Fri\", xAxisData.getString(4));\n        assertEquals(\"Sat\", xAxisData.getString(5));\n        assertEquals(\"Sun\", xAxisData.getString(6));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData1 = series.getJSONObject(0);\n        JSONArray data1 = seriesData1.getJSONArray(\"data\");\n        assertEquals(150, data1.getInteger(0));\n        assertEquals(230, data1.getInteger(1));\n        assertEquals(224, data1.getInteger(2));\n        assertEquals(218, data1.getInteger(3));\n        assertEquals(135, data1.getInteger(4));\n        assertEquals(147, data1.getInteger(5));\n        assertEquals(260, data1.getInteger(6));\n\n        JSONObject seriesData2 = series.getJSONObject(1);\n        JSONArray data2 = seriesData2.getJSONArray(\"data\");\n        assertEquals(100, data2.getInteger(0));\n        assertEquals(200, data2.getInteger(1));\n        assertEquals(300, data2.getInteger(2));\n        assertEquals(400, data2.getInteger(3));\n        assertEquals(500, data2.getInteger(4));\n        assertEquals(600, data2.getInteger(5));\n        assertEquals(700, data2.getInteger(6));\n\n        JSONObject seriesData3 = series.getJSONObject(2);\n        JSONArray data3 = seriesData3.getJSONArray(\"data\");\n        assertEquals(50, data3.getInteger(0));\n        assertEquals(100, data3.getInteger(1));\n        assertEquals(150, data3.getInteger(2));\n        assertEquals(200, data3.getInteger(3));\n        assertEquals(250, data3.getInteger(4));\n        assertEquals(300, data3.getInteger(5));\n        assertEquals(350, data3.getInteger(6));\n    }\n\n    @Test\n    void testMain6() {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}, {\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t100\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}, {\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t50\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        assertEquals(\"Mon\", xAxisData.getString(0));\n\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        JSONObject seriesData1 = series.getJSONObject(0);\n        JSONArray data1 = seriesData1.getJSONArray(\"data\");\n        assertEquals(150, data1.getInteger(0));\n\n        JSONObject seriesData2 = series.getJSONObject(1);\n        JSONArray data2 = seriesData2.getJSONArray(\"data\");\n        assertEquals(100, data2.getInteger(0));\n\n        JSONObject seriesData3 = series.getJSONObject(2);\n        JSONArray data3 = seriesData3.getJSONArray(\"data\");\n        assertEquals(50, data3.getInteger(0));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport com.alibaba.fastjson2.JSON;\nimport com.alibaba.fastjson2.JSONArray;\nimport com.alibaba.fastjson2.JSONObject;\n\npublic class Main {\n    public static void main(String[] args) {\n        String jsonStr = \"{\\n\" +\n                \"\\t\\\"xAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"category\\\",\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t\\\"Mon\\\",\\n\" +\n                \"\\t\\t\\t\\\"Tue\\\",\\n\" +\n                \"\\t\\t\\t\\\"Wed\\\",\\n\" +\n                \"\\t\\t\\t\\\"Thu\\\",\\n\" +\n                \"\\t\\t\\t\\\"Fri\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sat\\\",\\n\" +\n                \"\\t\\t\\t\\\"Sun\\\"\\n\" +\n                \"\\t\\t]\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"yAxis\\\": {\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"value\\\"\\n\" +\n                \"\\t},\\n\" +\n                \"\\t\\\"series\\\": [{\\n\" +\n                \"\\t\\t\\\"data\\\": [\\n\" +\n                \"\\t\\t\\t150,\\n\" +\n                \"\\t\\t\\t230,\\n\" +\n                \"\\t\\t\\t224,\\n\" +\n                \"\\t\\t\\t218,\\n\" +\n                \"\\t\\t\\t135,\\n\" +\n                \"\\t\\t\\t147,\\n\" +\n                \"\\t\\t\\t260\\n\" +\n                \"\\t\\t],\\n\" +\n                \"\\t\\t\\\"type\\\": \\\"line\\\"\\n\" +\n                \"\\t}]\\n\" +\n                \"}\";\n\n        JSONObject jsonObject = JSON.parseObject(jsonStr);\n\n        // Get xAxis data\n        JSONObject xAxis = jsonObject.getJSONObject(\"xAxis\");\n        JSONArray xAxisData = xAxis.getJSONArray(\"data\");\n        for (int i = 0; i < xAxisData.size(); i++) {\n            System.out.println(xAxisData.getString(i));\n        }\n\n        // Get series data\n        JSONArray series = jsonObject.getJSONArray(\"series\");\n        for (int i = 0; i < series.size(); i++) {\n            JSONObject seriesData = series.getJSONObject(i);\n            JSONArray data = seriesData.getJSONArray(\"data\");\n            for (int j = 0; j < data.size(); j++) {\n                System.out.println(data.getInteger(j));\n            }\n        }\n    }\n}\n\n```", "classification": "前端开发"}
{"_id": 157, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n输入字符串是这种 格式ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\n我需要先通过 ； 分割 再拿到每组最后一个&&右边的值，再去重，再根据是否有枚举类里面的值进行过滤 枚举是\npublic enum RiskRejectCategoryEnum {\n\n    /**\n     * The smaller the value of priority, the higher the priority\n     */\n    black_email(\"black_email\", \"GREYLIST\",1 ,\"灰名单\"),\n    rule_email(\"rule_email\", \"NON_GREYLIST\", 2,\"非灰名单\"),\n    no_email(\"no_email\", \"NO_EMAIL\", 99,\"不需要发邮箱\");}\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testFilterValues1() {\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"black_email\", \"no_email\", \"rule_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n}", "problem": "输入字符串是这种 格式ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\n我需要先通过 ； 分割 再拿到每组最后一个&&右边的值，再去重，再根据是否有枚举类里面的值进行过滤 枚举是\npublic enum RiskRejectCategoryEnum {\n\n    /**\n     * The smaller the value of priority, the higher the priority\n     */\n    black_email(\"black_email\", \"GREYLIST\",1 ,\"灰名单\"),\n    rule_email(\"rule_email\", \"NON_GREYLIST\", 2,\"非灰名单\"),\n    no_email(\"no_email\", \"NO_EMAIL\", 99,\"不需要发邮箱\");}", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nclass MainTest {\n    @Test\n    void testFilterValues2() {\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&black_email;ANTIFRAUD&&black_email;ANTIFRAUD&&black_email\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"black_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n\n    @Test\n    void testFilterValues3() {\n        String input = \"ANTIFRAUD&&no_email;ANTIFRAUD&&no_email;ANTIFRAUD&&no_email;ANTIFRAUD&&no_email\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"no_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n\n    @Test\n    void testFilterValues4() {\n        String input = \"ANTIFRAUD&&rule_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&rule_email\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"rule_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n\n    @Test\n    void testFilterValues5() {\n        String input = \"ANTIFRAUD&&infoCOde1&&TEST;ANTIFRAUD&&infoCOde2&&TEST;ANTIFRAUD&&infoCOde3&&TEST;ANTIFRAUD&&infoCOde4&&TEST\";\n        Set<String> expected = new HashSet<>();\n        assertEquals(expected, Main.filterValues(input));\n    }\n\n    @Test\n    void testFilterValues6() {\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&infoCOde1&&TEST;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"black_email\", \"no_email\", \"rule_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n\n    @Test\n    void testFilterValues7() {\n        String input = \"\";\n        Set<String> expected = new HashSet<>();\n        assertEquals(expected, Main.filterValues(input));\n    }\n\n    @Test\n    void testFilterValues8() {\n        String input = \"ANTIFRAUD&&black_email\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"black_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n\n    @Test\n    void testFilterValues9() {\n        String input = \"ANTIFRAUD&&no_email\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"no_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n\n    @Test\n    void testFilterValues10() {\n        String input = \"ANTIFRAUD&&rule_email\";\n        Set<String> expected = new HashSet<>(Arrays.asList(\"rule_email\"));\n        assertEquals(expected, Main.filterValues(input));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        String input = \"ANTIFRAUD&&black_email;ANTIFRAUD&&no_email;ANTIFRAUD&&rule_email;ANTIFRAUD&&infoCOde1&&TEST\";\n        Set<String> result = filterValues(input);\n        System.out.println(result);\n    }\n\n    public static Set<String> filterValues(String input) {\n        Set<String> enumValues = Arrays.stream(RiskRejectCategoryEnum.values())\n                .map(RiskRejectCategoryEnum::getName)\n                .collect(Collectors.toSet());\n\n        String[] parts = input.split(\";\");\n        Set<String> values = new HashSet<>();\n        for (String part : parts) {\n            String[] subParts = part.split(\"&&\");\n            String value = subParts[subParts.length - 1];\n            if (enumValues.contains(value)) {\n                values.add(value);\n            }\n        }\n        return values;\n    }\n}\n\nenum RiskRejectCategoryEnum {\n    black_email(\"black_email\", \"GREYLIST\",1 ,\"灰名单\"),\n    rule_email(\"rule_email\", \"NON_GREYLIST\", 2,\"非灰名单\"),\n    no_email(\"no_email\", \"NO_EMAIL\", 99,\"不需要发邮箱\");\n\n    private String name;\n    private String description;\n    private int priority;\n    private String chineseDescription;\n\n    RiskRejectCategoryEnum(String name, String description, int priority, String chineseDescription) {\n        this.name = name;\n        this.description = description;\n        this.priority = priority;\n        this.chineseDescription = chineseDescription;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 158, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n（检测密码）编写一个java方法，检测字符串是否是一个有效密码。\n\n密码规则如下：\n\n密码必须至少8位字符\n\n密码仅能包含字母和数字\n\n密码必须包含至少两个数字\n\n编写一个程序，提示用户输入一个密码，如果符合规则，则显示Valid Password，否则显示Invalid Password。\n\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(Main.isValidPassword(\"Password123\"));\n    }\n}", "problem": "（检测密码）编写一个java方法，检测字符串是否是一个有效密码。\n\n密码规则如下：\n\n密码必须至少8位字符\n\n密码仅能包含字母和数字\n\n密码必须包含至少两个数字\n\n编写一个程序，提示用户输入一个密码，如果符合规则，则显示Valid Password，否则显示Invalid Password。\n\n", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Scanner;\n\nclass MainTest {\n    @Test\n    void testIsValidPassword2() {\n        assertFalse(Main.isValidPassword(\"Password\"));\n    }\n\n    @Test\n    void testIsValidPassword3() {\n        assertTrue(Main.isValidPassword(\"password123\"));\n    }\n\n    @Test\n    void testIsValidPassword4() {\n        assertTrue(Main.isValidPassword(\"12345678\"));\n    }\n\n    @Test\n    void testIsValidPassword5() {\n        assertFalse(Main.isValidPassword(\"Passw0rd\"));\n    }\n\n    @Test\n    void testIsValidPassword6() {\n        assertTrue(Main.isValidPassword(\"passw0rd123\"));\n    }\n\n    @Test\n    void testIsValidPassword7() {\n        assertTrue(Main.isValidPassword(\"Password1234567890\"));\n    }\n\n    @Test\n    void testIsValidPassword8() {\n        assertTrue(Main.isValidPassword(\"P1234567\"));\n    }\n\n    @Test\n    void testIsValidPassword9() {\n        assertFalse(Main.isValidPassword(\"Password!@#\"));\n    }\n\n    @Test\n    void testIsValidPassword10() {\n        assertFalse(Main.isValidPassword(\"P@ssw0rd123\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.print(\"Enter a password: \");\n        String password = input.nextLine();\n\n        if (isValidPassword(password)) {\n            System.out.println(\"Valid Password\");\n        } else {\n            System.out.println(\"Invalid Password\");\n        }\n    }\n\n    public static boolean isValidPassword(String password) {\n        if (password.length() < 8) { \n            return false;\n        } else {   \n            int charCount = 0;\n            int numCount = 0;\n            for (int i = 0; i < password.length(); i++) {\n                char ch = password.charAt(i);\n                if (isNumeric(ch)) numCount++;\n                else if (isLetter(ch)) charCount++;\n                else return false;\n            }\n            return numCount >= 2;\n        }\n    }\n\n    public static boolean isLetter(char ch) {\n        ch = Character.toUpperCase(ch);\n        return (ch >= 'A' && ch <= 'Z');\n    }\n\n    public static boolean isNumeric(char ch) {\n        return (ch >= '0' && ch <= '9');\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 159, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n使用单例模式的思想实现多例模式，确保系统中某个类的对象只能存在有限个，如3个(Threeleton)。设计并编写Java代码实现该多例模式。然后使用多线程来测试三例模式，并请输出获取到的每个实例的编号（如0,1,2）。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testGetInstance_MultipleThreads_1() throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[1];\n        for (int i = 0; i < 1; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        assertEquals(0, ids[0].get());\n        assertEquals(0, ids[1].get());\n        assertEquals(0, ids[2].get());\n    }\n}", "problem": "使用单例模式的思想实现多例模式，确保系统中某个类的对象只能存在有限个，如3个(Threeleton)。设计并编写Java代码实现该多例模式。然后使用多线程来测试三例模式，并请输出获取到的每个实例的编号（如0,1,2）。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nclass ThreeletonTest {\n    @Test\n    void testGetInstance() {\n        Threeleton instance1 = Threeleton.getInstance();\n        assertEquals(0, instance1.getId());\n\n        Threeleton instance2 = Threeleton.getInstance();\n        assertEquals(1, instance2.getId());\n\n        Threeleton instance3 = Threeleton.getInstance();\n        assertEquals(2, instance3.getId());\n\n        Threeleton instance4 = Threeleton.getInstance();\n        assertEquals(0, instance4.getId());\n\n        Threeleton instance5 = Threeleton.getInstance();\n        assertEquals(1, instance5.getId());\n    }\n\n    @Test\n    void testGetInstanceWithThreads() throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i < 10; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        assertEquals(3, ids[0].get());\n        assertEquals(3, ids[1].get());\n        assertEquals(4, ids[2].get());\n    }\n\n    @Test\n    void testGetInstanceWithMoreThreads() throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[100];\n        for (int i = 0; i < 100; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        assertEquals(34, ids[0].get());\n        assertEquals(33, ids[1].get());\n        assertEquals(33, ids[2].get());\n    }\n\n    @Test\n    void testGetInstanceWithNoThreads() {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        for (int i = 0; i < 3; i++) {\n            Threeleton instance = Threeleton.getInstance();\n            ids[instance.getId()].incrementAndGet();\n        }\n\n        assertEquals(1, ids[0].get());\n        assertEquals(1, ids[1].get());\n        assertEquals(1, ids[2].get());\n    }\n\n\n    @Test\n    void testGetInstance_MultipleThreads_1000() throws InterruptedException {\n        AtomicInteger[] ids = new AtomicInteger[3];\n        for (int i = 0; i < 3; i++) {\n            ids[i] = new AtomicInteger(0);\n        }\n\n        Thread[] threads = new Thread[1000];\n        for (int i = 0; i < 1000; i++) {\n            threads[i] = new Thread(() -> {\n                Threeleton instance = Threeleton.getInstance();\n                ids[instance.getId()].incrementAndGet();\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        assertEquals(333, ids[0].get());\n        assertEquals(334, ids[1].get());\n        assertEquals(333, ids[2].get());\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\nclass Threeleton {\n    private static final int MAX_INSTANCE_COUNT = 3;\n    private static final Threeleton[] instances = new Threeleton[MAX_INSTANCE_COUNT];\n    private static final AtomicInteger count = new AtomicInteger(0);\n    private final int id;\n\n    static {\n        for (int i = 0; i < MAX_INSTANCE_COUNT; i++) {\n            instances[i] = new Threeleton(i);\n        }\n    }\n\n    private Threeleton(int id) {\n        this.id = id;\n    }\n\n    public static Threeleton getInstance() {\n        return instances[count.getAndIncrement() % MAX_INSTANCE_COUNT];\n    }\n\n    public int getId() {\n        return id;\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 160, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用Java设计一个方法\npublic static void encodeFile(File encodingFile, File encodedFile);\n用如下规则的加密手段，并将给定的encodingFile文本文件中的内容进行加密，然后保存到encodedFile文件中\n加密规则：\n1.数字： 如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4 如果是9的数字，变成0\n2.字母字符： 如果是非z字符，向右移动一个，比如d变成e, G变成H 如果是z，z->a, Z-A。\n   注：字母字符加密的过程不能改变大小写\n3.非数字和字母的字符则保持不变即可，比如汉字和标点符号等都只需要保持不变即可\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileEncoderTest {\n\n\n    @Test\n    void testEncodeDigits() throws IOException {\n        // 测试数字的加密，包括边界情况9\n        File input = new File(\"testEncodeDigits.txt\");\n        File output = new File(\"testEncodeDigitsOutput.txt\");\n        // 假设input文件内容为 \"123456789\"\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"234567890\", readFileContent(output));\n    }\n}", "problem": "用Java设计一个方法\npublic static void encodeFile(File encodingFile, File encodedFile);\n用如下规则的加密手段，并将给定的encodingFile文本文件中的内容进行加密，然后保存到encodedFile文件中\n加密规则：\n1.数字： 如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4 如果是9的数字，变成0\n2.字母字符： 如果是非z字符，向右移动一个，比如d变成e, G变成H 如果是z，z->a, Z-A。\n   注：字母字符加密的过程不能改变大小写\n3.非数字和字母的字符则保持不变即可，比如汉字和标点符号等都只需要保持不变即可", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileEncoderTest {\n\n\n    // 辅助方法，用于读取文件内容并返回字符串\n    private String readFileContent(File file) throws IOException {\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content.append(line);\n                // 添加换行符以匹配原始文件格式，除非是文件的最后一行\n                content.append(System.lineSeparator());\n            }\n        }\n        // 移除最后一个多余的换行符\n        return content.toString().trim();\n    }\n    @Test\n    void testEncodeLetters() throws IOException {\n        // 测试字母的加密，包括边界情况z和Z\n        File input = new File(\"testEncodeLetters.txt\");\n        File output = new File(\"testEncodeLettersOutput.txt\");\n        // 假设input文件内容为 \"abcxyzABCXYZ\"\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"bcdyzaBCDYZA\", readFileContent(output));\n    }\n\n    @Test\n    void testEncodeMixedContent() throws IOException {\n        // 测试数字、字母和特殊字符混合加密\n        File input = new File(\"testEncodeMixedContent.txt\");\n        File output = new File(\"testEncodeMixedContentOutput.txt\");\n        // 假设input文件内容为 \"a1zZ9!@\"\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"b2aA0!@\", readFileContent(output));\n    }\n\n    @Test\n    void testEncodeNonAlphanumeric() throws IOException {\n        // 测试非字母数字字符保持不变\n        File input = new File(\"testEncodeNonAlphanumeric.txt\");\n        File output = new File(\"testEncodeNonAlphanumericOutput.txt\");\n        // 假设input文件内容为 \"@#$%^&*()\"\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"@#$%^&*()\", readFileContent(output));\n    }\n\n    @Test\n    void testEncodeEmptyFile() throws IOException {\n        // 测试空文件\n        File input = new File(\"testEncodeEmptyFile.txt\");\n        File output = new File(\"testEncodeEmptyFileOutput.txt\");\n        // 假设input文件内容为空\n        FileEncoder.encodeFile(input, output);\n        assertEquals(\"\", readFileContent(output));\n    }\n\n}\n", "setup_code": "", "reference_solution": "```java\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileEncoder {\n\n    public static void encodeFile(File encodingFile, File encodedFile) {\n        try (FileReader reader = new FileReader(encodingFile);\n             FileWriter writer = new FileWriter(encodedFile)) {\n            int c;\n            while ((c = reader.read()) != -1) {\n                char character = (char) c;\n                if (Character.isDigit(character)) {\n                    // 数字加密规则\n                    character = character == '9' ? '0' : (char) (character + 1);\n                } else if (Character.isLetter(character)) {\n                    // 字母加密规则\n                    if (character == 'z') {\n                        character = 'a';\n                    } else if (character == 'Z') {\n                        character = 'A';\n                    } else if ((character >= 'a' && character < 'z') || (character >= 'A' && character < 'Z')) {\n                        character = (char) (character + 1);\n                    }\n                }\n                // 非数字和字母的字符保持不变\n                writer.write(character);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        // 示例使用方法\n        File encodingFile = new File(\"path/to/your/input.txt\"); // 指定要加密的文件路径\n        File encodedFile = new File(\"path/to/your/output.txt\"); // 指定加密后文件的保存路径\n        encodeFile(encodingFile, encodedFile);\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 161, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java2.利用Map，完成下面的功能：\n   1.从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。\n如果该年没有举办世界杯，则输出：没有举办世界杯。\n   2.例如，读入“巴西”，应当输出 1958 1962 1970 1994 2002 读入“荷兰”，应当输出 没有获得过世界杯 。\n1930  乌拉圭\n1934意大利\n1938意大利\n1950乌拉圭\n1954西德\n1958巴西\n1962巴西\n1966英格兰\n1970巴西\n1974西德\n1978阿根廷\n1982意大利\n1986阿根廷\n1990西德\n1994巴西\n1998法国\n2002巴西\n2006意大利\n2010西班牙\n2014德国\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class WorldCupServiceTest {\n\n\n    @Test\n    public void testGetChampionByYearWithExistingYear() {\n        assertEquals(\"巴西\", worldCupService.getChampionByYear(\"1958\"));\n    }\n}", "problem": "用java2.利用Map，完成下面的功能：\n   1.从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。\n如果该年没有举办世界杯，则输出：没有举办世界杯。\n   2.例如，读入“巴西”，应当输出 1958 1962 1970 1994 2002 读入“荷兰”，应当输出 没有获得过世界杯 。\n1930  乌拉圭\n1934意大利\n1938意大利\n1950乌拉圭\n1954西德\n1958巴西\n1962巴西\n1966英格兰\n1970巴西\n1974西德\n1978阿根廷\n1982意大利\n1986阿根廷\n1990西德\n1994巴西\n1998法国\n2002巴西\n2006意大利\n2010西班牙\n2014德国", "testcases": "import org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class WorldCupServiceTest {\n    private WorldCupService worldCupService;\n\n    @Before\n    public void setUp() {\n        worldCupService = new WorldCupService();\n    }\n    @Test\n    public void testGetChampionByYearWithNonExistingYear() {\n        assertEquals(\"没有举办世界杯\", worldCupService.getChampionByYear(\"1942\"));\n    }\n\n    @Test\n    public void testGetYearsWonByCountryWithMultipleWins() {\n        assertEquals(\"1958 1962 1970 1994 2002\", worldCupService.getYearsWonByCountry(\"巴西\"));\n    }\n\n    @Test\n    public void testGetYearsWonByCountryWithSingleWin() {\n        assertEquals(\"1966\", worldCupService.getYearsWonByCountry(\"英格兰\"));\n    }\n\n    @Test\n    public void testGetYearsWonByCountryWithNoWins() {\n        assertEquals(\"没有获得过世界杯\", worldCupService.getYearsWonByCountry(\"荷兰\"));\n    }\n\n    @Test\n    public void testGetChampionByYearWithFutureYear() {\n        assertEquals(\"没有举办世界杯\", worldCupService.getChampionByYear(\"2022\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class WorldCupService {\n\n    private final Map<String, String> worldCupChampions = new TreeMap<>();\n\n    public WorldCupService() {\n        initializeChampions();\n    }\n\n    private void initializeChampions() {\n        worldCupChampions.put(\"1930\", \"乌拉圭\");\n        worldCupChampions.put(\"1934\", \"意大利\");\n        worldCupChampions.put(\"1938\", \"意大利\");\n        worldCupChampions.put(\"1950\", \"乌拉圭\");\n        worldCupChampions.put(\"1954\", \"西德\");\n        worldCupChampions.put(\"1958\", \"巴西\");\n        worldCupChampions.put(\"1962\", \"巴西\");\n        worldCupChampions.put(\"1966\", \"英格兰\");\n        worldCupChampions.put(\"1970\", \"巴西\");\n        worldCupChampions.put(\"1974\", \"西德\");\n        worldCupChampions.put(\"1978\", \"阿根廷\");\n        worldCupChampions.put(\"1982\", \"意大利\");\n        worldCupChampions.put(\"1986\", \"阿根廷\");\n        worldCupChampions.put(\"1990\", \"西德\");\n        worldCupChampions.put(\"1994\", \"巴西\");\n        worldCupChampions.put(\"1998\", \"法国\");\n        worldCupChampions.put(\"2002\", \"巴西\");\n        worldCupChampions.put(\"2006\", \"意大利\");\n        worldCupChampions.put(\"2010\", \"西班牙\");\n        worldCupChampions.put(\"2014\", \"德国\");\n    }\n\n    public String getChampionByYear(String year) {\n        return worldCupChampions.getOrDefault(year, \"没有举办世界杯\");\n    }\n\n    public String getYearsWonByCountry(String country) {\n        StringBuilder years = new StringBuilder();\n        for (Map.Entry<String, String> entry : worldCupChampions.entrySet()) {\n            if (entry.getValue().equals(country)) {\n                years.append(entry.getKey()).append(\" \");\n            }\n        }\n        return years.length() > 0 ? years.toString().trim() : \"没有获得过世界杯\";\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 162, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n有一种将字母编码成数字的方式：' a '->1' b ->2',...,' z ->26'。\n现在给一串数字，返回有多少种可能的译码结果。\n例如：\"11\"有2种可能的译码结\n果，\" aa \"或\" k \"。\n要求：字符串长度满足0< n ≤90，空间\n复杂度 O ( n )，时间复杂度 O ( n )。用JAVA实现\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass SolutionTest {\n\n    @Test\n    void testNumDecodings1() {\n        Solution solution = new Solution();\n        assertEquals(2, solution.numDecodings(\"11\"));\n    }\n}", "problem": "有一种将字母编码成数字的方式：' a '->1' b ->2',...,' z ->26'。\n现在给一串数字，返回有多少种可能的译码结果。\n例如：\"11\"有2种可能的译码结\n果，\" aa \"或\" k \"。\n要求：字符串长度满足0< n ≤90，空间\n复杂度 O ( n )，时间复杂度 O ( n )。用JAVA实现", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass SolutionTest {\n    @Test\n    void testNumDecodings2() {\n        Solution solution = new Solution();\n        assertEquals(3, solution.numDecodings(\"111\"));\n    }\n\n    @Test\n    void testNumDecodings3() {\n        Solution solution = new Solution();\n        assertEquals(0, solution.numDecodings(\"0\"));\n    }\n\n    @Test\n    void testNumDecodings4() {\n        Solution solution = new Solution();\n        assertEquals(1, solution.numDecodings(\"10\"));\n    }\n\n    @Test\n    void testNumDecodings5() {\n        Solution solution = new Solution();\n        assertEquals(0, solution.numDecodings(\"100\"));\n    }\n\n    @Test\n    void testNumDecodings6() {\n        Solution solution = new Solution();\n        assertEquals(1, solution.numDecodings(\"27\"));\n    }\n\n    @Test\n    void testNumDecodings7() {\n        Solution solution = new Solution();\n        assertEquals(0, solution.numDecodings(\"\"));\n    }\n\n    @Test\n    void testNumDecodings8() {\n        Solution solution = new Solution();\n        assertEquals(1, solution.numDecodings(\"1\"));\n    }\n\n    @Test\n    void testNumDecodings9() {\n        Solution solution = new Solution();\n        assertEquals(1, solution.numDecodings(\"9\"));\n    }\n\n    @Test\n    void testNumDecodings10() {\n        Solution solution = new Solution();\n        assertEquals(2, solution.numDecodings(\"26\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) != '0' ? 1 : 0;\n        for (int i = 2; i <= n; i++) {\n            int first = Integer.valueOf(s.substring(i - 1, i));\n            int second = Integer.valueOf(s.substring(i - 2, i));\n            if (first >= 1 && first <= 9) {\n                dp[i] += dp[i-1];\n            }\n            if (second >= 10 && second <= 26) {\n                dp[i] += dp[i-2];\n            }\n        }\n        return dp[n];\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 163, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下\n\nn = 3, m = 3\n1   2   3\n2   4   6\n3   6   9\n\n给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。请用java实现这一代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class KthLargestInMatrixTest {\n\n\n    @Test\n    public void testSimpleCase() {\n        assertEquals(9, finder.findKthLargestValue(3, 3, 1));\n    }\n}", "problem": "在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下\n\nn = 3, m = 3\n1   2   3\n2   4   6\n3   6   9\n\n给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。请用java实现这一代码", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class KthLargestInMatrixTest {\n    private final KthLargestInMatrix finder = new KthLargestInMatrix();\n    @Test\n    public void testMiddleValue() {\n        assertEquals(3, finder.findKthLargestValue(3, 3, 5));\n    }\n\n    @Test\n    public void testLastValue() {\n        assertEquals(1, finder.findKthLargestValue(3, 3, 9));\n    }\n\n    // 测试k大于总单元格数\n    @Test\n    public void testKGreaterThanTotalCells() {\n        assertEquals(Integer.MIN_VALUE, finder.findKthLargestValue(2, 2, 5));\n    }\n\n    // 测试零维度\n    @Test\n    public void testZeroDimensions() {\n        assertEquals(Integer.MIN_VALUE, finder.findKthLargestValue(0, 0, 1));\n    }\n\n    // 测试负维度\n    @Test\n    public void testNegativeDimensions() {\n        assertEquals(Integer.MIN_VALUE, finder.findKthLargestValue(-1, -1, 1));\n    }\n\n    // 测试k为零\n    @Test\n    public void testKIsZero() {\n        assertEquals(Integer.MIN_VALUE, finder.findKthLargestValue(3, 3, 0));\n    }\n\n    // 测试较大的矩阵\n    @Test\n    public void testLargeMatrix() {\n        assertEquals(8, finder.findKthLargestValue(4, 4, 5));\n    }\n\n    // 测试非方阵\n    @Test\n    public void testNonSquareMatrix() {\n        assertEquals(6, finder.findKthLargestValue(3, 4, 4));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.PriorityQueue;\n\npublic class KthLargestInMatrix {\n\n    public int findKthLargestValue(int n, int m, int k) {\n        // 验证输入\n        if (n <= 0 || m <= 0 || k <= 0 || k > n * m) {\n            return Integer.MIN_VALUE;\n        }\n\n        // 使用最小堆来存储最大的k个元素\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);\n\n        // 遍历所有单元格\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int value = i * j;\n\n                // 如果堆的大小小于k，直接添加\n                if (minHeap.size() < k) {\n                    minHeap.add(value);\n                } else if (value > minHeap.peek()) {\n                    // 如果当前值大于堆顶元素，则弹出堆顶，将当前值加入堆中\n                    minHeap.poll();\n                    minHeap.add(value);\n                }\n            }\n        }\n\n        // 堆顶元素即为第k大的元素\n        return minHeap.peek();\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 164, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。 java\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TreeNodeTest {\n\n    @Test\n    void testIsValidBST1() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(2);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(3);\n        assertTrue(solution.isValidBST(root));\n    }\n}", "problem": "给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。 java", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass TreeNodeTest {\n    @Test\n    void testIsValidBST2() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(5);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(4);\n        root.right.left = new TreeNode(3);\n        root.right.right = new TreeNode(6);\n        assertFalse(solution.isValidBST(root));\n    }\n\n    @Test\n    void testIsValidBST3() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(10);\n        root.left = new TreeNode(5);\n        root.right = new TreeNode(15);\n        root.right.left = new TreeNode(6);\n        root.right.right = new TreeNode(20);\n        assertFalse(solution.isValidBST(root));\n    }\n\n    @Test\n    void testIsValidBST4() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(1);\n        assertFalse(solution.isValidBST(root));\n    }\n\n    @Test\n    void testIsValidBST5() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(1);\n        root.right = new TreeNode(1);\n        assertFalse(solution.isValidBST(root));\n    }\n\n    @Test\n    void testIsValidBST6() {\n        Solution solution = new Solution();\n        TreeNode root = null;\n        assertTrue(solution.isValidBST(root));\n    }\n\n    @Test\n    void testIsValidBST7() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(Integer.MAX_VALUE);\n        assertTrue(solution.isValidBST(root));\n    }\n\n    @Test\n    void testIsValidBST8() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(Integer.MIN_VALUE);\n        assertTrue(solution.isValidBST(root));\n    }\n\n    @Test\n    void testIsValidBST9() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(0);\n        root.left = new TreeNode(Integer.MIN_VALUE);\n        root.right = new TreeNode(Integer.MAX_VALUE);\n        assertTrue(solution.isValidBST(root));\n    }\n\n    @Test\n    void testIsValidBST10() {\n        Solution solution = new Solution();\n        TreeNode root = new TreeNode(0);\n        root.left = new TreeNode(Integer.MAX_VALUE);\n        root.right = new TreeNode(Integer.MIN_VALUE);\n        assertFalse(solution.isValidBST(root));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n\n    public boolean isValidBST(TreeNode node, long minVal, long maxVal) {\n        if (node == null) return true;\n        if (node.val >= maxVal || node.val <= minVal) return false;\n        return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal);\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 165, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写程序，请用JAVA语言中的switch-case语句来完成：\n从键盘分别输入年、月、日，判断这一天是当年的第几天\n\n提示：判断一年是否是闰年的标准：\n1)可以被4整除，但不可被100整除\n2)可以被400整除\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DayOfYearCalculatorTest {\n\n\n    @Test\n    public void testCommonYearFebruary() {\n        assertEquals(59, DayOfYearCalculator.dayOfYear(2023, 2, 28));\n    }\n}", "problem": "编写程序，请用JAVA语言中的switch-case语句来完成：\n从键盘分别输入年、月、日，判断这一天是当年的第几天\n\n提示：判断一年是否是闰年的标准：\n1)可以被4整除，但不可被100整除\n2)可以被400整除", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DayOfYearCalculatorTest {\n    @Test\n    public void testLeapYearFebruary() {\n        assertEquals(60, DayOfYearCalculator.dayOfYear(2024, 2, 29));\n    }\n\n    @Test\n    public void testStartOfYear() {\n        assertEquals(1, DayOfYearCalculator.dayOfYear(2023, 1, 1));\n    }\n\n    @Test\n    public void testEndOfYear() {\n        assertEquals(365, DayOfYearCalculator.dayOfYear(2023, 12, 31));\n    }\n\n    @Test\n    public void testLeapYearEndOfYear() {\n        assertEquals(366, DayOfYearCalculator.dayOfYear(2024, 12, 31));\n    }\n\n    @Test\n    public void testMidYear() {\n        assertEquals(182, DayOfYearCalculator.dayOfYear(2023, 7, 1));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidDate() {\n        DayOfYearCalculator.dayOfYear(2023, 2, 30);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidMonth() {\n        DayOfYearCalculator.dayOfYear(2023, 13, 1);\n    }\n\n\n    @Test\n    public void testMonthEnd() {\n        assertEquals(31, DayOfYearCalculator.dayOfYear(2023, 1, 31));\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\npublic class DayOfYearCalculator {\n\n    public static int dayOfYear(int year, int month, int day) {\n        int[] daysInMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n        // 检查闰年\n        if (isLeapYear(year)) {\n            daysInMonth[1] = 29; // 2月为29天\n        }\n\n        // 验证输入\n        if (month < 1 || month > 12 || day < 1 || day > daysInMonth[month - 1]) {\n            throw new IllegalArgumentException(\"Invalid date\");\n        }\n\n        int dayOfYear = day;\n        for (int i = 0; i < month - 1; i++) {\n            dayOfYear += daysInMonth[i];\n        }\n\n        return dayOfYear;\n    }\n\n    private static boolean isLeapYear(int year) {\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 166, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n小蓝每天都锻炼身体。\n\n正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2千米。\n\n小蓝跑步已经坚持了很长时间，从 2000 年 11 月 11 日周六（含）到 2020 年 10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？Java写并解释\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\n\nimport java.time.LocalDate;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RunningTrackerTest {\n\n\n    @Test\n    public void testNonLeapYearFebruary() {\n        // 测试非闰年的2月，期望跑步距离考虑了月初和周一\n        assertEquals(\"Expected distance considering Mondays and the beginning of the month\", 32, tracker.calculateTotalDistance(LocalDate.of(2021, 2, 1), LocalDate.of(2021, 2, 28)));\n    }\n}", "problem": "小蓝每天都锻炼身体。\n\n正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑 2 千米。如果同时是周一或月初，小蓝也是跑 2千米。\n\n小蓝跑步已经坚持了很长时间，从 2000 年 11 月 11 日周六（含）到 2020 年 10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？Java写并解释", "testcases": "import org.junit.Test;\n\nimport java.time.LocalDate;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RunningTrackerTest {\n    private RunningTracker tracker = new RunningTracker();\n    @Test\n    public void testLeapYearFebruary() {\n        // 测试闰年的2月\n        assertEquals(\"Expected distance in a leap year February\", 34, tracker.calculateTotalDistance(LocalDate.of(2020, 2, 1), LocalDate.of(2020, 2, 29)));\n    }\n\n    @Test\n    public void testMonthWithMultipleMondays() {\n        // 测试包含多个周一的月份\n        assertEquals(\"Expected distance in a month with multiple Mondays\", 36, tracker.calculateTotalDistance(LocalDate.of(2021, 3, 1), LocalDate.of(2021, 3, 31)));\n    }\n    @Test\n    public void testStartAndEndOnMondays() {\n        // 测试起始和结束日期都是周一的情况\n        assertEquals(\"Expected distance when both start and end dates are Mondays\", 10, tracker.calculateTotalDistance(LocalDate.of(2021, 11, 1), LocalDate.of(2021, 11, 8)));\n    }\n\n    @Test\n    public void testSingleDayMonthStart() {\n        // 测试只有一个天，且这一天是月初的情况\n        assertEquals(\"Expected distance for a single day at the start of the month\", 2, tracker.calculateTotalDistance(LocalDate.of(2021, 4, 1), LocalDate.of(2021, 4, 1)));\n    }\n\n    @Test\n    public void testSingleDayNotMondayOrMonthStart() {\n        // 测试只有一天，且这天既不是周一也不是月初\n        assertEquals(\"Expected distance for a single day that is neither Monday nor the start of the month\", 1, tracker.calculateTotalDistance(LocalDate.of(2021, 4, 2), LocalDate.of(2021, 4, 2)));\n    }\n\n    @Test\n    public void testFullYearNonLeap() {\n        // 测试整个非闰年\n        assertEquals(\"Expected distance for a full non-leap year\", 426, tracker.calculateTotalDistance(LocalDate.of(2021, 1, 1), LocalDate.of(2021, 12, 31)));\n    }\n\n    @Test\n    public void testFullYearLeap() {\n        // 测试整个闰年\n        assertEquals(\"Expected distance for a full leap year\", 429, tracker.calculateTotalDistance(LocalDate.of(2020, 1, 1), LocalDate.of(2020, 12, 31)));\n    }\n\n    @Test\n    public void testEndOnMonday() {\n        // 测试结束日期是周一的情况\n        assertEquals(\"Expected distance when the end date is a Monday\", 3, tracker.calculateTotalDistance(LocalDate.of(2021, 4, 4), LocalDate.of(2021, 4, 5)));\n    }\n\n    @Test\n    public void testRangeWithNoMondaysOrMonthStart() {\n        // 测试日期范围内没有周一也没有月初的情况\n        assertEquals(\"Expected distance for a range with no Mondays or month starts\", 3, tracker.calculateTotalDistance(LocalDate.of(2021, 4, 7), LocalDate.of(2021, 4, 9)));\n    }\n}\n", "setup_code": "", "reference_solution": "```java\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class RunningTracker {\n\n    public long calculateTotalDistance(LocalDate start, LocalDate end) {\n        long totalDistance = 0;\n        LocalDate date = start;\n\n        while (!date.isAfter(end)) {\n            // 如果是月初或周一，则跑2千米\n            if (date.getDayOfMonth() == 1 || date.getDayOfWeek() == java.time.DayOfWeek.MONDAY) {\n                totalDistance += 2;\n            } else {\n                totalDistance += 1;\n            }\n            date = date.plusDays(1);\n        }\n\n        return totalDistance;\n    }\n}\n\n```", "classification": "其他"}
{"_id": 167, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\njava\n\n对一个字符串，按字典序罗列它的全部排列方式。\n\n输入\n一个字符串（其中可能有相同字符，长度不大于12）\n\n输出\n按ASCII码序，每行一个，罗列它的全部排列方式。\n\n最后一行输出全部排列方式的个数。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringPermutationsTest {\n\n\n\n    @Test\n    public void testSingleCharacter() {\n        assertEquals(\"Should return one permutation for a single character\", 1, permutations.permute(\"A\").size());\n    }\n}", "problem": "java\n\n对一个字符串，按字典序罗列它的全部排列方式。\n\n输入\n一个字符串（其中可能有相同字符，长度不大于12）\n\n输出\n按ASCII码序，每行一个，罗列它的全部排列方式。\n\n最后一行输出全部排列方式的个数。", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringPermutationsTest {\n    private StringPermutations permutations = new StringPermutations();\n    @Test\n    public void testTwoDifferentCharacters() {\n        assertEquals(\"Should return two permutations for two different characters\", 2, permutations.permute(\"AB\").size());\n    }\n\n    @Test\n    public void testTwoSameCharacters() {\n        assertEquals(\"Should return one permutation for two identical characters\", 1, permutations.permute(\"AA\").size());\n    }\n\n    @Test\n    public void testThreeDifferentCharacters() {\n        assertEquals(\"Should return six permutations for three different characters\", 6, permutations.permute(\"ABC\").size());\n    }\n\n    @Test\n    public void testStringWithDuplicates() {\n        assertEquals(\"Should handle duplicates correctly\", 3, permutations.permute(\"AAB\").size());\n    }\n\n    @Test\n    public void testAllSameCharacters() {\n        assertEquals(\"Should return one permutation for all same characters\", 1, permutations.permute(\"AAAA\").size());\n    }\n\n    @Test\n    public void testAlphanumericString() {\n        assertEquals(\"Should handle alphanumeric strings\", 24, permutations.permute(\"A1B2\").size()); // 4!\n    }\n\n    @Test\n    public void testStringWithSpecialCharacters() {\n        assertEquals(\"Should handle strings with special characters\", 2, permutations.permute(\"A*\").size());\n    }\n}\n", "setup_code": "", "reference_solution": "```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class StringPermutations {\n\n    public List<String> permute(String s) {\n        Set<String> permutations = new HashSet<>();\n        permute(\"\", s, permutations);\n        List<String> sortedList = new ArrayList<>(permutations);\n        Collections.sort(sortedList);\n        return sortedList;\n    }\n\n    private void permute(String prefix, String s, Set<String> permutations) {\n        int n = s.length();\n        if (n == 0) {\n            permutations.add(prefix);\n        } else {\n            for (int i = 0; i < n; i++) {\n                permute(prefix + s.charAt(i), s.substring(0, i) + s.substring(i + 1, n), permutations);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        StringPermutations sp = new StringPermutations();\n        List<String> result = sp.permute(\"AAB\");\n        result.forEach(System.out::println);\n        System.out.println(\"Total permutations: \" + result.size());\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 168, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请用java解决下面问题：某系统的进程可能占有和等待一些资源，现给出在某一时刻dump的这些进程占有和等待的资源信息，请按照如下简化规则分析哪些进程发生了 死锁，请升序返回所有死锁的进程ID列表，或空列表 []。\n简化规则如下：\n•如果某个进程 p 的任一等待资源设占有，则该进程必须等待，直到这些资源被释放：等待期间，该进程不会释放所占有的资源。\n如果进程 P 所等传的资源全部部末被其他进程占有，则该进程必将释放所古有的资源。\n基于上，如果某个进程因为所等待的资源一直被古有而无限等待下去，则认为该进程发生了死锁。\n输入\n第一行为一个整数num，表示进程个数;\n第二行开始的num行，依次表示每个进程占有和等待资源的情况，格式为：\n进程ID（占有资源列表）（等待资源列表）。\n0<=进程D<=100,0<=资源编号 <= 300\n每一行的箱入中不会包含重复的资源编号\n输入保证：每个资源最多只会被一个进程占有。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testFindDeadlocks1() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(2, 3)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1, 2), result);\n    }\n}", "problem": "请用java解决下面问题：某系统的进程可能占有和等待一些资源，现给出在某一时刻dump的这些进程占有和等待的资源信息，请按照如下简化规则分析哪些进程发生了 死锁，请升序返回所有死锁的进程ID列表，或空列表 []。\n简化规则如下：\n•如果某个进程 p 的任一等待资源设占有，则该进程必须等待，直到这些资源被释放：等待期间，该进程不会释放所占有的资源。\n如果进程 P 所等传的资源全部部末被其他进程占有，则该进程必将释放所古有的资源。\n基于上，如果某个进程因为所等待的资源一直被古有而无限等待下去，则认为该进程发生了死锁。\n输入\n第一行为一个整数num，表示进程个数;\n第二行开始的num行，依次表示每个进程占有和等待资源的情况，格式为：\n进程ID（占有资源列表）（等待资源列表）。\n0<=进程D<=100,0<=资源编号 <= 300\n每一行的箱入中不会包含重复的资源编号\n输入保证：每个资源最多只会被一个进程占有。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\n\nclass MainTest {\n    @Test\n    void testFindDeadlocks2() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(6, 7)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(8, 9)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(new ArrayList<>(), result);\n    }\n\n    @Test\n    void testFindDeadlocks3() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(6, 7)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1), result);\n    }\n\n    @Test\n    void testFindDeadlocks4() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(2)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1, 2), result);\n    }\n\n    @Test\n    void testFindDeadlocks5() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(2, 3)));\n        holdMap.put(3, new HashSet<>(Arrays.asList(6, 7)));\n        waitMap.put(3, new HashSet<>(Arrays.asList(8, 9)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1, 2), result);\n    }\n\n    @Test\n    void testFindDeadlocks6() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        holdMap.put(1, new HashSet<>(Arrays.asList(2, 3)));\n        waitMap.put(1, new HashSet<>(Arrays.asList(4, 5)));\n        holdMap.put(2, new HashSet<>(Arrays.asList(4, 5)));\n        waitMap.put(2, new HashSet<>(Arrays.asList(6, 7)));\n        holdMap.put(3, new HashSet<>(Arrays.asList(6, 7)));\n        waitMap.put(3, new HashSet<>(Arrays.asList(2, 3)));\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(Arrays.asList(1, 2, 3), result);\n    }\n\n    @Test\n    void testFindDeadlocks7() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        for (int i = 1; i <= 100; i++) {\n            holdMap.put(i, new HashSet<>(Arrays.asList(i)));\n            waitMap.put(i, new HashSet<>(Arrays.asList(i == 100 ? 1 : i + 1)));\n        }\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        List<Integer> expected = new ArrayList<>();\n        for (int i = 1; i <= 100; i++) {\n            expected.add(i);\n        }\n        assertEquals(expected, result);\n    }\n\n    @Test\n    void testFindDeadlocks8() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        for (int i = 1; i <= 100; i++) {\n            holdMap.put(i, new HashSet<>(Arrays.asList(i)));\n            waitMap.put(i, new HashSet<>(Arrays.asList(i == 1 ? 100 : i - 1)));\n        }\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        List<Integer> expected = new ArrayList<>();\n        for (int i = 1; i <= 100; i++) {\n            expected.add(i);\n        }\n        assertEquals(expected, result);\n    }\n\n    @Test\n    void testFindDeadlocks9() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        for (int i = 1; i <= 100; i++) {\n            holdMap.put(i, new HashSet<>(Arrays.asList(i)));\n            waitMap.put(i, new HashSet<>());\n        }\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(new ArrayList<>(), result);\n    }\n\n    @Test\n    void testFindDeadlocks10() {\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        for (int i = 1; i <= 100; i++) {\n            holdMap.put(i, new HashSet<>(Arrays.asList(i)));\n            waitMap.put(i, new HashSet<>(Arrays.asList(101)));\n        }\n        List<Integer> result = Main.findDeadlocks(holdMap, waitMap);\n        Collections.sort(result);\n        assertEquals(new ArrayList<>(), result);\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int num = scanner.nextInt();\n        scanner.nextLine();\n        Map<Integer, Set<Integer>> holdMap = new HashMap<>();\n        Map<Integer, Set<Integer>> waitMap = new HashMap<>();\n        for (int i = 0; i < num; i++) {\n            String line = scanner.nextLine();\n            String[] parts = line.split(\"\\\\s+\");\n            int pid = Integer.parseInt(parts[0]);\n            Set<Integer> holdSet = new HashSet<>();\n            Set<Integer> waitSet = new HashSet<>();\n            for (String s : parts[1].substring(1, parts[1].length() - 1).split(\",\")) {\n                if (!s.isEmpty()) {\n                    holdSet.add(Integer.parseInt(s));\n                }\n            }\n            for (String s : parts[2].substring(1, parts[2].length() - 1).split(\",\")) {\n                if (!s.isEmpty()) {\n                    waitSet.add(Integer.parseInt(s));\n                }\n            }\n            holdMap.put(pid, holdSet);\n            waitMap.put(pid, waitSet);\n        }\n        List<Integer> deadlocks = findDeadlocks(holdMap, waitMap);\n        Collections.sort(deadlocks);\n        System.out.println(deadlocks);\n    }\n\n    static List<Integer> findDeadlocks(Map<Integer, Set<Integer>> holdMap, Map<Integer, Set<Integer>> waitMap) {\n        List<Integer> deadlocks = new ArrayList<>();\n        for (int pid : waitMap.keySet()) {\n            Set<Integer> waitSet = waitMap.get(pid);\n            for (int resource : waitSet) {\n                if (isResourceHeldByOthers(resource, pid, holdMap)) {\n                    deadlocks.add(pid);\n                    break;\n                }\n            }\n        }\n        return deadlocks;\n    }\n\n    private static boolean isResourceHeldByOthers(int resource, int pid, Map<Integer, Set<Integer>> holdMap) {\n        for (int otherPid : holdMap.keySet()) {\n            if (otherPid != pid && holdMap.get(otherPid).contains(resource)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 169, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n计算正方形的面积和周长\n编程题\n题目描述\n编写程序，输入正方形的边长，计算这个正方形的周长和面积，并将计算结果打印输出。\n输入示例\n10\n输出示例\n边长: 10\n周长: 40\n面积: 100    用Java写出来\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class SquareTest {\n\n\n    @Test\n    public void testPerimeterWithPositiveSide() {\n        Square square = new Square(10);\n        assertEquals(40, square.getPerimeter(), 0.01);\n    }\n}", "problem": "计算正方形的面积和周长\n编程题\n题目描述\n编写程序，输入正方形的边长，计算这个正方形的周长和面积，并将计算结果打印输出。\n输入示例\n10\n输出示例\n边长: 10\n周长: 40\n面积: 100    用Java写出来", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class SquareTest {\n    @Test\n    public void testAreaWithPositiveSide() {\n        Square square = new Square(10);\n        assertEquals(100, square.getArea(), 0.01);\n    }\n\n    @Test\n    public void testPerimeterWithZeroSide() {\n        Square square = new Square(0);\n        assertEquals(0, square.getPerimeter(), 0.01);\n    }\n\n    @Test\n    public void testAreaWithZeroSide() {\n        Square square = new Square(0);\n        assertEquals(0, square.getArea(), 0.01);\n    }\n\n    @Test\n    public void testPerimeterWithSmallSide() {\n        Square square = new Square(0.1);\n        assertEquals(0.4, square.getPerimeter(), 0.01);\n    }\n\n    @Test\n    public void testAreaWithSmallSide() {\n        Square square = new Square(0.1);\n        assertEquals(0.01, square.getArea(), 0.0001);\n    }\n\n    @Test\n    public void testPerimeterWithLargeSide() {\n        Square square = new Square(1000);\n        assertEquals(4000, square.getPerimeter(), 0.01);\n    }\n\n    @Test\n    public void testAreaWithLargeSide() {\n        Square square = new Square(1000);\n        assertEquals(1000000, square.getArea(), 0.01);\n    }\n\n    @Test\n    public void testPerimeterWithFractionalSide() {\n        Square square = new Square(5.5);\n        assertEquals(22, square.getPerimeter(), 0.01);\n    }\n\n    @Test\n    public void testAreaWithFractionalSide() {\n        Square square = new Square(5.5);\n        assertEquals(30.25, square.getArea(), 0.01);\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\npublic class Square {\n    private double sideLength;\n\n    public Square(double sideLength) {\n        this.sideLength = sideLength;\n    }\n\n    public double getPerimeter() {\n        return 4 * sideLength;\n    }\n\n    public double getArea() {\n        return sideLength * sideLength;\n    }\n}\n\n```", "classification": "其他"}
{"_id": 170, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n小美最近发现了一种有趣的游戏，给定一个队列q，小美会按照以下规则进行游戏：\n\n每次从队列中取出一个数，如果这个数是当前队列中最小的值，那么小美就会丢掉这个数。否则小美就会把这个数重新加入队列。\n\n小美会一直进行游戏直到队列变空为止，但是小美并没有多少耐心，因此她想知道她最多需要进行多少次操作才能结束游戏。 请用java编程解决\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testMaxOperations1() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(3, 2, 1, 4, 5));\n        assertEquals(12, Main.maxOperations(queue));\n    }\n}", "problem": "小美最近发现了一种有趣的游戏，给定一个队列q，小美会按照以下规则进行游戏：\n\n每次从队列中取出一个数，如果这个数是当前队列中最小的值，那么小美就会丢掉这个数。否则小美就会把这个数重新加入队列。\n\n小美会一直进行游戏直到队列变空为止，但是小美并没有多少耐心，因此她想知道她最多需要进行多少次操作才能结束游戏。 请用java编程解决", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\n\nclass MainTest {\n    @Test\n    void testMaxOperations2() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5));\n        assertEquals(5, Main.maxOperations(queue));\n    }\n\n    @Test\n    void testMaxOperations3() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(5, 4, 3, 2, 1));\n        assertEquals(15, Main.maxOperations(queue));\n    }\n\n    @Test\n    void testMaxOperations4() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(1, 1, 1, 1, 1));\n        assertEquals(5, Main.maxOperations(queue));\n    }\n\n    @Test\n    void testMaxOperations5() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(5, 5, 5, 5, 5));\n        assertEquals(5, Main.maxOperations(queue));\n    }\n\n    @Test\n    void testMaxOperations6() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n        assertEquals(10, Main.maxOperations(queue));\n    }\n\n    @Test\n    void testMaxOperations7() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(10, 9, 8, 7, 6, 5, 4, 3, 2, 1));\n        assertEquals(55, Main.maxOperations(queue));\n    }\n\n    @Test\n    void testMaxOperations8() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(1));\n        assertEquals(1, Main.maxOperations(queue));\n    }\n\n    @Test\n    void testMaxOperations9() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(100, 200, 300, 400, 500));\n        assertEquals(5, Main.maxOperations(queue));\n    }\n\n    @Test\n    void testMaxOperations10() {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(500, 400, 300, 200, 100));\n        assertEquals(15, Main.maxOperations(queue));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Queue<Integer> queue = new LinkedList<>(Arrays.asList(3, 2, 1, 4, 5));\n        System.out.println(maxOperations(queue));\n    }\n\n    public static int maxOperations(Queue<Integer> queue) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>(queue);\n        int operations = 0;\n        while (!queue.isEmpty()) {\n            int num = queue.poll();\n            if (num == pq.peek()) {\n                pq.poll();\n            } else {\n                queue.offer(num);\n            }\n            operations++;\n        }\n        return operations;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 171, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nlong 数据类型最多能表示19位⼗进制整数，那么对于更⼤的整数应该如何描述呢？在包 hugeinteger 中创建功\n能类 HugeInteger ，该类⽤来存放和操作⼀个不超过100位的⼗进制⼤整数。\n1. 2个重载的构造函数，⽀持通过 long 和 String 类型初始化⼀个 HugeInteger 对象。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass HugeIntegerTest {\n\n    @Test\n    void testConstructorWithLong() {\n        HugeInteger hi = new HugeInteger(1234567890123456789L);\n        assertEquals(\"1234567890123456789\", hi.getValue());\n    }\n}", "problem": "long 数据类型最多能表示19位⼗进制整数，那么对于更⼤的整数应该如何描述呢？在包 hugeinteger 中创建功\n能类 HugeInteger ，该类⽤来存放和操作⼀个不超过100位的⼗进制⼤整数。\n1. 2个重载的构造函数，⽀持通过 long 和 String 类型初始化⼀个 HugeInteger 对象。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass HugeIntegerTest {\n    @Test\n    void testConstructorWithString() {\n        HugeInteger hi = new HugeInteger(\"12345678901234567891234567890123456789\");\n        assertEquals(\"12345678901234567891234567890123456789\", hi.getValue());\n    }\n\n    @Test\n    void testConstructorWithZeroLong() {\n        HugeInteger hi = new HugeInteger(0L);\n        assertEquals(\"0\", hi.getValue());\n    }\n\n    @Test\n    void testConstructorWithZeroString() {\n        HugeInteger hi = new HugeInteger(\"0\");\n        assertEquals(\"0\", hi.getValue());\n    }\n\n    @Test\n    void testConstructorWithNegativeLong() {\n        HugeInteger hi = new HugeInteger(-1234567890123456789L);\n        assertEquals(\"-1234567890123456789\", hi.getValue());\n    }\n\n    @Test\n    void testConstructorWithNegativeString() {\n        HugeInteger hi = new HugeInteger(\"-12345678901234567891234567890123456789\");\n        assertEquals(\"-12345678901234567891234567890123456789\", hi.getValue());\n    }\n\n    @Test\n    void testConstructorWithMaxLong() {\n        HugeInteger hi = new HugeInteger(Long.MAX_VALUE);\n        assertEquals(Long.toString(Long.MAX_VALUE), hi.getValue());\n    }\n\n    @Test\n    void testConstructorWithMinLong() {\n        HugeInteger hi = new HugeInteger(Long.MIN_VALUE);\n        assertEquals(Long.toString(Long.MIN_VALUE), hi.getValue());\n    }\n\n    @Test\n    void testConstructorWithMaxDigitsString() {\n        HugeInteger hi = new HugeInteger(\"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\");\n        assertEquals(\"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\", hi.getValue());\n    }\n\n    @Test\n    void testConstructorWithExceedMaxDigitsString() {\n        assertThrows(IllegalArgumentException.class, () -> new HugeInteger(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\n\npublic class HugeInteger {\n\n    private String value;\n\n    // Constructor that accepts long\n    public HugeInteger(long value) {\n        this.value = Long.toString(value);\n    }\n\n    // Constructor that accepts String\n    public HugeInteger(String value) {\n        if (value.length() > 100) {\n            throw new IllegalArgumentException(\"The length of the string should not exceed 100 digits.\");\n        }\n        this.value = value;\n    }\n\n    // Getter method\n    public String getValue() {\n        return this.value;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 172, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n有一个List<Integer>，其内容为 [1,2,3,4,10,12]，如何将其处理为统一用两位数表示的字符串列表，如 1 要变成 01，用java语言操作\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class NumberFormatterTest {\n\n\n    @Test\n    public void testFormatNumbers() {\n        List<Integer> input = Arrays.asList(1, 2, 3, 4, 10, 12);\n        List<String> expected = Arrays.asList(\"01\", \"02\", \"03\", \"04\", \"10\", \"12\");\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n}", "problem": "有一个List<Integer>，其内容为 [1,2,3,4,10,12]，如何将其处理为统一用两位数表示的字符串列表，如 1 要变成 01，用java语言操作", "testcases": "import org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class NumberFormatterTest {\n    @Test\n    public void testEmptyList() {\n        List<Integer> input = Arrays.asList();\n        List<String> expected = Arrays.asList();\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n\n    @Test\n    public void testSingleDigitNumbers() {\n        List<Integer> input = Arrays.asList(0, 5, 9);\n        List<String> expected = Arrays.asList(\"00\", \"05\", \"09\");\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n\n    @Test\n    public void testDoubleDigitNumbers() {\n        List<Integer> input = Arrays.asList(10, 20, 99);\n        List<String> expected = Arrays.asList(\"10\", \"20\", \"99\");\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n\n    @Test\n    public void testMixedSingleAndDoubleDigitNumbers() {\n        List<Integer> input = Arrays.asList(0, 1, 10, 99);\n        List<String> expected = Arrays.asList(\"00\", \"01\", \"10\", \"99\");\n        assertEquals(expected, NumberFormatter.formatNumbers(input));\n    }\n}\n", "setup_code": "", "reference_solution": "```java\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class NumberFormatter {\n\n    public static List<String> formatNumbers(List<Integer> numbers) {\n        return numbers.stream()\n                .map(number -> String.format(\"%02d\", number))\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 10, 12);\n        List<String> formattedNumbers = formatNumbers(numbers);\n        System.out.println(formattedNumbers);\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 173, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n设计一个表示分数的类Fraction。这个类用两个int类型的变量分别表示分子和分母。注意，在创建和做完运算后应该化简分数为最简形式。如2/4应该被化简为1/2。Java代码\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class FractionTest {\n\n\n    @Test\n    public void testConstruct() {\n        Fraction fraction = new Fraction(2, 4);\n        assertEquals(\"1/2\", fraction.toString());\n    }\n}", "problem": "设计一个表示分数的类Fraction。这个类用两个int类型的变量分别表示分子和分母。注意，在创建和做完运算后应该化简分数为最简形式。如2/4应该被化简为1/2。Java代码", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class FractionTest {\n    @Test\n    public void testAddition() {\n        Fraction f1 = new Fraction(1, 2);\n        Fraction f2 = new Fraction(1, 3);\n        Fraction result = f1.add(f2);\n        assertEquals(\"5/6\", result.toString());\n    }\n\n    @Test\n    public void testSubtraction() {\n        Fraction f1 = new Fraction(3, 4);\n        Fraction f2 = new Fraction(1, 4);\n        Fraction result = f1.subtract(f2);\n        assertEquals(\"1/2\", result.toString());\n    }\n\n    @Test\n    public void testMultiplication() {\n        Fraction f1 = new Fraction(1, 2);\n        Fraction f2 = new Fraction(2, 3);\n        Fraction result = f1.multiply(f2);\n        assertEquals(\"1/3\", result.toString());\n    }\n\n    @Test\n    public void testDivision() {\n        Fraction f1 = new Fraction(1, 2);\n        Fraction f2 = new Fraction(1, 3);\n        Fraction result = f1.divide(f2);\n        assertEquals(\"3/2\", result.toString());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testDivisionByZero() {\n        Fraction f1 = new Fraction(1, 2);\n        Fraction f2 = new Fraction(0, 1);\n        f1.divide(f2);\n    }\n\n    @Test\n    public void testSimplification() {\n        Fraction fraction = new Fraction(100, 200);\n        assertEquals(\"1/2\", fraction.toString());\n    }\n\n    @Test\n    public void testNegativeFraction() {\n        Fraction fraction = new Fraction(-1, 2);\n        assertEquals(\"-1/2\", fraction.toString());\n    }\n\n    @Test\n    public void testToString() {\n        Fraction fraction = new Fraction(3, 4);\n        assertEquals(\"3/4\", fraction.toString());\n    }\n\n    @Test\n    public void testIntegerFraction() {\n        Fraction fraction = new Fraction(4, 2);\n        assertEquals(\"2/1\", fraction.toString());\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\n\npublic class Fraction {\n    private int numerator;   // 分子\n    private int denominator; // 分母\n\n    // 构造器\n    public Fraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be zero.\");\n        }\n        this.numerator = numerator;\n        this.denominator = denominator;\n        simplify();\n    }\n\n    // 化简分数\n    private void simplify() {\n        int gcd = gcd(Math.abs(numerator), Math.abs(denominator));\n        numerator /= gcd;\n        denominator /= gcd;\n    }\n\n    // 计算最大公约数\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    // 加法\n    public Fraction add(Fraction other) {\n        int newNumerator = this.numerator * other.denominator + other.numerator * this.denominator;\n        int newDenominator = this.denominator * other.denominator;\n        return new Fraction(newNumerator, newDenominator);\n    }\n\n    // 减法\n    public Fraction subtract(Fraction other) {\n        int newNumerator = this.numerator * other.denominator - other.numerator * this.denominator;\n        int newDenominator = this.denominator * other.denominator;\n        return new Fraction(newNumerator, newDenominator);\n    }\n\n    // 乘法\n    public Fraction multiply(Fraction other) {\n        return new Fraction(this.numerator * other.numerator, this.denominator * other.denominator);\n    }\n\n    // 除法\n    public Fraction divide(Fraction other) {\n        return new Fraction(this.numerator * other.denominator, this.denominator * other.numerator);\n    }\n\n    // 转换为字符串\n    @Override\n    public String toString() {\n        return numerator + \"/\" + denominator;\n    }\n\n    // Getter方法\n    public int getNumerator() {\n        return numerator;\n    }\n\n    public int getDenominator() {\n        return denominator;\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 174, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java编写代码，实现 给定一个非空字符串 word 和缩写 abbr，返回字符串是否可以和给定的缩写匹配。\n比如一个 “word” 的字符串仅包含以下有效缩写：[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MainTest {\n\n\n    @Test\n    public void testValidSingleDigitAbbreviation() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"1ord\"));\n    }\n}", "problem": "用java编写代码，实现 给定一个非空字符串 word 和缩写 abbr，返回字符串是否可以和给定的缩写匹配。\n比如一个 “word” 的字符串仅包含以下有效缩写：[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MainTest {\n    @Test\n    public void testValidFullLengthAbbreviation() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"4\"));\n    }\n\n    @Test\n    public void testValidMultipleAbbreviations() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"2r1\"));\n    }\n\n    @Test\n    public void testValidMixedAbbreviation() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"w1r1\"));\n    }\n\n    @Test\n    public void testInvalidAbbreviationWithWrongPosition() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"1o2\"));\n    }\n\n    @Test\n    public void testInvalidAbbreviationWithExceedingLength() {\n        assertFalse(Main.validWordAbbreviation(\"word\", \"wo3\"));\n    }\n\n    @Test\n    public void testInvalidAbbreviationWithLeadingZero() {\n        assertFalse(Main.validWordAbbreviation(\"word\", \"02rd\"));\n    }\n\n    @Test\n    public void testValidExactMatch() {\n        assertTrue(Main.validWordAbbreviation(\"word\", \"word\"));\n    }\n\n    @Test\n    public void testInvalidEmptyAbbreviation() {\n        assertFalse(Main.validWordAbbreviation(\"word\", \"\"));\n    }\n\n    @Test\n    public void testInvalidNonNumericAbbreviation() {\n        assertFalse(Main.validWordAbbreviation(\"word\", \"wrd\"));\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\npublic class Main {\n    public static boolean validWordAbbreviation(String word, String abbr) {\n        int i = 0, j = 0;\n        while (i < word.length() && j < abbr.length()) {\n            if (word.charAt(i) == abbr.charAt(j)) {\n                ++i;\n                ++j;\n                continue;\n            }\n            if (abbr.charAt(j) <= '0' || abbr.charAt(j) > '9') {\n                return false;\n            }\n            int start = j;\n            while (j < abbr.length() && abbr.charAt(j) >= '0' && abbr.charAt(j) <= '9') {\n                ++j;\n            }\n            int num = Integer.valueOf(abbr.substring(start, j));\n            i += num;\n        }\n        return i == word.length() && j == abbr.length();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(validWordAbbreviation(\"word\", \"1ord\")); // true\n        System.out.println(validWordAbbreviation(\"word\", \"4\")); // true\n        System.out.println(validWordAbbreviation(\"word\", \"2r1\")); // true\n        System.out.println(validWordAbbreviation(\"word\", \"w1r1\")); // true\n        System.out.println(validWordAbbreviation(\"word\", \"word\")); // true\n        System.out.println(validWordAbbreviation(\"word\", \"1o2\")); // false\n        System.out.println(validWordAbbreviation(\"word\", \"wo3\")); // false\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 175, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请设计一个递归分段求和函数sum（int start,int End）用于计算机Start至End间的整数和，当Start<End时计算Sum＝Start+（Start+1）+……+End;当Start=End时则返回Start;当Start>End时则返回0输入包含多组测试数据，每组数据包含两个整数Start与End,输出每组数据的计算结果，每组测试数据的计算结果占一行\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSum1() {\n        assertEquals(0, Main.sum(5, 3));\n    }\n}", "problem": "请设计一个递归分段求和函数sum（int start,int End）用于计算机Start至End间的整数和，当Start<End时计算Sum＝Start+（Start+1）+……+End;当Start=End时则返回Start;当Start>End时则返回0输入包含多组测试数据，每组数据包含两个整数Start与End,输出每组数据的计算结果，每组测试数据的计算结果占一行", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Scanner;\n\nclass MainTest {\n    @Test\n    void testSum2() {\n        assertEquals(5, Main.sum(5, 5));\n    }\n\n    @Test\n    void testSum3() {\n        assertEquals(15, Main.sum(1, 5));\n    }\n\n    @Test\n    void testSum4() {\n        assertEquals(5050, Main.sum(1, 100));\n    }\n\n    @Test\n    void testSum5() {\n        assertEquals(0, Main.sum(0, 0));\n    }\n\n    @Test\n    void testSum6() {\n        assertEquals(0, Main.sum(100, 1));\n    }\n\n    @Test\n    void testSum7() {\n        assertEquals(Integer.MAX_VALUE, Main.sum(Integer.MAX_VALUE, Integer.MAX_VALUE));\n    }\n\n    @Test\n    void testSum8() {\n        assertEquals(0, Main.sum(Integer.MAX_VALUE, Integer.MIN_VALUE));\n    }\n\n    @Test\n    void testSum9() {\n        assertEquals(Integer.MIN_VALUE, Main.sum(Integer.MIN_VALUE, Integer.MIN_VALUE));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextInt()) {\n            int start = scanner.nextInt();\n            int end = scanner.nextInt();\n            System.out.println(sum(start, end));\n        }\n        scanner.close();\n    }\n\n    public static int sum(int start, int end) {\n        if (start > end) {\n            return 0;\n        } else if (start == end) {\n            return start;\n        } else {\n            return start + sum(start + 1, end);\n        }\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 176, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写3个基本类： Triangle, Ladder和Circle，分别用来刻画“三角形”、“梯形”和“圆形”类； 1个主类： Compute，负责计算每个形状的面积或周长。\n具体要求：\nTriangle 定义3个变量：边长；和1个求周长的方法。\nLadder  定义3个变量：上底，下底和高；定义1个求面积的方法\nCircle  定义1个变量：半径；定义2个方法：求面积、求周长。\n3个基本类都要定义相应的构造方法，对变量进行初始化。用Java编写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TriangleTest {\n\n    @Test\n    void calculatePerimeter() {\n        Triangle triangle = new Triangle(5);\n        assertEquals(15, triangle.calculatePerimeter());\n    }\n}", "problem": "编写3个基本类： Triangle, Ladder和Circle，分别用来刻画“三角形”、“梯形”和“圆形”类； 1个主类： Compute，负责计算每个形状的面积或周长。\n具体要求：\nTriangle 定义3个变量：边长；和1个求周长的方法。\nLadder  定义3个变量：上底，下底和高；定义1个求面积的方法\nCircle  定义1个变量：半径；定义2个方法：求面积、求周长。\n3个基本类都要定义相应的构造方法，对变量进行初始化。用Java编写", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass TriangleTest {\n    @Test\n    void calculateArea() {\n        Circle circle = new Circle(5);\n        assertEquals(78.53981633974483, circle.calculateArea());\n    }\n\n    @Test\n    void calculateCircumference() {\n        Circle circle = new Circle(5);\n        assertEquals(31.41592653589793, circle.calculateCircumference());\n    }\n\n    @Test\n    void calculateAreaZero() {\n        Circle circle = new Circle(0);\n        assertEquals(0, circle.calculateArea());\n    }\n\n    @Test\n    void calculateCircumferenceZero() {\n        Circle circle = new Circle(0);\n        assertEquals(0, circle.calculateCircumference());\n    }\n}", "setup_code": "", "reference_solution": "```java\n\nclass Triangle {\n    private double side;\n\n    public Triangle(double side) {\n        this.side = side;\n    }\n\n    public double calculatePerimeter() {\n        return 3 * side;\n    }\n}\n\nclass Ladder {\n    private double top;\n    private double bottom;\n    private double height;\n\n    public Ladder(double top, double bottom, double height) {\n        this.top = top;\n        this.bottom = bottom;\n        this.height = height;\n    }\n\n    public double calculateArea() {\n        return (top + bottom) * height / 2;\n    }\n}\n\nclass Circle {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    public double calculateArea() {\n        return Math.PI * Math.pow(radius, 2);\n    }\n\n    public double calculateCircumference() {\n        return 2 * Math.PI * radius;\n    }\n}\n\npublic class Compute {\n    public static void main(String[] args) {\n        Triangle triangle = new Triangle(5);\n        System.out.println(\"Triangle Perimeter: \" + triangle.calculatePerimeter());\n\n        Ladder ladder = new Ladder(5, 10, 7);\n        System.out.println(\"Ladder Area: \" + ladder.calculateArea());\n\n        Circle circle = new Circle(5);\n        System.out.println(\"Circle Area: \" + circle.calculateArea());\n        System.out.println(\"Circle Circumference: \" + circle.calculateCircumference());\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 177, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个Java程序，声明两个整数变量x，y，分别初始化为5和7。然后执行以下操作：\n1、使用前缀递增运算符将第一个整数增加1，并将结果赋值给变量a。\n2、使用后缀递减运算符将第二个整数减少1，并将结果赋值给变量b。\n3、输出a和b的最终值。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class IncrementDecrementTest {\n\n\n    @Test\n    public void testIncrement() {\n        assertEquals(\"Increment 5 should be 6\", 6, incDec.increment(5));\n    }\n}", "problem": "编写一个Java程序，声明两个整数变量x，y，分别初始化为5和7。然后执行以下操作：\n1、使用前缀递增运算符将第一个整数增加1，并将结果赋值给变量a。\n2、使用后缀递减运算符将第二个整数减少1，并将结果赋值给变量b。\n3、输出a和b的最终值。\n", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class IncrementDecrementTest {\n    private IncrementDecrement incDec = new IncrementDecrement();\n    @Test\n    public void testDecrement() {\n        assertEquals(\"Decrement 7 should return 7 due to postfix operation\", 7, incDec.decrement(7));\n    }\n\n    @Test\n    public void testIncrementZero() {\n        assertEquals(\"Increment 0 should be 1\", 1, incDec.increment(0));\n    }\n\n    @Test\n    public void testDecrementToNegative() {\n        assertEquals(\"Decrement 0 should return 0 due to postfix operation\", 0, incDec.decrement(0));\n    }\n\n    @Test\n    public void testIncrementNegative() {\n        assertEquals(\"Increment -1 should be 0\", 0, incDec.increment(-1));\n    }\n\n    @Test\n    public void testDecrementNegative() {\n        assertEquals(\"Decrement -1 should return -1 due to postfix operation\", -1, incDec.decrement(-1));\n    }\n\n    @Test\n    public void testIncrementMaxValue() {\n        assertEquals(\"Increment Integer.MAX_VALUE should overflow to Integer.MIN_VALUE\", Integer.MIN_VALUE, incDec.increment(Integer.MAX_VALUE));\n    }\n\n    @Test\n    public void testDecrementMinValue() {\n        assertEquals(\"Decrement Integer.MIN_VALUE should return Integer.MIN_VALUE due to postfix operation\", Integer.MIN_VALUE, incDec.decrement(Integer.MIN_VALUE));\n    }\n\n    @Test\n    public void testMultipleIncrements() {\n        int result = incDec.increment(5);\n        result = incDec.increment(result);\n        assertEquals(\"Multiple increments should result in 7\", 7, result);\n    }\n\n    @Test\n    public void testMultipleDecrements() {\n        int result = incDec.decrement(7);\n        result = incDec.decrement(result);\n        assertEquals(\"Multiple decrements should return 6 due to postfix operation\", 7, result);\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\npublic class IncrementDecrement {\n    public int increment(int x) {\n        return ++x; // 前缀递增\n    }\n\n    public int decrement(int y) {\n        return y--; // 后缀递减，返回的是递减前的值\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 178, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个方法，计算给定的两个数组之和，格式如下：\r\n6.1.1\r\npublic static int[] sumArray(int[] a, int[] b)\r\n要求返回的数组元素是两个参数数组对应元素之和，不对\r\n应的元素直接赋给相应的位置，例如，{1,2,4} + \r\n{2,4,6,8}={3,6,10,8}。\r\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testSumArray1() {\n        assertArrayEquals(new int[]{3,6,10,8}, Main.sumArray(new int[]{1,2,4}, new int[]{2,4,6,8}));\n    }\n}", "problem": "编写一个方法，计算给定的两个数组之和，格式如下：\r\n6.1.1\r\npublic static int[] sumArray(int[] a, int[] b)\r\n要求返回的数组元素是两个参数数组对应元素之和，不对\r\n应的元素直接赋给相应的位置，例如，{1,2,4} + \r\n{2,4,6,8}={3,6,10,8}。\r\n", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass MainTest {\n    @Test\n    void testSumArray2() {\n        assertArrayEquals(new int[]{5,7,9}, Main.sumArray(new int[]{1,2,3}, new int[]{4,5,6}));\n    }\n\n    @Test\n    void testSumArray3() {\n        assertArrayEquals(new int[]{5,7,9,7,8,9}, Main.sumArray(new int[]{1,2,3}, new int[]{4,5,6,7,8,9}));\n    }\n\n    @Test\n    void testSumArray4() {\n        assertArrayEquals(new int[]{1,2,3,7,8,9}, Main.sumArray(new int[]{1,2,3,0,0,0}, new int[]{0,0,0,7,8,9}));\n    }\n\n    @Test\n    void testSumArray5() {\n        assertArrayEquals(new int[]{0,0,0,0,0,0}, Main.sumArray(new int[]{0,0,0,0,0,0}, new int[]{0,0,0,0,0,0}));\n    }\n\n    @Test\n    void testSumArray6() {\n        assertArrayEquals(new int[]{1,2,3,4,5,6,7,8,9}, Main.sumArray(new int[]{1,2,3,4,5,6,7,8,9}, new int[]{}));\n    }\n\n    @Test\n    void testSumArray7() {\n        assertArrayEquals(new int[]{1}, Main.sumArray(new int[]{1}, new int[]{}));\n    }\n\n    @Test\n    void testSumArray8() {\n        assertArrayEquals(new int[]{1}, Main.sumArray(new int[]{}, new int[]{1}));\n    }\n\n    @Test\n    void testSumArray9() {\n        assertArrayEquals(new int[]{}, Main.sumArray(new int[]{}, new int[]{}));\n    }\n\n    @Test\n    void testSumArray10() {\n        assertArrayEquals(new int[]{Integer.MAX_VALUE, 2}, Main.sumArray(new int[]{Integer.MAX_VALUE, 1}, new int[]{0, 1}));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] a = {1, 2, 4};\n        int[] b = {2, 4, 6, 8};\n        int[] sum = sumArray(a, b);\n        for (int i : sum) {\n            System.out.print(i + \" \");\n        }\n    }\n\n    public static int[] sumArray(int[] a, int[] b) {\n        int[] sum;\n        if (a.length > b.length) {\n            sum = new int[a.length];\n            for (int i = 0; i < a.length; i++) {\n                if (i < b.length) {\n                    sum[i] = a[i] + b[i];\n                } else {\n                    sum[i] = a[i];\n                }\n            }\n        } else {\n            sum = new int[b.length];\n            for (int i = 0; i < b.length; i++) {\n                if (i < a.length) {\n                    sum[i] = a[i] + b[i];\n                } else {\n                    sum[i] = b[i];\n                }\n            }\n        }\n        return sum;\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 179, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请帮我实现一段java代码，实现：输入一段字符串，其中会含有<a>标签 ，输出的是处理过的字符串，要求：1、被<a> </a>所包裹的内容保持不变 2、没有被<a>标签包裹的内容需要被<b>标签包裹\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testWrapNonATagContent1() {\n        String input = \"Hello <a>World</a>!\";\n        String expected = \"<b>Hello </b><a>World</a><b>!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n}", "problem": "请帮我实现一段java代码，实现：输入一段字符串，其中会含有<a>标签 ，输出的是处理过的字符串，要求：1、被<a> </a>所包裹的内容保持不变 2、没有被<a>标签包裹的内容需要被<b>标签包裹", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass MainTest {\n    @Test\n    void testWrapNonATagContent2() {\n        String input = \"<a>Hello</a> World!\";\n        String expected = \"<a>Hello</a><b> World!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n\n    @Test\n    void testWrapNonATagContent3() {\n        String input = \"Hello World!\";\n        String expected = \"<b>Hello World!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n\n    @Test\n    void testWrapNonATagContent4() {\n        String input = \"<a>Hello</a><a>World</a>!\";\n        String expected = \"<a>Hello</a><a>World</a><b>!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n\n    @Test\n    void testWrapNonATagContent5() {\n        String input = \"Hello<a>World</a>!\";\n        String expected = \"<b>Hello</b><a>World</a><b>!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n\n    @Test\n    void testWrapNonATagContent6() {\n        String input = \"<a>Hello</a> <a>World</a>!\";\n        String expected = \"<a>Hello</a><b> </b><a>World</a><b>!</b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n\n    @Test\n    void testWrapNonATagContent7() {\n        String input = \"<a></a>\";\n        String expected = \"<a></a>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n\n    @Test\n    void testWrapNonATagContent8() {\n        String input = \"\";\n        String expected = \"<b></b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n\n    @Test\n    void testWrapNonATagContent9() {\n        String input = \" \";\n        String expected = \"<b> </b>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n\n    @Test\n    void testWrapNonATagContent10() {\n        String input = \"<a> </a>\";\n        String expected = \"<a> </a>\";\n        assertEquals(expected, Main.wrapNonATagContent(input));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        String input = \"Hello <a>World</a>!\";\n        System.out.println(wrapNonATagContent(input));\n    }\n\n    public static String wrapNonATagContent(String input) {\n        String[] parts = input.split(\"(?=<a>)|(?<=</a>)\");\n        StringBuilder result = new StringBuilder();\n        Pattern pattern = Pattern.compile(\"<a>.*</a>\");\n\n        for (String part : parts) {\n            Matcher matcher = pattern.matcher(part);\n            if (!matcher.matches()) {\n                result.append(\"<b>\").append(part).append(\"</b>\");\n            } else {\n                result.append(part);\n            }\n        }\n\n        return result.toString();\n    }\n}\n\n```", "classification": "前端开发"}
{"_id": 180, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n需求描述:国家实行无偿献血制度，对于献血者的体格检查的部分标准为：年龄为18～55周\n岁，男性体重≥ 50kg，女性本重 ≥45kg，每次献血量为200m1~400ml。用Java编写程序实现输入献血的年龄，性别，体重，判断其是否能进行献血。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class BloodDonationEligibilityTest {\n\n\n    @Test\n    public void testEligibleMale() {\n        assertTrue(\"A male aged 30 weighing 60kg should be eligible\", eligibility.isEligibleForDonation(30, \"male\", 60));\n    }\n}", "problem": "需求描述:国家实行无偿献血制度，对于献血者的体格检查的部分标准为：年龄为18～55周\n岁，男性体重≥ 50kg，女性本重 ≥45kg，每次献血量为200m1~400ml。用Java编写程序实现输入献血的年龄，性别，体重，判断其是否能进行献血。\n", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class BloodDonationEligibilityTest {\n    private BloodDonationEligibility eligibility = new BloodDonationEligibility();\n    @Test\n    public void testEligibleFemale() {\n        assertTrue(\"A female aged 25 weighing 50kg should be eligible\", eligibility.isEligibleForDonation(25, \"female\", 50));\n    }\n\n    @Test\n    public void testIneligibleAge() {\n        assertFalse(\"A person aged 17 should be ineligible\", eligibility.isEligibleForDonation(17, \"male\", 60));\n    }\n\n    @Test\n    public void testIneligibleMaleWeight() {\n        assertFalse(\"A male weighing 49kg should be ineligible\", eligibility.isEligibleForDonation(30, \"male\", 49));\n    }\n\n    @Test\n    public void testIneligibleFemaleWeight() {\n        assertFalse(\"A female weighing 44kg should be ineligible\", eligibility.isEligibleForDonation(25, \"female\", 44));\n    }\n\n    @Test\n    public void testIneligibleAgeAndWeightMale() {\n        assertFalse(\"A male aged 16 weighing 48kg should be ineligible\", eligibility.isEligibleForDonation(16, \"male\", 48));\n    }\n\n    @Test\n    public void testIneligibleAgeAndWeightFemale() {\n        assertFalse(\"A female aged 56 weighing 44kg should be ineligible\", eligibility.isEligibleForDonation(56, \"female\", 44));\n    }\n\n    @Test\n    public void testUpperBoundaryAgeMale() {\n        assertTrue(\"A male aged 55 weighing 50kg should be eligible\", eligibility.isEligibleForDonation(55, \"male\", 50));\n    }\n\n    @Test\n    public void testUpperBoundaryAgeFemale() {\n        assertTrue(\"A female aged 55 weighing 45kg should be eligible\", eligibility.isEligibleForDonation(55, \"female\", 45));\n    }\n\n    @Test\n    public void testLowerBoundaryAgeMale() {\n        assertTrue(\"A male aged 18 weighing 50kg should be eligible\", eligibility.isEligibleForDonation(18, \"male\", 50));\n    }\n\n    @Test\n    public void testLowerBoundaryAgeFemale() {\n        assertTrue(\"A female aged 18 weighing 45kg should be eligible\", eligibility.isEligibleForDonation(18, \"female\", 45));\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\npublic class BloodDonationEligibility {\n\n    public boolean isEligibleForDonation(int age, String gender, double weight) {\n        // 检查年龄是否在18到55岁之间\n        if (age < 18 || age > 55) {\n            return false;\n        }\n\n        // 根据性别检查体重\n        if (\"male\".equalsIgnoreCase(gender) && weight < 50) {\n            return false;\n        } else if (\"female\".equalsIgnoreCase(gender) && weight < 45) {\n            return false;\n        }\n\n        // 如果通过上述所有检查，则符合献血条件\n        return true;\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 181, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n给你一个下标从 0 开始的字符串数组 words 和两个整数：left 和 right 。\n\n如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 元音字符串 ，其中元音字母是 'a'、'e'、'i'、'o'、'u' 。\n\n返回 words[i] 是元音字符串的数目，其中 i 在闭区间 [left, right] 内。\n\n使用java解答\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testCountVowelStrings1() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(0, Main.countVowelStrings(words, 1, 5));\n    }\n}", "problem": "给你一个下标从 0 开始的字符串数组 words 和两个整数：left 和 right 。\n\n如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 元音字符串 ，其中元音字母是 'a'、'e'、'i'、'o'、'u' 。\n\n返回 words[i] 是元音字符串的数目，其中 i 在闭区间 [left, right] 内。\n\n使用java解答", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass MainTest {\n    @Test\n    void testCountVowelStrings2() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(1, Main.countVowelStrings(words, 0, 3));\n    }\n\n    @Test\n    void testCountVowelStrings3() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(0, Main.countVowelStrings(words, 2, 4));\n    }\n\n    @Test\n    void testCountVowelStrings4() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(1, Main.countVowelStrings(words, 0, 6));\n    }\n\n    @Test\n    void testCountVowelStrings5() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(0, Main.countVowelStrings(words, 3, 3));\n    }\n\n    @Test\n    void testCountVowelStrings6() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        assertEquals(0, Main.countVowelStrings(words, 4, 6));\n    }\n\n    @Test\n    void testCountVowelStrings7() {\n        String[] words = {\"apple\"};\n        assertEquals(1, Main.countVowelStrings(words, 0, 0));\n    }\n\n    @Test\n    void testCountVowelStrings8() {\n        String[] words = {\"banana\"};\n        assertEquals(0, Main.countVowelStrings(words, 0, 0));\n    }\n\n    @Test\n    void testCountVowelStrings9() {\n        String[] words = {\"apple\", \"banana\"};\n        assertEquals(1, Main.countVowelStrings(words, 0, 1));\n    }\n\n    @Test\n    void testCountVowelStrings10() {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\", \"honeydew\", \"ice cream\", \"jackfruit\"};\n        assertEquals(1, Main.countVowelStrings(words, 0, 9));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] words = {\"apple\", \"banana\", \"cherry\", \"date\", \"egg\", \"fig\", \"grape\"};\n        int left = 1;\n        int right = 5;\n        System.out.println(countVowelStrings(words, left, right));\n    }\n\n    public static int countVowelStrings(String[] words, int left, int right) {\n        int count = 0;\n        for (int i = left; i <= right; i++) {\n            if (isVowelString(words[i])) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private static boolean isVowelString(String word) {\n        char firstChar = word.charAt(0);\n        char lastChar = word.charAt(word.length() - 1);\n        return isVowel(firstChar) && isVowel(lastChar);\n    }\n\n    private static boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 182, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJava方法重载自定义一个求最大值的类。\n求三个数中最大值的方法，并实现方法重载，要求能够分别比较三个整数中的最大值，三个小数中的最大值，以及任意三个数中的最大值。\n\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MaxValueTest {\n\n    @Test\n    void testMaxInt() {\n        MaxValue maxValue = new MaxValue();\n        assertEquals(9, maxValue.max(3, 5, 9));\n        assertEquals(0, maxValue.max(0, -1, -2));\n        assertEquals(100, maxValue.max(100, 100, 100));\n        assertEquals(-1, maxValue.max(-1, -2, -3));\n        assertEquals(Integer.MAX_VALUE, maxValue.max(Integer.MAX_VALUE, 0, -1));\n        assertEquals(Integer.MIN_VALUE, maxValue.max(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE));\n    }\n}", "problem": "Java方法重载自定义一个求最大值的类。\n求三个数中最大值的方法，并实现方法重载，要求能够分别比较三个整数中的最大值，三个小数中的最大值，以及任意三个数中的最大值。\n", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass MaxValueTest {\n    @Test\n    void testMaxDouble() {\n        MaxValue maxValue = new MaxValue();\n        assertEquals(9.9, maxValue.max(3.3, 5.5, 9.9));\n        assertEquals(0.0, maxValue.max(0.0, -1.1, -2.2));\n        assertEquals(100.1, maxValue.max(100.1, 100.1, 100.1));\n        assertEquals(-1.1, maxValue.max(-1.1, -2.2, -3.3));\n        assertEquals(Double.MAX_VALUE, maxValue.max(Double.MAX_VALUE, 0.0, -1.1));\n        assertEquals(Double.MIN_VALUE, maxValue.max(Double.MIN_VALUE, Double.MIN_VALUE, Double.MIN_VALUE));\n    }\n\n    @Test\n    void testMaxNumber() {\n        MaxValue maxValue = new MaxValue();\n        assertEquals(9.9, maxValue.max(3, 5.5, 9.9));\n        assertEquals(0.0, maxValue.max(0, -1.1, -2));\n        assertEquals(100.1, maxValue.max(100, 100.1, 100));\n        assertEquals(-1, maxValue.max(-1, -2.2, -3));\n        assertEquals(Double.MIN_VALUE, maxValue.max(Integer.MIN_VALUE, Double.MIN_VALUE, Double.MIN_VALUE));\n    }\n}", "setup_code": "", "reference_solution": "```java\n\npublic class MaxValue {\n    // Method to find maximum in three integers\n    public int max(int num1, int num2, int num3) {\n        return Math.max(num1, Math.max(num2, num3));\n    }\n\n    // Method to find maximum in three doubles\n    public double max(double num1, double num2, double num3) {\n        return Math.max(num1, Math.max(num2, num3));\n    }\n\n    // Method to find maximum in three numbers (any type)\n    public double max(Number num1, Number num2, Number num3) {\n        return Math.max(num1.doubleValue(), Math.max(num2.doubleValue(), num3.doubleValue()));\n    }\n}\n\n```", "classification": "软件工程"}
{"_id": 183, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\nJava中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n\n\n    @Test\n    public void testAlternateCaseBasic() {\n        assertEquals(\"LeGeNdArY\", StringUtils.alternateCase(\"legendary\"));\n    }\n}", "problem": "Java中，把字符串\"legendary\"中字符 改成间隔大写小写模式，\n\n即 \"LeGeNdArY\"\n\n提示:\n\n借助API\n\nCharacter.toUpperCase把字符转换成大写", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class StringUtilsTest {\n    @Test\n    public void testAlternateCaseEmpty() {\n        assertEquals(\"\", StringUtils.alternateCase(\"\"));\n    }\n\n    @Test\n    public void testAlternateCaseAllLowerCase() {\n        assertEquals(\"AbCdEf\", StringUtils.alternateCase(\"abcdef\"));\n    }\n\n    @Test\n    public void testAlternateCaseAllUpperCase() {\n        assertEquals(\"AbCdEf\", StringUtils.alternateCase(\"ABCDEF\"));\n    }\n\n    @Test\n    public void testAlternateCaseWithSpecialCharacters() {\n        assertEquals(\"A!B@C#D$\", StringUtils.alternateCase(\"a!b@c#d$\"));\n    }\n\n    @Test\n    public void testAlternateCaseSingleCharacter() {\n        assertEquals(\"A\", StringUtils.alternateCase(\"a\"));\n    }\n\n    @Test\n    public void testAlternateCaseLongString() {\n        String longString = \"abcdefghijklmnopqrstuvwxyz\";\n        String expected = \"AbCdEfGhIjKlMnOpQrStUvWxYz\";\n        assertEquals(expected, StringUtils.alternateCase(longString));\n    }\n\n    @Test\n    public void testAlternateCaseNonAlphabetic() {\n        assertEquals(\"1!2@3#\", StringUtils.alternateCase(\"1!2@3#\"));\n    }\n\n    @Test\n    public void testAlternateCaseConsecutiveCases() {\n        assertEquals(\"AaBbCcDd\", StringUtils.alternateCase(\"AABbccDd\"));\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\npublic class StringUtils {\n\n    public static String alternateCase(String input) {\n        StringBuilder sb = new StringBuilder(input.length());\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (i % 2 == 0) {\n                sb.append(Character.toUpperCase(c));\n            } else {\n                sb.append(Character.toLowerCase(c));\n            }\n        }\n        return sb.toString();\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 184, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java编写一个切换java jdk版本的程序，用于切换jdk1.7，1.8以及jdk11,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass CommentRemoverTest {\n\n    @Test\n    void testRemoveCommentsFromFile1() {\n        CommentRemover.removeCommentsFromFile(\"test1/test.java\", \"test1/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test1/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "problem": "用java编写一个切换java jdk版本的程序，用于切换jdk1.7，1.8以及jdk11,", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\nclass CommentRemoverTest {\n    @Test\n    void testRemoveCommentsFromFile2() {\n        CommentRemover.removeCommentsFromFile(\"test2/test.java\", \"test2/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test2/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    void testRemoveCommentsFromFile3() {\n        CommentRemover.removeCommentsFromFile(\"test3/test.java\", \"test3/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test3/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    void testRemoveCommentsFromFile4() {\n        CommentRemover.removeCommentsFromFile(\"test4/test.java\", \"test4/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test4/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    void testRemoveCommentsFromFile5() {\n        CommentRemover.removeCommentsFromFile(\"test5/test.java\", \"test5/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test5/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    void testRemoveCommentsFromFile6() {\n        CommentRemover.removeCommentsFromFile(\"test6/test.java\", \"test6/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test6/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    void testRemoveCommentsFromFile7() {\n        CommentRemover.removeCommentsFromFile(\"test7/test.java\", \"test7/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test7/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    void testRemoveCommentsFromFile8() {\n        CommentRemover.removeCommentsFromFile(\"test8/test.java\", \"test8/output.java\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"test8/output.java\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                assertFalse(line.startsWith(\"//\"));\n                assertFalse(line.startsWith(\"/*\"));\n                assertFalse(line.contains(\"*/\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "setup_code": "", "reference_solution": "```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class CommentRemover {\n    public static void removeCommentsFromFile(String inputFilePath, String outputFilePath) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(inputFilePath));\n             BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilePath))) {\n\n            String line;\n            StringBuilder codeBuilder = new StringBuilder();\n            boolean isCommentBlock = false;\n\n            while ((line = reader.readLine()) != null) {\n                line = line.trim();\n\n                // 处理多行注释块\n                if (isCommentBlock) {\n                    if (line.contains(\"*/\")) {\n                        line = line.substring(line.indexOf(\"*/\") + 2);\n                        isCommentBlock = false;\n                    } else {\n                        continue;\n                    }\n                }\n\n                // 处理单行注释\n                if (line.startsWith(\"//\")) {\n                    line = \"\";\n                } else if (line.startsWith(\"/*\")) {\n                    // 处理多行注释块的起始行\n                    if (line.contains(\"*/\")) {\n                        line = line.substring(line.indexOf(\"*/\") + 2);\n                    } else {\n                        isCommentBlock = true;\n                        continue;\n                    }\n                }\n\n                codeBuilder.append(line);\n                codeBuilder.append(System.lineSeparator());\n            }\n\n            writer.write(codeBuilder.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        String inputFilePath = \"Example.java\";\n        String outputFilePath = \"CleanExample.java\";\n\n        removeCommentsFromFile(inputFilePath, outputFilePath);\n    }\n}\n```", "classification": "后端开发"}
{"_id": 185, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java语法,读取java文件并去除其中的所有注释，可以使用正则表达式或解析器来实现,输出去除所有注释的文件,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ImageClassifierTest {\n\n    @Test\n    public void testClassifyImages_case1() {\n        ImageClassifier.classifyImages(\"test1\", 280, 440);\n        assertTrue((new File(\"test1/folder_1/1.jpg\").exists()));\n    }\n}", "problem": "用java语法,读取java文件并去除其中的所有注释，可以使用正则表达式或解析器来实现,输出去除所有注释的文件,", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\n\nclass ImageClassifierTest {\n    @Test\n    public void testClassifyImages_case2() {\n        ImageClassifier.classifyImages(\"test2\", 280, 440);\n        assertTrue((new File(\"test2/folder_1/1.jpg\").exists()));\n        assertTrue((new File(\"test2/folder_3/2.jpg\").exists()));\n    }\n\n    @Test\n    public void testClassifyImages_case3() {\n        ImageClassifier.classifyImages(\"test3\", 280, 440);\n        assertTrue((new File(\"test3/folder_1/1.jpg\").exists()));\n        assertTrue((new File(\"test3/folder_2/4.jpg\").exists()));\n        assertTrue((new File(\"test3/folder_3/2.jpg\").exists()));\n    }\n\n    @Test\n    public void testClassifyImages_case4() {\n        ImageClassifier.classifyImages(\"test4\", 280, 440);\n        assertTrue((new File(\"test4/folder_1/1.jpg\").exists()));\n        assertTrue((new File(\"test4/folder_2/3.jpg\").exists()));\n        assertTrue((new File(\"test4/folder_2/4.jpg\").exists()));\n        assertTrue((new File(\"test4/folder_3/2.jpg\").exists()));\n        assertTrue((new File(\"test4/folder_3/5.jpg\").exists()));\n    }\n\n    @Test\n    public void testClassifyImages_case5() {\n        ImageClassifier.classifyImages(\"test5\", 280, 440);\n        assertTrue((new File(\"test5/folder_3/5.jpg\").exists()));\n    }\n\n    @Test\n    public void testClassifyImages_case6() {\n        ImageClassifier.classifyImages(\"test6\", 280, 440);\n        assertTrue((new File(\"test6/folder_3/2.jpg\").exists()));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\n\npublic class ImageClassifier {\n    public static void classifyImages(String imageFolder, int threshold1, int threshold2){\n        // 分类后的文件夹路径\n        String outputFolder1 = imageFolder + \"/folder_1\";\n        String outputFolder2 = imageFolder + \"/folder_2\";\n        String outputFolder3 = imageFolder + \"/folder_3\";\n\n        // 获取图像文件夹中的所有文件\n        File[] imageFiles = new File(imageFolder).listFiles();\n        if (imageFiles == null) {\n            System.out.println(\"图像文件夹为空或无法访问。\");\n            return;\n        }\n\n        // 遍历图像文件夹中的所有文件\n        for (File imageFile : imageFiles) {\n            if (imageFile.getName().endsWith(\".jpg\") || imageFile.getName().endsWith(\".png\")) {\n                try {\n                    // 读取图像\n                    BufferedImage image = ImageIO.read(imageFile);\n\n                    // 获取图像的长宽\n                    int width = image.getWidth();\n                    int height = image.getHeight();\n\n                    // 根据阈值分类\n                    String outputFolder;\n                    if (width < threshold1 || height < threshold1) {\n                        outputFolder = outputFolder1;\n                    } else if (width < threshold2 || height < threshold2) {\n                        outputFolder = outputFolder2;\n                    } else {\n                        outputFolder = outputFolder3;\n                    }\n\n                    // 确保输出文件夹存在\n                    new File(outputFolder).mkdirs();\n\n                    // 将图像移动到相应的输出文件夹中\n                    Path outputPath = new File(outputFolder, imageFile.getName()).toPath();\n                    Files.copy(imageFile.toPath(), outputPath, StandardCopyOption.REPLACE_EXISTING);\n                } catch (IOException e) {\n                    System.out.println(\"处理图像文件时出错: \" + e.getMessage());\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // 图像文件夹路径\n        String imageFolder = \"images\";\n\n        // 阈值\n        int threshold1 = 100;\n        int threshold2 = 200;\n\n        classifyImages(imageFolder, threshold1, threshold2);\n    }\n}\n```", "classification": "后端开发"}
{"_id": 186, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\njava语言根据图像长宽设定三个阈值进行分类，当长或宽小于阈值100时输出到文件夹folder_1，当长或宽大于阈值100小于阈值200时输出到文件夹folder_2，其它输出到文件夹folder_3,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass DistanceTest {\n\n    @Test\n    void testEuclideanDistance() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n        assertEquals(5.196152422706632, Distance.euclideanDistance(pointA, pointB));\n    }\n}", "problem": "java语言根据图像长宽设定三个阈值进行分类，当长或宽小于阈值100时输出到文件夹folder_1，当长或宽大于阈值100小于阈值200时输出到文件夹folder_2，其它输出到文件夹folder_3,", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass DistanceTest {\n    @Test\n    void testManhattanDistance() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n        assertEquals(9.0, Distance.manhattanDistance(pointA, pointB));\n    }\n\n    @Test\n    void testChebyshevDistance() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n        assertEquals(3.0, Distance.chebyshevDistance(pointA, pointB));\n    }\n\n    @Test\n    void testMinkowskiDistance() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n        assertEquals(5.196152422706632, Distance.minkowskiDistance(pointA, pointB, 2));\n    }\n\n    @Test\n    void testCosineSimilarity() {\n        double[] vectorX = {1, 2, 3};\n        double[] vectorY = {4, 5, 6};\n        assertEquals(0.9746318461970762, Distance.cosineSimilarity(vectorX, vectorY));\n    }\n\n    @Test\n    void testHammingDistance() {\n        String stringP = \"1010101\";\n        String stringQ = \"1001001\";\n        assertEquals(3, Distance.hammingDistance(stringP, stringQ));\n    }\n\n    @Test\n    void testJaccardSimilarity() {\n        Set<Integer> setAlpha = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n        Set<Integer> setBeta = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));\n        assertEquals(0.25, Distance.jaccardSimilarity(setAlpha, setBeta));\n    }\n\n    @Test\n    void testEuclideanDistanceWithSamePoints() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {1, 2, 3};\n        assertEquals(0.0, Distance.euclideanDistance(pointA, pointB));\n    }\n\n    @Test\n    void testManhattanDistanceWithSamePoints() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {1, 2, 3};\n        assertEquals(0.0, Distance.manhattanDistance(pointA, pointB));\n    }\n\n    @Test\n    void testChebyshevDistanceWithSamePoints() {\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {1, 2, 3};\n        assertEquals(0.0, Distance.chebyshevDistance(pointA, pointB));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Distance {\n\n    // 欧几里得距离\n    public static double euclideanDistance(double[] point1, double[] point2) {\n        double sum = 0;\n        for (int i = 0; i < point1.length; i++) {\n            sum += Math.pow(point1[i] - point2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }\n\n    // 曼哈顿距离\n    public static double manhattanDistance(double[] point1, double[] point2) {\n        double sum = 0;\n        for (int i = 0; i < point1.length; i++) {\n            sum += Math.abs(point1[i] - point2[i]);\n        }\n        return sum;\n    }\n\n    // 切比雪夫距离\n    public static double chebyshevDistance(double[] point1, double[] point2) {\n        double max = 0;\n        for (int i = 0; i < point1.length; i++) {\n            max = Math.max(max, Math.abs(point1[i] - point2[i]));\n        }\n        return max;\n    }\n\n    // 闵可夫斯基距离\n    public static double minkowskiDistance(double[] point1, double[] point2, double p) {\n        double sum = 0;\n        for (int i = 0; i < point1.length; i++) {\n            sum += Math.pow(Math.abs(point1[i] - point2[i]), p);\n        }\n        return Math.pow(sum, 1 / p);\n    }\n\n    // 余弦相似度\n    public static double cosineSimilarity(double[] vector1, double[] vector2) {\n        double dotProduct = 0;\n        double normVector1 = 0;\n        double normVector2 = 0;\n\n        for (int i = 0; i < vector1.length; i++) {\n            dotProduct += vector1[i] * vector2[i];\n            normVector1 += Math.pow(vector1[i], 2);\n            normVector2 += Math.pow(vector2[i], 2);\n        }\n\n        return dotProduct / (Math.sqrt(normVector1) * Math.sqrt(normVector2));\n    }\n\n    // 汉明距离\n    public static int hammingDistance(String string1, String string2) {\n        int distance = 0;\n        for (int i = 0; i < string1.length(); i++) {\n            if (string1.charAt(i) != string2.charAt(i)) {\n                distance++;\n            }\n        }\n        return distance;\n    }\n\n    // Jaccard相似度\n    public static double jaccardSimilarity(Set<Integer> set1, Set<Integer> set2) {\n        Set<Integer> intersection = new HashSet<>(set1);\n        intersection.retainAll(set2);\n\n        Set<Integer> union = new HashSet<>(set1);\n        union.addAll(set2);\n\n        return (double) intersection.size() / union.size();\n    }\n\n    public static void main(String[] args) {\n        // 手动编写数据\n        double[] pointA = {1, 2, 3};\n        double[] pointB = {4, 5, 6};\n\n        double[] vectorX = {1, 2, 3};\n        double[] vectorY = {4, 5, 6};\n\n        String stringP = \"1010101\";\n        String stringQ = \"1001001\";\n\n        Set<Integer> setAlpha = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));\n        Set<Integer> setBeta = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));\n\n        // 调用函数并输出结果\n        System.out.println(\"Euclidean Distance: \" + euclideanDistance(pointA, pointB));\n        System.out.println(\"Manhattan Distance: \" + manhattanDistance(pointA, pointB));\n        System.out.println(\"Chebyshev Distance: \" + chebyshevDistance(pointA, pointB));\n        System.out.println(\"Minkowski Distance (p=2): \" + minkowskiDistance(pointA, pointB, 2));\n        System.out.println(\"Cosine Similarity: \" + cosineSimilarity(vectorX, vectorY));\n        System.out.println(\"Hamming Distance: \" + hammingDistance(stringP, stringQ));\n        System.out.println(\"Jaccard Similarity: \" + jaccardSimilarity(setAlpha, setBeta));\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 187, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java函数编写欧几里得、曼哈顿、切比雪夫、闵可夫斯基、余弦相似度、汉明距离、Jaccard相似度等距离计算方法。手动编写数据调用这些距离计算函数。输出计算结果。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass TestConvertLabels {\n\n\n    @Test\n    void testConvertLabels1(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>950</xmin><ymin>786</ymin><xmax>1400</xmax><ymax>1052</ymax></bndbox><name>1</name></object></annotation>\", new int[]{950,786,1400,1052}, \"0\");\n    }\n}", "problem": "用java函数编写欧几里得、曼哈顿、切比雪夫、闵可夫斯基、余弦相似度、汉明距离、Jaccard相似度等距离计算方法。手动编写数据调用这些距离计算函数。输出计算结果。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.*;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.w3c.dom.*;\n\nimport javax.xml.parsers.*;\nimport java.nio.file.*;\n\nclass TestConvertLabels {\n    @Test\n    void testConvertLabels2(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>0</xmin><ymin>0</ymin><xmax>2</xmax><ymax>2</ymax></bndbox><name>1</name></object></annotation>\", new int[]{1,1,3,3}, \"0\");\n    }\n\n    @Test\n    void testConvertLabels3(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>0</xmin><ymin>0</ymin><xmax>2</xmax><ymax>2</ymax></bndbox><name>1</name></object></annotation>\", new int[]{2,2,4,4}, \"1\");\n    }\n\n    @Test\n    void testConvertLabels4(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>0</xmin><ymin>0</ymin><xmax>2</xmax><ymax>2</ymax></bndbox><name>1</name></object></annotation>\", new int[]{0,0,2,2}, \"0\");\n    }\n\n    @Test\n    void testConvertLabels5(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>1000</xmin><ymin>800</ymin><xmax>1300</xmax><ymax>1000</ymax></bndbox><name>1</name></object></annotation>\", new int[]{950,786,1400,1052}, \"0\");\n    }\n\n    @Test\n    void testConvertLabels6(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>900</xmin><ymin>750</ymin><xmax>1450</xmax><ymax>1100</ymax></bndbox><name>1</name></object></annotation>\", new int[]{950,786,1400,1052}, \"0\");\n    }\n\n    @Test\n    void testConvertLabels7(@TempDir Path tempDir) throws Exception {\n        testConvertLabelsHelper(tempDir, \"<annotation><object><bndbox><xmin>950</xmin><ymin>786</ymin><xmax>1400</xmax><ymax>1052</ymax></bndbox><name>2</name></object></annotation>\", new int[]{950,786,1400,1052}, \"0\");\n    }\n    // Repeat for testConvertLabels2, testConvertLabels3, etc., changing the XML string, array, and expected string as needed.\n\n    private void testConvertLabelsHelper(Path tempDir, String xml, int[] bounds, String expected) throws Exception {\n        Path subDir = tempDir.resolve(\"sub\");\n        Files.createDirectory(subDir);\n        Path xmlFile = subDir.resolve(\"label.xml\");\n        Files.write(xmlFile, xml.getBytes());\n\n        // Assuming convertLabels is a static method in a class called MyClass.\n        LabelConverter.convertLabels(xmlFile.toString(), bounds);\n\n        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        Document doc = builder.parse(xmlFile.toFile());\n        String actual = doc.getElementsByTagName(\"name\").item(0).getTextContent();\n        assertEquals(expected, actual);\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class LabelConverter {\n    public static double calculateIoU(int[] box1, int[] box2) {\n        int x1 = box1[0];\n        int y1 = box1[1];\n        int x2 = box1[2];\n        int y2 = box1[3];\n        int x3 = box2[0];\n        int y3 = box2[1];\n        int x4 = box2[2];\n        int y4 = box2[3];\n\n        // 计算相交矩形的左上角和右下角坐标\n        int inter_x1 = Math.max(x1, x3);\n        int inter_y1 = Math.max(y1, y3);\n        int inter_x2 = Math.min(x2, x4);\n        int inter_y2 = Math.min(y2, y4);\n\n        // 计算相交矩形的面积\n        int inter_area = Math.max(0, inter_x2 - inter_x1 + 1) * Math.max(0, inter_y2 - inter_y1 + 1);\n\n        // 计算并集面积和IoU\n        int box1_area = (x2 - x1 + 1) * (y2 - y1 + 1);\n        int box2_area = (x4 - x3 + 1) * (y4 - y3 + 1);\n        int union_area = box1_area + box2_area - inter_area;\n        double iou = (double) inter_area / union_area;\n\n        return iou;\n    }\n\n    public static void convertLabels(String labelFile, int[] targetRegion) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        Document doc = factory.newDocumentBuilder().parse(new File(labelFile));\n\n        NodeList objectList = doc.getElementsByTagName(\"object\");\n\n        for (int i = 0; i < objectList.getLength(); i++) {\n            Element objectElem = (Element) objectList.item(i);\n            Element bboxElem = (Element) objectElem.getElementsByTagName(\"bndbox\").item(0);\n\n            int xmin = Integer.parseInt(bboxElem.getElementsByTagName(\"xmin\").item(0).getTextContent());\n            int ymin = Integer.parseInt(bboxElem.getElementsByTagName(\"ymin\").item(0).getTextContent());\n            int xmax = Integer.parseInt(bboxElem.getElementsByTagName(\"xmax\").item(0).getTextContent());\n            int ymax = Integer.parseInt(bboxElem.getElementsByTagName(\"ymax\").item(0).getTextContent());\n\n            // 计算当前边界框与目标区域的IoU\n            double iou = calculateIoU(targetRegion, new int[]{xmin, ymin, xmax, ymax});\n\n            // 如果IoU大于0.2，则将类别设置为0\n            if (iou > 0.2) {\n                Element nameElem = (Element) objectElem.getElementsByTagName(\"name\").item(0);\n                nameElem.setTextContent(\"0\");\n            }\n        }\n\n        // 保存更新后的XML文件\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        DOMSource source = new DOMSource(doc);\n        StreamResult result = new StreamResult(new File(labelFile));\n        transformer.transform(source, result);\n    }\n\n    public static void main(String[] args) {\n        int[] targetRegion = {950, 786, 1400, 1052};\n        String labelFile = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\work\\\\1225\\\\annotations\\\\A37-145-BSD-231221-A_485.xml\";\n\n        try {\n            convertLabels(labelFile, targetRegion);\n            System.out.println(\"Label conversion completed successfully.\");\n        } catch (ParserConfigurationException | IOException | SAXException | TransformerException e) {\n            System.out.println(\"An error occurred during label conversion: \" + e.getMessage());\n        }\n    }\n}\n```", "classification": "算法和数据结构"}
{"_id": 188, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n用java标签数据采用VOC格式，实现在给定区域内将IoU大于0.2的真实框标签划分为类别0,\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MainTest {\n\n    @Test\n    void testAddUser1() {\n        UserManager userManager = new UserManager();\n        // Test case 1: Invalid name\n        assertEquals(\"Name illegal\", userManager.addUser(\"123\", \"M\", \"000100200000\"));\n    }\n}", "problem": "用java标签数据采用VOC格式，实现在给定区域内将IoU大于0.2的真实框标签划分为类别0,", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.HashSet;\n\nclass MainTest {\n    @Test\n    void testAddUser2() {\n        UserManager userManager = new UserManager();\n        // Test case 2: Invalid gender\n        assertEquals(\"Sex illegal\", userManager.addUser(\"LaoWang\", \"G\", \"123704601001\"));\n    }\n\n    @Test\n    void testAddUser3() {\n        UserManager userManager = new UserManager();\n        // Test case 3: Invalid ID number format\n        assertEquals(\"ID number illegal\", userManager.addUser(\"LaoWang\", \"M\", \"100003000552\"));\n    }\n\n    @Test\n    void testAddUser4() {\n        UserManager userManager = new UserManager();\n        // Test case 4: ID number and gender mismatch\n        assertEquals(\"ID number illegal\", userManager.addUser(\"LaoWang\", \"M\", \"023004000800\"));\n    }\n\n    @Test\n    void testAddUser5() {\n        UserManager userManager = new UserManager();\n        // Test case 5: Valid input\n        assertEquals(\"Name:LaoWang\\nSex:M\\nID:111102220991\", userManager.addUser(\"LaoWang\", \"M\", \"111102220991\"));\n    }\n\n    @Test\n    void testAddUser6() {\n        UserManager userManager = new UserManager();\n        // Test case 6: ID number already registered\n        assertEquals(\"Name:HaiWang\\nSex:M\\nID:098703100251\", userManager.addUser(\"HaiWang\", \"M\", \"098703100251\"));\n    }\n\n    @Test\n    void testAddUser7() {\n        UserManager userManager = new UserManager();\n        // Test case 7: Minimum valid ID number\n        assertEquals(\"ID number illegal\", userManager.addUser(\"John\", \"M\", \"120004500652\"));\n    }\n\n    @Test\n    void testAddUser8() {\n        UserManager userManager = new UserManager();\n        // Test case 8: Maximum valid ID number\n        assertEquals(\"Name:John\\nSex:M\\nID:002301220991\", userManager.addUser(\"John\", \"M\", \"002301220991\"));\n    }\n\n    @Test\n    void testAddUser9() {\n        UserManager userManager = new UserManager();\n        // Test case 9: ID number just below minimum\n        assertEquals(\"ID number illegal\", userManager.addUser(\"John\", \"M\", \"100000720002\"));\n    }\n\n    @Test\n    void testAddUser10() {\n        UserManager userManager = new UserManager();\n        // Test case 10: ID number just above maximum\n        assertEquals(\"ID number illegal\", userManager.addUser(\"John\", \"M\", \"123004601000\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.HashSet;\n\nclass User {\n    private String name;\n    private char gender;\n    private String idNumber;\n\n    // Constructor\n    public User(String name, char gender, String idNumber) {\n        this.name = name;\n        this.gender = gender;\n        this.idNumber = idNumber;\n    }\n\n    // Getter and setter methods\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public String getIdNumber() {\n        return idNumber;\n    }\n\n    public void setIdNumber(String idNumber) {\n        this.idNumber = idNumber;\n    }\n\n    // toString method\n    @Override\n    public String toString() {\n        return String.format(\"Name:%s\\nSex:%c\\nID:%s\", name, gender, idNumber);\n    }\n}\n\nclass UserManager {\n    private HashSet<String> registeredIds = new HashSet<>();\n\n    public String addUser(String name, String gender, String idNumber) {\n        // Validate arguments\n        if (!name.matches(\"[a-zA-Z_]+\")) {\n            return \"Name illegal\";\n        }\n\n        if (!gender.matches(\"[MFO]\")) {\n            return \"Sex illegal\";\n        }\n\n        if (!idNumber.matches(\"[0-9]{12}\")) {\n            return \"ID number illegal\";\n        }\n\n        // Extract and validate parts of the ID number\n        int part1 = Integer.parseInt(idNumber.substring(0, 4));\n        int part2 = Integer.parseInt(idNumber.substring(4, 8));\n        int part3 = Integer.parseInt(idNumber.substring(8, 12));\n\n        if (part1 < 1 || part1 > 1237 || part2 < 20 || part2 > 460 || part3 / 10 < 0 || part3 / 10 > 100) {\n            return \"ID number illegal\";\n        }\n\n        // Check if the last digit of ID number matches the gender\n        int lastDigit = part3 % 10;\n        if ((gender.equals(\"M\") && lastDigit != 1) || (gender.equals(\"F\") && lastDigit != 0) || (gender.equals(\"O\") && lastDigit != 2)) {\n            return \"ID number illegal\";\n        }\n\n        // Check if ID number already registered\n        if (registeredIds.contains(idNumber)) {\n            return \"ID number exist\";\n        }\n\n        // All checks passed, add user\n        User newUser = new User(name, gender.charAt(0), idNumber);\n        registeredIds.add(idNumber);\n\n        // Return formatted user information\n        return newUser.toString();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        UserManager userManager = new UserManager();\n\n        // Example usage\n        System.out.println(userManager.addUser(\"LaoWang\", \"M\", \"003005001010\")); // ID number illegal\n        System.out.println(userManager.addUser(\"LaoWang\", \"M\", \"002301220991\")); // Name:LaoWang\\nSex:M\\nID:002301220991\n        System.out.println(userManager.addUser(\"HaiWang\", \"M\", \"002301220991\")); // ID number exist\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 189, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请用java语言为用户设立一个 User 类：\n私有属性至少包括姓名（仅可能由 26 个字母大小写和下划线构成）、性别（字符 M/F/O，分别表示男性/女性/其他）、ID卡号（符合下述合法格式）\nID卡号一共12位，每个用户唯一\n前4位的范围是[0001,1237]\n中间4位的范围为[0020,0460]\n最后四位为生物识别库提供的生物识别码，前三位的范围为[000,100]，最后一位表示持有人的性别，0代表女性，1代表男性，2代表其他。\n合法的ID卡号示例：\n0023 0122 0991\n1000 0072 0000\n不合法的ID卡号示例：\n0000 0122 0991\n0030 0500 1010\n1234 0123 0553\n需要为用户的3种属性提供相应的 getter 和 setter 方法\n实现方法 String toString() 打印用户格式化信息，具体要求如下：\n1.冒号为英文字符 :\n2.不包含多余的空格\n3.所有字符为半角字符\n以 jack，ID卡号 0910 0072 0112 为例：\nName:jack\nSex:O\nID:091000720112 \n实现添加用户方法，命令格式如下：\n选项\t[参数 1]\t[参数 2]\t[参数 3]\t功能描述\naddUser\t姓名\t性别\t卡号\t新增用户对象并储存相关信息，对于非法输入，终端输出相应报错。对于合法输入，调用该对象的 toString() 方法。\n具体要求如下：\n在输入 addUser 命令时，并不保证参数数量严格对应，这也是一种非法情况，需要在终端输出：\nArguments illegal\n如果参数合法，按以下顺序依次进行信息检查\n姓名由 26 个字母和下划线构成，其他情况请输出\nName illegal\n性别必须为 F / M / O，其他情况请输出\nSex illegal\n卡号需满足指定格式，非法（包括尾号和性别不符的情况）请输出\nID number illegal\n一张卡号只能注册一次，若注册卡号已存在请输出\nID number exist\n如果存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n如果输入合法，按 toString() 输出格式打印刚添加的用户信息。如：\naddUser LaoWang M\nArguments illegal\naddUser LaoWang GHS 123123\nSex illegal\naddUser LaoWang M 003005001010\nAadhaar number illegal\naddUser LaoWang M 002301220991\nName:LaoWang\nSex:M\nAadhaar:002301220991\naddUser HaiWang M 002301220991\nAadhaar number exist\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass CopyFileTest {\n\n\n    @Test\n    void testCopyAndMoveFile1() {\n        String sourceFilePath = \"test1/test.txt\";\n        String destinationDirectory = \"test1/target\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n}", "problem": "请用java语言为用户设立一个 User 类：\n私有属性至少包括姓名（仅可能由 26 个字母大小写和下划线构成）、性别（字符 M/F/O，分别表示男性/女性/其他）、ID卡号（符合下述合法格式）\nID卡号一共12位，每个用户唯一\n前4位的范围是[0001,1237]\n中间4位的范围为[0020,0460]\n最后四位为生物识别库提供的生物识别码，前三位的范围为[000,100]，最后一位表示持有人的性别，0代表女性，1代表男性，2代表其他。\n合法的ID卡号示例：\n0023 0122 0991\n1000 0072 0000\n不合法的ID卡号示例：\n0000 0122 0991\n0030 0500 1010\n1234 0123 0553\n需要为用户的3种属性提供相应的 getter 和 setter 方法\n实现方法 String toString() 打印用户格式化信息，具体要求如下：\n1.冒号为英文字符 :\n2.不包含多余的空格\n3.所有字符为半角字符\n以 jack，ID卡号 0910 0072 0112 为例：\nName:jack\nSex:O\nID:091000720112 \n实现添加用户方法，命令格式如下：\n选项\t[参数 1]\t[参数 2]\t[参数 3]\t功能描述\naddUser\t姓名\t性别\t卡号\t新增用户对象并储存相关信息，对于非法输入，终端输出相应报错。对于合法输入，调用该对象的 toString() 方法。\n具体要求如下：\n在输入 addUser 命令时，并不保证参数数量严格对应，这也是一种非法情况，需要在终端输出：\nArguments illegal\n如果参数合法，按以下顺序依次进行信息检查\n姓名由 26 个字母和下划线构成，其他情况请输出\nName illegal\n性别必须为 F / M / O，其他情况请输出\nSex illegal\n卡号需满足指定格式，非法（包括尾号和性别不符的情况）请输出\nID number illegal\n一张卡号只能注册一次，若注册卡号已存在请输出\nID number exist\n如果存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n如果输入合法，按 toString() 输出格式打印刚添加的用户信息。如：\naddUser LaoWang M\nArguments illegal\naddUser LaoWang GHS 123123\nSex illegal\naddUser LaoWang M 003005001010\nAadhaar number illegal\naddUser LaoWang M 002301220991\nName:LaoWang\nSex:M\nAadhaar:002301220991\naddUser HaiWang M 002301220991\nAadhaar number exist", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.PrintStream;\nimport java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Paths;\n\nclass CopyFileTest {\n    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();\n    private final PrintStream originalOut = System.out;\n\n    @BeforeEach\n    public void setUpStreams() {\n        System.setOut(new PrintStream(outContent));\n    }\n    @Test\n    void testCopyAndMoveFile2() {\n        String sourceFilePath = \"test2/test.txt\";\n        String destinationDirectory = \"test2/target\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertEquals(\"File not exist.\\n\", outContent.toString());\n    }\n\n    @Test\n    void testCopyAndMoveFile3() {\n        String sourceFilePath = \"test3/source/test.txt\";\n        String destinationDirectory = \"test3\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n\n    @Test\n    void testCopyAndMoveFile4() {\n        String sourceFilePath = \"test4/test.txt\";\n        String destinationDirectory = \"test4\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n\n    @Test\n    void testCopyAndMoveFile5() {\n        String sourceFilePath = \"test5/source/test.txt\";\n        String destinationDirectory = \"test5/target\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n\n    @Test\n    void testCopyAndMoveFile6() {\n        String sourceFilePath = \"test6/test.txt\";\n        String destinationDirectory = \"test6/target\";\n        CopyFile.copyAndMoveFile(sourceFilePath, destinationDirectory);\n        assertTrue(Files.exists(Paths.get(destinationDirectory, \"test.txt\")));\n    }\n\n    @AfterEach\n    public void restoreStreams() {\n        System.setOut(originalOut);\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.io.IOException;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class CopyFile {\n    public static void copyAndMoveFile(String sourcePath, String destinationDirectory) {\n        // 获取源文件的文件名\n        Path sourceFilePath = Paths.get(sourcePath);\n        String fileName = sourceFilePath.getFileName().toString();\n\n        // 构建目标路径\n        Path destinationPath = Paths.get(destinationDirectory, fileName);\n\n        try {\n            // 检查源文件是否存在\n            if (Files.exists(sourceFilePath)) {\n                // 复制文件\n                Files.copy(sourceFilePath, destinationPath);\n            } else {\n                System.out.println(\"File not exist.\");\n            }\n        } catch (FileAlreadyExistsException e) {\n            System.out.println(e.getMessage());\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        // 例子\n        String sourceFilePath = \"C:\\\\Users\\\\jieman\\\\Desktop\\\\json\\\\aaaa.py\";\n        String destinationDirectory = \"C:\\\\Users\\\\jieman\\\\Desktop\\\\MFGRN\";\n\n        copyAndMoveFile(sourceFilePath, destinationDirectory);\n    }\n}\n```", "classification": "后端开发"}
{"_id": 190, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n手动编写数据，使用java语言编写K均值（K-means）聚类算法。计算输出每个数据样本的结果\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass LongestPathTest {\n\n    @Test\n    public void testLengthLongestPath1() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n}", "problem": "手动编写数据，使用java语言编写K均值（K-means）聚类算法。计算输出每个数据样本的结果", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass LongestPathTest {\n    @Test\n    public void testLengthLongestPath2() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\";\n        int expected = 21;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n\n    @Test\n    public void testLengthLongestPath3() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tsubsubdir1\\n\\t\\t\\tfile1.ext\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n\n    @Test\n    public void testLengthLongestPath4() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\t\\t\\tfile2.ext\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile3.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n\n    @Test\n    public void testLengthLongestPath5() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\t\\t\\tfile2.ext\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile3.ext\\n\\t\\t\\t\\tfile4.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n\n    @Test\n    public void testLengthLongestPath6() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\t\\t\\tfile2.ext\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile3.ext\\n\\t\\t\\t\\tfile4.ext\\n\\t\\t\\t\\t\\tfile5.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n\n    @Test\n    public void testLengthLongestPath7() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\";\n        int expected = 0;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n\n    @Test\n    public void testLengthLongestPath8() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\";\n        int expected = 0;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n\n    @Test\n    public void testLengthLongestPath9() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\";\n        int expected = 21;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n\n    @Test\n    public void testLengthLongestPath10() {\n        LongestPath lp = new LongestPath();\n        String input = \"dir\\n\\tsubdir1\\n\\t\\tsubsubdir1\\n\\t\\t\\tfile1.ext\";\n        int expected = 32;\n        assertEquals(expected, lp.lengthLongestPath(input));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass LongestPath {\n    public int lengthLongestPath(String input) {\n        int n = input.length();\n        int pos = 0;\n        int ans = 0;\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        while (pos < n) {\n            /* 检测当前文件的深度 */\n            int depth = 1;\n            while (pos < n && input.charAt(pos) == '\\t') {\n                pos++;\n                depth++;\n            }\n            /* 统计当前文件名的长度 */\n            boolean isFile = false;\n            int len = 0;\n            while (pos < n && input.charAt(pos) != '\\n') {\n                if (input.charAt(pos) == '.') {\n                    isFile = true;\n                }\n                len++;\n                pos++;\n            }\n            /* 跳过当前的换行符 */\n            pos++;\n            while (stack.size() >= depth) {\n                stack.pop();\n            }\n            if (!stack.isEmpty()) {\n                len += stack.peek() + 1;\n            }\n            if (isFile) {\n                ans = Math.max(ans, len);\n            } else {\n                stack.push(len);\n            }\n        }\n        return ans;\n    }\n}\n```", "classification": "算法和数据结构"}
{"_id": 191, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请使用java完成一个进度条类ProgressBar以展示工程进度。具体要求如下：1.接受一个参数totalTasks，表示总任务数；2.包含taskCompleted()方法，用于标记任务完成；3.updateProgressBar()方法，用于更新进度条的显示。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ValidPasswordTest {\n\n    @Test\n    void testIsValidPassword1() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@123\"));\n    }\n}", "problem": "请使用java完成一个进度条类ProgressBar以展示工程进度。具体要求如下：1.接受一个参数totalTasks，表示总任务数；2.包含taskCompleted()方法，用于标记任务完成；3.updateProgressBar()方法，用于更新进度条的显示。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass ValidPasswordTest {\n    @Test\n    void testIsValidPassword2() {\n        assertFalse(ValidPassword.isValidPassword(\"example@123\"));\n    }\n\n    @Test\n    void testIsValidPassword3() {\n        assertFalse(ValidPassword.isValidPassword(\"EXAMPLE@123\"));\n    }\n\n    @Test\n    void testIsValidPassword4() {\n        assertFalse(ValidPassword.isValidPassword(\"Example123\"));\n    }\n\n    @Test\n    void testIsValidPassword5() {\n        assertFalse(ValidPassword.isValidPassword(\"Example@\"));\n    }\n\n    @Test\n    void testIsValidPassword6() {\n        assertFalse(ValidPassword.isValidPassword(\"example123\"));\n    }\n\n    @Test\n    void testIsValidPassword7() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@1234567890\"));\n    }\n\n    @Test\n    void testIsValidPassword8() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@1234567890A\"));\n    }\n\n    @Test\n    void testIsValidPassword9() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@1234567890Aa\"));\n    }\n\n    @Test\n    void testIsValidPassword10() {\n        assertTrue(ValidPassword.isValidPassword(\"Example@1234567890Aa!\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ValidPassword {\n    public static boolean isValidPassword(String password) {\n        String passwordRegex = \"^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])(?=\\\\S+$).{8,}$\";\n        Pattern pattern = Pattern.compile(passwordRegex);\n        Matcher matcher = pattern.matcher(password);\n        return matcher.matches();\n    }\n\n    public static void main(String[] args) {\n        String password = \"Example@123\";\n        System.out.println(\"Is the password valid? \" + isValidPassword(password));\n    }\n}\n```", "classification": "软件工程"}
{"_id": 192, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建一个名为LinearRegressionLoss的java类，编写三个静态方法用于计算线性回归中常用的三种损失函数均方误差，平均绝对误差和Huber损失，并在main方法中手动生成数据，调用这三个方法计算相应的损失，并输出相应的计算结果。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass LinearRegressionLossTest {\n\n    @Test\n    public void testCalculateMSE1() {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        assertEquals(0.25, LinearRegressionLoss.calculateMSE(actual, predicted));\n    }\n}", "problem": "创建一个名为LinearRegressionLoss的java类，编写三个静态方法用于计算线性回归中常用的三种损失函数均方误差，平均绝对误差和Huber损失，并在main方法中手动生成数据，调用这三个方法计算相应的损失，并输出相应的计算结果。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass LinearRegressionLossTest {\n    @Test\n    public void testCalculateMSE2() {\n        double[] actual = {1.0, 2.0, 3.0};\n        double[] predicted = {1.0, 2.0, 3.0};\n        assertEquals(0.0, LinearRegressionLoss.calculateMSE(actual, predicted));\n    }\n\n    @Test\n    public void testCalculateMSE3() {\n        double[] actual = {1.0, 2.0, 3.0};\n        double[] predicted = {3.0, 2.0, 1.0};\n        assertEquals(2.6666666666666665, LinearRegressionLoss.calculateMSE(actual, predicted));\n    }\n\n    @Test\n    public void testCalculateMAE1() {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        assertEquals(0.5, LinearRegressionLoss.calculateMAE(actual, predicted));\n    }\n\n    @Test\n    public void testCalculateMAE2() {\n        double[] actual = {1.0, 2.0, 3.0};\n        double[] predicted = {1.0, 2.0, 3.0};\n        assertEquals(0.0, LinearRegressionLoss.calculateMAE(actual, predicted));\n    }\n\n    @Test\n    public void testCalculateMAE3() {\n        double[] actual = {1.0, 2.0, 3.0};\n        double[] predicted = {3.0, 2.0, 1.0};\n        assertEquals(1.3333333333333333, LinearRegressionLoss.calculateMAE(actual, predicted));\n    }\n\n    @Test\n    public void testCalculateHuberLoss1() {\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n        double delta = 1.0;\n        assertEquals(0.125, LinearRegressionLoss.calculateHuberLoss(actual, predicted, delta));\n    }\n\n    @Test\n    public void testCalculateHuberLoss2() {\n        double[] actual = {1.0, 2.0, 3.0};\n        double[] predicted = {1.0, 2.0, 3.0};\n        double delta = 1.0;\n        assertEquals(0.0, LinearRegressionLoss.calculateHuberLoss(actual, predicted, delta));\n    }\n\n    @Test\n    public void testCalculateHuberLoss3() {\n        double[] actual = {1.0, 2.0, 3.0};\n        double[] predicted = {3.0, 2.0, 1.0};\n        double delta = 1.0;\n        assertEquals(1.0, LinearRegressionLoss.calculateHuberLoss(actual, predicted, delta));\n    }\n\n    @Test\n    public void testCalculateHuberLoss4() {\n        double[] actual = {5.5, 2.5, 4.0};\n        double[] predicted = {3.0, 1.5, 3.5};\n        double delta = 0.7;\n        assertEquals(0.695, LinearRegressionLoss.calculateHuberLoss(actual, predicted, delta));\n    }\n}", "setup_code": "", "reference_solution": "```java\n/*\n创建一个名为LinearRegressionLoss的java类，编写三个静态方法用于计算线性回归中常用的三种损失函数均方误差，平均绝对误差和Huber损失，并在main方法中手动生成数据，调用这三个方法计算相应的损失，并输出相应的计算结果。\n*/\npublic class LinearRegressionLoss {\n\n    // Mean Squared Error (MSE)\n    public static double calculateMSE(double[] actual, double[] predicted) {\n        if (actual.length != predicted.length) {\n            throw new IllegalArgumentException(\"Input arrays must have the same length\");\n        }\n\n        double sumSquaredError = 0.0;\n\n        for (int i = 0; i < actual.length; i++) {\n            double error = actual[i] - predicted[i];\n            sumSquaredError += Math.pow(error, 2);\n        }\n\n        return sumSquaredError / actual.length;\n    }\n\n    // Mean Absolute Error (MAE)\n    public static double calculateMAE(double[] actual, double[] predicted) {\n        if (actual.length != predicted.length) {\n            throw new IllegalArgumentException(\"Input arrays must have the same length\");\n        }\n\n        double sumAbsoluteError = 0.0;\n\n        for (int i = 0; i < actual.length; i++) {\n            double error = Math.abs(actual[i] - predicted[i]);\n            sumAbsoluteError += error;\n        }\n\n        return sumAbsoluteError / actual.length;\n    }\n\n    // Huber Loss\n    public static double calculateHuberLoss(double[] actual, double[] predicted, double delta) {\n        if (actual.length != predicted.length) {\n            throw new IllegalArgumentException(\"Input arrays must have the same length\");\n        }\n\n        double sumHuberLoss = 0.0;\n\n        for (int i = 0; i < actual.length; i++) {\n            double error = Math.abs(actual[i] - predicted[i]);\n            if (error <= delta) {\n                sumHuberLoss += 0.5 * Math.pow(error, 2);\n            } else {\n                sumHuberLoss += delta * (error - 0.5 * delta);\n            }\n        }\n\n        return sumHuberLoss / actual.length;\n    }\n\n    public static void main(String[] args) {\n        // Sample data\n        double[] actual = {3.0, 5.0, 7.0, 9.0, 11.0};\n        double[] predicted = {2.5, 5.5, 7.5, 8.5, 10.5};\n\n        // Calculate MSE\n        double mse = calculateMSE(actual, predicted);\n        System.out.println(\"Mean Squared Error (MSE): \" + mse);\n\n        // Calculate MAE\n        double mae = calculateMAE(actual, predicted);\n        System.out.println(\"Mean Absolute Error (MAE): \" + mae);\n\n        // Calculate Huber Loss with delta = 1.0\n        double delta = 1.0;\n        double huberLoss = calculateHuberLoss(actual, predicted, delta);\n        System.out.println(\"Huber Loss (delta = \" + delta + \"): \" + huberLoss);\n    }\n}\n\n\n\n\n\n\n```", "classification": "后端开发"}
{"_id": 193, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n对于java中time包的考察\n编写一个Java程序来计算两个日期之间的间隔。给定两个字符串格式的日期（\"2023-03-15\"和\"2023-04-14\"），计算它们之间的完整天数差。程序应能处理不同年份和闰年。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass DaysBetweenDatesTest {\n\n    @Test\n    void testCalculateDaysBetweenDates() {\n        assertEquals(30, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-04-14\"));\n        assertEquals(365, DaysBetweenDates.calculateDaysBetweenDates(\"2023-01-01\", \"2024-01-01\"));\n        assertEquals(366, DaysBetweenDates.calculateDaysBetweenDates(\"2024-01-01\", \"2025-01-01\"));\n        assertEquals(0, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-15\"));\n        assertEquals(1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-15\", \"2023-03-16\"));\n        assertEquals(-1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-03-16\", \"2023-03-15\"));\n    }\n}", "problem": "对于java中time包的考察\n编写一个Java程序来计算两个日期之间的间隔。给定两个字符串格式的日期（\"2023-03-15\"和\"2023-04-14\"），计算它们之间的完整天数差。程序应能处理不同年份和闰年。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\n\nclass DaysBetweenDatesTest {\n    @Test\n    void testCalculateDaysBetweenDatesBoundary() {\n        assertEquals(0, DaysBetweenDates.calculateDaysBetweenDates(\"0001-01-01\", \"0001-01-01\"));\n        assertEquals(3652058, DaysBetweenDates.calculateDaysBetweenDates(\"0001-01-01\", \"9999-12-31\"));\n        assertEquals(-3652058, DaysBetweenDates.calculateDaysBetweenDates(\"9999-12-31\", \"0001-01-01\"));\n        assertEquals(1, DaysBetweenDates.calculateDaysBetweenDates(\"2023-02-28\", \"2023-03-01\"));\n        assertEquals(2, DaysBetweenDates.calculateDaysBetweenDates(\"2024-02-28\", \"2024-03-01\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\n/*\n对于java中time包的考察\n编写一个Java程序来计算两个日期之间的间隔。给定两个字符串格式的日期（\"2023-03-15\"和\"2023-04-14\"），计算它们之间的完整天数差。程序应能处理不同年份和闰年。\n*/\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n\n    public static long calculateDaysBetweenDates(String date1, String date2) {\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n        LocalDate startDate = LocalDate.parse(date1, formatter);\n        LocalDate endDate = LocalDate.parse(date2, formatter);\n\n        return ChronoUnit.DAYS.between(startDate, endDate);\n    }\n\n    public static void main(String[] args) {\n        String date1 = \"2023-03-15\";\n        String date2 = \"2023-04-14\";\n\n        long days = calculateDaysBetweenDates(date1, date2);\n        System.out.println(\"Days between dates: \" + days);\n    }\n}\n\n```", "classification": "后端开发"}
{"_id": 194, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n创建一个名为 GameItem 的类，包含属性：道具名称、类型、数量。分别是String, String, int类型。\n创建一个名为 Inventory 的类，用于管理游戏道具。它应该能够添加道具、删除道具、查找道具，列出道具。\n函数名分别为：addItem(GameItem item)，removeItem(String itemName)，findItem(String itemName)，listItems()\n在main函数中测试GameItem和Inventory类，比如先新建两个gameitem并添加到inventory里面，然后listItems()，然后去寻找其中一个item，使用findItem函数。随后移除一个gameitem，然后再次listItems()。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass q10Test {\n\n    @Test\n    public void testGameItemAndInventory() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Potion\", \"Health\", 5));\n\n        assertEquals(2, inventory.items.size());\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        assertNotNull(foundItem);\n        assertEquals(\"Potion\", foundItem.getName());\n\n        inventory.removeItem(\"Sword\");\n        assertEquals(1, inventory.items.size());\n    }\n}", "problem": "创建一个名为 GameItem 的类，包含属性：道具名称、类型、数量。分别是String, String, int类型。\n创建一个名为 Inventory 的类，用于管理游戏道具。它应该能够添加道具、删除道具、查找道具，列出道具。\n函数名分别为：addItem(GameItem item)，removeItem(String itemName)，findItem(String itemName)，listItems()\n在main函数中测试GameItem和Inventory类，比如先新建两个gameitem并添加到inventory里面，然后listItems()，然后去寻找其中一个item，使用findItem函数。随后移除一个gameitem，然后再次listItems()。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass q10Test {\n    @Test\n    public void testEmptyInventory() {\n        Inventory inventory = new Inventory();\n\n        assertEquals(0, inventory.items.size());\n\n        GameItem foundItem = inventory.findItem(\"Sword\");\n        assertNull(foundItem);\n    }\n\n    @Test\n    public void testRemoveNonExistentItem() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n\n        inventory.removeItem(\"Potion\");\n        assertEquals(1, inventory.items.size());\n    }\n\n    @Test\n    public void testFindNonExistentItem() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        assertNull(foundItem);\n    }\n\n    @Test\n    public void testAddMultipleSameItems() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n\n        assertEquals(2, inventory.items.size());\n    }\n\n    @Test\n    public void testRemoveMultipleSameItems() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n\n        inventory.removeItem(\"Sword\");\n        assertEquals(0, inventory.items.size());\n    }\n\n    @Test\n    public void testAddItemWithZeroQuantity() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 0));\n\n        assertEquals(1, inventory.items.size());\n    }\n\n    @Test\n    public void testAddItemWithNegativeQuantity() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", -1));\n\n        assertEquals(1, inventory.items.size());\n    }\n\n    @Test\n    public void testAddItemWithMaxIntQuantity() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", Integer.MAX_VALUE));\n\n        assertEquals(1, inventory.items.size());\n    }\n\n    @Test\n    public void testAddItemWithMinIntQuantity() {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", Integer.MIN_VALUE));\n\n        assertEquals(1, inventory.items.size());\n    }\n}", "setup_code": "", "reference_solution": "```java\n/*\n创建一个名为 GameItem 的类，包含属性：道具名称、类型、数量。分别是String, String, int类型。\n创建一个名为 Inventory 的类，用于管理游戏道具。它应该能够添加道具、删除道具、查找道具，列出道具。\n函数名分别为：addItem(GameItem item)，removeItem(String itemName)，findItem(String itemName)，listItems()\n在main函数中测试GameItem和Inventory类，比如先新建两个gameitem并添加到inventory里面，然后listItems()，然后去寻找其中一个item，使用findItem函数。随后移除一个gameitem，然后再次listItems()。\n*/\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass GameItem {\n    private String name;\n    private String type;\n    private int quantity;\n\n    public GameItem(String name, String type, int quantity) {\n        this.name = name;\n        this.type = type;\n        this.quantity = quantity;\n    }\n\n    // Getters and setters\n    public String getName() {\n        return name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public int getQuantity() {\n        return quantity;\n    }\n\n    public void setQuantity(int quantity) {\n        this.quantity = quantity;\n    }\n\n    @Override\n    public String toString() {\n        return \"GameItem{\" +\n                \"name='\" + name + '\\'' +\n                \", type='\" + type + '\\'' +\n                \", quantity=\" + quantity +\n                '}';\n    }\n}\n\nclass Inventory {\n    List<GameItem> items;\n\n    public Inventory() {\n        this.items = new ArrayList<>();\n    }\n\n    public void addItem(GameItem item) {\n        this.items.add(item);\n    }\n\n    public void removeItem(String itemName) {\n        this.items.removeIf(item -> item.getName().equals(itemName));\n    }\n\n    public GameItem findItem(String itemName) {\n        return this.items.stream()\n                .filter(item -> item.getName().equals(itemName))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public void listItems() {\n        for (GameItem item : items) {\n            System.out.println(item);\n        }\n    }\n}\n\npublic class q10 {\n    public static void main(String[] args) {\n        Inventory inventory = new Inventory();\n        inventory.addItem(new GameItem(\"Sword\", \"Weapon\", 1));\n        inventory.addItem(new GameItem(\"Potion\", \"Health\", 5));\n\n        System.out.println(\"Inventory after adding items:\");\n        inventory.listItems();\n\n        GameItem foundItem = inventory.findItem(\"Potion\");\n        if (foundItem != null) {\n            System.out.println(\"Found item: \" + foundItem);\n        }\n\n        inventory.removeItem(\"Sword\");\n        System.out.println(\"Inventory after removing the sword:\");\n        inventory.listItems();\n    }\n}\n\n\n```", "classification": "软件工程"}
{"_id": 195, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n商店由N个销售区组成，并且销售区由M个干货架组成，货架上面又须要放置P种货物。请你善用继承分别编写商店、销售区、货架和货物的实体类，并利用泛型随机生成货物。货物包含id、名字和价格三个属性。最后首先按照销售区域号排序，区域号相同的按照货架号排序，打印展示货物\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MaxLCMGCDTest {\n\n\n    @Test\n    public void testWithNEqualTo1() {\n        assertEquals(0, MaxLCMGCD.maxLCMMinusGCD(1));\n    }\n}", "problem": "商店由N个销售区组成，并且销售区由M个干货架组成，货架上面又须要放置P种货物。请你善用继承分别编写商店、销售区、货架和货物的实体类，并利用泛型随机生成货物。货物包含id、名字和价格三个属性。最后首先按照销售区域号排序，区域号相同的按照货架号排序，打印展示货物", "testcases": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class MaxLCMGCDTest {\n    @Test\n    public void testWithNEqualTo2() {\n        assertEquals(1, MaxLCMGCD.maxLCMMinusGCD(2));\n    }\n\n    @Test\n    public void testWithNEqualTo3() {\n        assertEquals(5, MaxLCMGCD.maxLCMMinusGCD(3));\n    }\n\n    @Test\n    public void testWithSmallN() {\n        assertEquals(11, MaxLCMGCD.maxLCMMinusGCD(4));\n    }\n\n    @Test\n    public void testWithMediumN() {\n        assertEquals(29, MaxLCMGCD.maxLCMMinusGCD(6));\n    }\n\n    @Test\n    public void testWithLargeN() {\n        long expected = MaxLCMGCD.lcm(1000, 999) - MaxLCMGCD.gcd(1000, 999);\n        assertEquals(expected, MaxLCMGCD.maxLCMMinusGCD(1000));\n    }\n\n    @Test\n    public void testWithVeryLargeN() {\n        long expected = MaxLCMGCD.lcm(10000, 9999) - MaxLCMGCD.gcd(10000, 9999);\n        assertEquals(expected, MaxLCMGCD.maxLCMMinusGCD(10000));\n    }\n\n    @Test\n    public void testNIsPrime() {\n        long expected = MaxLCMGCD.lcm(7, 6) - MaxLCMGCD.gcd(7, 6);\n        assertEquals(expected, MaxLCMGCD.maxLCMMinusGCD(7));\n    }\n\n    @Test\n    public void testNIsEven() {\n        long expected = MaxLCMGCD.lcm(10, 9) - MaxLCMGCD.gcd(10, 9);\n        assertEquals(expected, MaxLCMGCD.maxLCMMinusGCD(10));\n    }\n\n    @Test\n    public void testNIsOdd() {\n        long expected = MaxLCMGCD.lcm(9, 8) - MaxLCMGCD.gcd(9, 8);\n        assertEquals(expected, MaxLCMGCD.maxLCMMinusGCD(9));\n    }\n}\n", "setup_code": "", "reference_solution": "```java\n\npublic class MaxLCMGCD {\n\n    // 计算最大公约数（GCD）\n    public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    // 计算最小公倍数（LCM）\n    public static long lcm(int a, int b) {\n        return (long) a / gcd(a, b) * b;\n    }\n\n    // 找出最大的 lcm(a, b) - gcd(a, b)\n    public static long maxLCMMinusGCD(int n) {\n        if (n == 1) return 0;\n        int a = n;\n        int b = n - 1;\n        return lcm(a, b) - gcd(a, b);\n    }\n\n    public static void main(String[] args) {\n        int n = 10; // 示例输入\n        System.out.println(\"Maximum of lcm(a, b) - gcd(a, b) is: \" + maxLCMMinusGCD(n));\n    }\n}\n\n```", "classification": "算法和数据结构"}
{"_id": 196, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n模拟报文的发送端和接收端，在接收到发送端的传输报文后，进行哈夫曼编码压缩，形成编码后报文并发送出去，然后再接收端进行解码，还原内容并打印显示出报文内容\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass HuffmanTest {\n\n    @Test\n    void testEncodeAndDecode1() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"hello world\");\n        assertEquals(\"hello world\", huffman.recv());\n    }\n}", "problem": "模拟报文的发送端和接收端，在接收到发送端的传输报文后，进行哈夫曼编码压缩，形成编码后报文并发送出去，然后再接收端进行解码，还原内容并打印显示出报文内容", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.*;\n\nclass HuffmanTest {\n    @Test\n    void testEncodeAndDecode2() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"abcdefghijklmnopqrstuvwxyz\");\n        assertEquals(\"abcdefghijklmnopqrstuvwxyz\", huffman.recv());\n    }\n\n    @Test\n    void testEncodeAndDecode3() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        assertEquals(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", huffman.recv());\n    }\n\n    @Test\n    void testEncodeAndDecode4() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"1234567890\");\n        assertEquals(\"1234567890\", huffman.recv());\n    }\n\n    @Test\n    void testEncodeAndDecode5() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"Huffman coding is a data compression algorithm.\");\n        assertEquals(\"Huffman coding is a data compression algorithm.\", huffman.recv());\n    }\n\n    @Test\n    void testEncodeAndDecode6() {\n        Huffman huffman = new Huffman();\n        huffman.send(\" \");\n        assertEquals(\" \", huffman.recv());\n    }\n\n    @Test\n    void testEncodeAndDecode7() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"\");\n        assertEquals(\"\", huffman.recv());\n    }\n\n    @Test\n    void testEncodeAndDecode8() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"a\");\n        assertEquals(\"a\", huffman.recv());\n    }\n\n    @Test\n    void testEncodeAndDecode9() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"aa\");\n        assertEquals(\"aa\", huffman.recv());\n    }\n\n    @Test\n    void testEncodeAndDecode10() {\n        Huffman huffman = new Huffman();\n        huffman.send(\"aaa\");\n        assertEquals(\"aaa\", huffman.recv());\n    }\n}", "setup_code": "", "reference_solution": "```java\n/*\n模拟报文的发送端和接收端，在接收到发送端的传输报文后，进行哈夫曼编码压缩，形成编码后报文并发送出去，然后再接收端进行解码，还原内容并打印显示出报文内容\n*/\nimport java.util.*;\n\npublic class Huffman {\n    //内部类 二叉树节点\n    private static class TreeNode {\n        public TreeNode() { }\n        public TreeNode(Character ch, int val, int freq, TreeNode left, TreeNode right) {\n            this.ch = ch;\n            this.val = val;\n            this.freq = freq;\n            this.left = left;\n            this.right = right;\n        }\n        Character ch;\n        int val;\n        int freq;\n        TreeNode left;\n        TreeNode right;\n    }\n    static String encodeStr = \"\";\n    static Map<Character,String> encodeMap = null;\n\n    public static void main(String[] args) {\n        Scanner scan=new Scanner(System.in);\n        String s = scan.nextLine();\n        System.out.println(\"要发送的消息为：\"+s);\n\n        //开始发送内容\n        send(s);\n\n        System.out.println(\"编码表：\");\n        for(Map.Entry<Character,String> e:encodeMap.entrySet()){\n            System.out.println(e.getKey()+\":\"+e.getValue());\n        }\n        System.out.println(\"编码后：\"+encodeStr);\n\n        //接收方解码\n        String decodeStr = recv();\n        System.out.println(\"接收方解码后:\"+decodeStr);\n    }\n    public static  void send (String s){\n        Object[] encodeRes = encode(s);\n        encodeStr = (String)encodeRes[0];\n        encodeMap = (Map<Character, String>)encodeRes[1];\n    }\n    public static String recv(){\n        return decode(encodeStr,encodeMap);\n    }\n\n    //编码方法，返回Object[]，大小为2,Objec[0]为编码后的字符串，Object[1]为编码对应的码表\n    public static Object[] encode(String s){\n        Object[]res= new Object[2];\n        Map<Character,String> encodeMap = new HashMap<Character, String>();\n        TreeNode tree = constructTree(s);\n        findPath(tree, encodeMap, new StringBuilder());\n        findPath(tree, encodeMap, new StringBuilder());\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<s.length();i++){\n            String tmp = encodeMap.get(s.charAt(i));\n            sb.append(tmp);\n        }\n        res[0]=sb.toString();\n        res[1] = encodeMap;\n        return res;\n\n    }\n\n    /*\n     * 根据字符串建立二叉树\n     * @param s：要编码的源字符串\n     */\n    private static TreeNode constructTree(String s) {\n        if (s == null || s.equals(\"\")) {\n            return null;\n        }\n        //计算每个字母的词频，放到Map中\n        Map<Character, Integer> dataMap = new HashMap<Character, Integer>();\n        for (int i = 0; i < s.length(); i++) {\n            Character c = s.charAt(i);\n            if (dataMap.containsKey(c)) {\n                int count = dataMap.get(c);\n                dataMap.put(c, count + 1);\n            } else {\n                dataMap.put(c, 1);\n            }\n        }\n        //遍历dataMap,初始化二叉树节点，并将所有初始化后的节点放到nodeList中，并进行排序\n        LinkedList<TreeNode> nodeList = new LinkedList<TreeNode>();\n        for (Map.Entry<Character, Integer> entry : dataMap.entrySet()) {\n            Character ch = entry.getKey();\n            int freq = entry.getValue();\n            int val = 0;\n            TreeNode tmp = new TreeNode(ch,val,freq,null,null);\n            nodeList.add(tmp);\n        }\n        //对存放节点的链表进行排序，方便后续进行组合\n        Collections.sort(nodeList, new Comparator<TreeNode>() {\n            public int compare(TreeNode t1, TreeNode t2) {\n                return t1.freq-t2.freq;\n            }\n        });\n\n        //size==1,代表字符串只包含一种类型的字母\n        if(nodeList.size()==1){\n            TreeNode t = nodeList.get(0);\n            return new TreeNode(null,0,nodeList.get(0).freq,t,null);\n        }\n\n        //利用排序好的节点建立二叉树，root为初始化根节点\n        TreeNode root = null;\n        while(nodeList.size()>0){\n            //因为nodeList在前面已经排好序，所以直接取出前两个节点，他们的和肯定为最小\n            TreeNode t1 = nodeList.removeFirst();\n            TreeNode t2 = nodeList.removeFirst();\n            //左子树的val赋值为0，右子树的val赋值为1\n            t1.val = 0;\n            t2.val = 1;\n            //将取出的两个节点进行合并\n            if(nodeList.size()==0){\n                //此时代表所有节点合并完毕，返回结果\n                root = new TreeNode(null,0,t1.freq+t2.freq,t1,t2);\n            }else {\n                //此时代表还有可以合并的节点\n                TreeNode tmp = new TreeNode(null,0,t1.freq+t2.freq,t1,t2);\n\n                //t1、t2合并后，需要将得到的新节点加入到原链表中，继续与其他节点合并，\n                //此时需要保证原链表的有序性，需要进行排序\n                if(tmp.freq>nodeList.getLast().freq){\n                    nodeList.addLast(tmp);\n                }else {\n                    for(int i=0;i<nodeList.size();i++){\n                        int tmpFreq = tmp.freq;\n                        if(tmpFreq<= nodeList.get(i).freq){\n                            nodeList.add(i,tmp);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        //返回建立好的二叉树根节点\n        return root;\n    }\n\n    //对已经建立好的二叉树进行遍历，得到每个字符的编码\n    private static void findPath(TreeNode root, Map<Character,String> res, StringBuilder path) {\n        if (root == null){\n            return;\n        }\n        if (root.left == null && root.right == null) {\n            path.append(root.val);\n            res.put(root.ch,path.substring(1));\n            path.deleteCharAt(path.length() - 1);\n            return;\n        }\n        path.append(root.val);\n        if (root.left != null) findPath(root.left, res, path);\n        if (root.right != null) findPath(root.right, res, path);\n        path.deleteCharAt(path.length() - 1);\n    }\n\n    //对字符串进行解码，解码时需要编码码表\n    public static String decode(String encodeStr,Map<Character,String> encodeMap){\n        StringBuilder decodeStr = new StringBuilder();\n        while(encodeStr.length()>0){\n            for(Map.Entry<Character,String> e: encodeMap.entrySet()){\n                String charEncodeStr = e.getValue();\n                if(encodeStr.startsWith(charEncodeStr)){\n                    decodeStr.append(e.getKey());\n                    encodeStr = encodeStr.substring(charEncodeStr.length());\n                    break;\n                }\n            }\n        }\n        return decodeStr.toString();\n    }\n\n}\n\n\n```", "classification": "网络编程"}
{"_id": 197, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n编写一个 Java 函数，使用正则表达式来验证一个字符串是否是有效的电子邮件地址。电子邮件地址的一般格式为 username@domain.com。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass ValidEmailTest {\n\n    @Test\n    void testIsValidEmail1() {\n        assertTrue(ValidEmail.isValidEmail(\"example@example.com\"));\n    }\n}", "problem": "编写一个 Java 函数，使用正则表达式来验证一个字符串是否是有效的电子邮件地址。电子邮件地址的一般格式为 username@domain.com。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass ValidEmailTest {\n    @Test\n    void testIsValidEmail2() {\n        assertFalse(ValidEmail.isValidEmail(\"example@.com\"));\n    }\n\n    @Test\n    void testIsValidEmail3() {\n        assertFalse(ValidEmail.isValidEmail(\"example@com\"));\n    }\n\n    @Test\n    void testIsValidEmail4() {\n        assertTrue(ValidEmail.isValidEmail(\"example.example@example.com\"));\n    }\n\n    @Test\n    void testIsValidEmail5() {\n        assertFalse(ValidEmail.isValidEmail(\"example.example@.com\"));\n    }\n\n    @Test\n    void testIsValidEmail6() {\n        assertFalse(ValidEmail.isValidEmail(\"example.example@com\"));\n    }\n\n    @Test\n    void testIsValidEmail7() {\n        assertTrue(ValidEmail.isValidEmail(\"example_example@example.com\"));\n    }\n\n    @Test\n    void testIsValidEmail8() {\n        assertFalse(ValidEmail.isValidEmail(\"example_example@.com\"));\n    }\n\n    @Test\n    void testIsValidEmail9() {\n        assertFalse(ValidEmail.isValidEmail(\"example_example@com\"));\n    }\n\n    @Test\n    void testIsValidEmail10() {\n        assertTrue(ValidEmail.isValidEmail(\"example-example@example.com\"));\n    }\n}", "setup_code": "", "reference_solution": "```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ValidEmail {\n    public static boolean isValidEmail(String email) {\n        String emailRegex = \"^[a-zA-Z0-9_+&*-]+(?:\\\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,7}$\";\n        Pattern pattern = Pattern.compile(emailRegex);\n        Matcher matcher = pattern.matcher(email);\n        return matcher.matches();\n    }\n\n    public static void main(String[] args) {\n        String email = \"example@example.com\";\n        System.out.println(\"Is the email valid? \" + isValidEmail(email));\n    }\n}\n\n\n```", "classification": "后端开发"}
{"_id": 198, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n异常检测的问题：考察对Exception的重写。\n创建一个简单的银行账户类 BankAccount，其中包含一个处理取款操作的方法。这个方法应该能够检测和抛出异常，比如当账户余额不足时。\n\n创建一个名为BankAccount的类，包含属性：账户余额。\n在BankAccount类中，实现一个withdraw方法，该方法接受一个取款金额参数。\n如果取款金额大于账户余额，方法应抛出一个自定义的异常 InsufficientFundsException。\n在 main 函数中，创建一个 BankAccount 对象，先往里面存500，然后取600，看看是否会调用到实现好的InsufficientFundsException并打印其报错信息。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass q13Test {\n\n        @Test\n        void testWithdraw1() {\n            BankAccount account = new BankAccount(500.0);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(600.0));\n        }\n}", "problem": "异常检测的问题：考察对Exception的重写。\n创建一个简单的银行账户类 BankAccount，其中包含一个处理取款操作的方法。这个方法应该能够检测和抛出异常，比如当账户余额不足时。\n\n创建一个名为BankAccount的类，包含属性：账户余额。\n在BankAccount类中，实现一个withdraw方法，该方法接受一个取款金额参数。\n如果取款金额大于账户余额，方法应抛出一个自定义的异常 InsufficientFundsException。\n在 main 函数中，创建一个 BankAccount 对象，先往里面存500，然后取600，看看是否会调用到实现好的InsufficientFundsException并打印其报错信息。", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass q13Test {\n    @Test\n        void testWithdraw2() {\n            BankAccount account = new BankAccount(500.0);\n            assertDoesNotThrow(() -> account.withdraw(400.0));\n        }\n\n        @Test\n        void testWithdraw3() {\n            BankAccount account = new BankAccount(1000.0);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(1500.0));\n        }\n\n        @Test\n        void testWithdraw4() {\n            BankAccount account = new BankAccount(1000.0);\n            assertDoesNotThrow(() -> account.withdraw(1000.0));\n        }\n\n        @Test\n        void testWithdraw5() {\n            BankAccount account = new BankAccount(0.0);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(1.0));\n        }\n\n        @Test\n        void testWithdraw6() {\n            BankAccount account = new BankAccount(0.0);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(0.1));\n        }\n\n        // boundary test cases\n        @Test\n        void testWithdraw7() {\n            BankAccount account = new BankAccount(Double.MAX_VALUE);\n            assertDoesNotThrow(() -> account.withdraw(Double.MAX_VALUE));\n        }\n        \n\n        @Test\n        void testWithdraw9() {\n            BankAccount account = new BankAccount(Double.MIN_VALUE);\n            assertDoesNotThrow(() -> account.withdraw(Double.MIN_VALUE));\n        }\n\n        @Test\n        void testWithdraw10() {\n            BankAccount account = new BankAccount(Double.MIN_VALUE);\n            assertThrows(InsufficientFundsException.class, () -> account.withdraw(Double.MIN_VALUE + 1));\n        }\n    }", "setup_code": "", "reference_solution": "```java\n/*\n异常检测的问题：考察对Exception的重写。\n创建一个简单的银行账户类 BankAccount，其中包含一个处理取款操作的方法。这个方法应该能够检测和抛出异常，比如当账户余额不足时。\n\n创建一个名为BankAccount的类，包含属性：账户余额。\n在BankAccount类中，实现一个withdraw方法，该方法接受一个取款金额参数。\n如果取款金额大于账户余额，方法应抛出一个自定义的异常 InsufficientFundsException。\n在 main 函数中，创建一个 BankAccount 对象，先往里面存500，然后取600，看看是否会调用到实现好的InsufficientFundsException并打印其报错信息。\n*/\nclass InsufficientFundsException extends Exception {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}\n\nclass BankAccount {\n    private double balance;\n\n    public BankAccount(double balance) {\n        this.balance = balance;\n    }\n\n    public void withdraw(double amount) throws InsufficientFundsException {\n        if (amount > balance) {\n            throw new InsufficientFundsException(\"Insufficient funds for withdrawal\");\n        }\n        balance -= amount;\n        System.out.println(\"Withdrawal successful. Remaining balance: \" + balance);\n    }\n}\n\npublic class q13 {\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount(500.0);\n\n        try {\n            account.withdraw(600.0);\n        } catch (InsufficientFundsException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n```", "classification": "软件工程"}
{"_id": 199, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n请使用StringBuilder和StringBuffer，创建一个简单的Markdown解析器，它能够将特定的Markdown语法转换为HTML。你的任务是处理以下Markdown特性：\n\n# 开头的行转换为 <h1> 标签。\n## 开头的行转换为 <h2> 标签。\n* 开头的行（后跟空格）转换为 <li> 标签（列表项）。\n文本行（不符合上述情况）转换为 <p> 标签。\n注意，Markdown语法规定，每个标记（如#，##，*）后必须紧跟一个空格。\n\n输入：\n# Header 1\nThis is a paragraph.\n## Header 2\n* List item 1\n* List item 2\n\n输出：\n<h1>Header 1</h1>\n<p>This is a paragraph.</p>\n<h2>Header 2</h2>\n<ul>\n<li>List item 1</li>\n<li>List item 2</li>\n</ul>\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\nclass MarkdownToHTMLTest {\n\n    @Test\n    void testParseMarkdown1() {\n        String markdown = \"# Header 1\\nThis is a paragraph.\\n## Header 2\\n* List item 1\\n* List item 2\";\n        String expected = \"<h1>Header 1</h1>\\n<p>This is a paragraph.</p>\\n<h2>Header 2</h2>\\n<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n}", "problem": "请使用StringBuilder和StringBuffer，创建一个简单的Markdown解析器，它能够将特定的Markdown语法转换为HTML。你的任务是处理以下Markdown特性：\n\n# 开头的行转换为 <h1> 标签。\n## 开头的行转换为 <h2> 标签。\n* 开头的行（后跟空格）转换为 <li> 标签（列表项）。\n文本行（不符合上述情况）转换为 <p> 标签。\n注意，Markdown语法规定，每个标记（如#，##，*）后必须紧跟一个空格。\n\n输入：\n# Header 1\nThis is a paragraph.\n## Header 2\n* List item 1\n* List item 2\n\n输出：\n<h1>Header 1</h1>\n<p>This is a paragraph.</p>\n<h2>Header 2</h2>\n<ul>\n<li>List item 1</li>\n<li>List item 2</li>\n</ul>", "testcases": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.StringTokenizer;\n\nclass MarkdownToHTMLTest {\n    @Test\n    void testParseMarkdown2() {\n        String markdown = \"This is a paragraph.\";\n        String expected = \"<p>This is a paragraph.</p>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n\n    @Test\n    void testParseMarkdown3() {\n        String markdown = \"# Header 1\";\n        String expected = \"<h1>Header 1</h1>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n\n    @Test\n    void testParseMarkdown4() {\n        String markdown = \"## Header 2\";\n        String expected = \"<h2>Header 2</h2>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n\n    @Test\n    void testParseMarkdown5() {\n        String markdown = \"* List item 1\";\n        String expected = \"<ul>\\n<li>List item 1</li>\\n</ul>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n\n    @Test\n    void testParseMarkdown6() {\n        String markdown = \"* List item 1\\n* List item 2\";\n        String expected = \"<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n\n    @Test\n    void testParseMarkdown7() {\n        String markdown = \"\";\n        String expected = \"\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n\n    @Test\n    void testParseMarkdown8() {\n        String markdown = \"# Header 1\\n## Header 2\\n* List item 1\\n* List item 2\\nThis is a paragraph.\";\n        String expected = \"<h1>Header 1</h1>\\n<h2>Header 2</h2>\\n<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n<p>This is a paragraph.</p>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n\n    @Test\n    void testParseMarkdown9() {\n        String markdown = \"# Header 1\\nThis is a paragraph.\\n## Header 2\\n* List item 1\\n* List item 2\\n# Header 3\";\n        String expected = \"<h1>Header 1</h1>\\n<p>This is a paragraph.</p>\\n<h2>Header 2</h2>\\n<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n<h1>Header 3</h1>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n\n    @Test\n    void testParseMarkdown10() {\n        String markdown = \"# Header 1\\nThis is a paragraph.\\n## Header 2\\n* List item 1\\n* List item 2\\nThis is another paragraph.\";\n        String expected = \"<h1>Header 1</h1>\\n<p>This is a paragraph.</p>\\n<h2>Header 2</h2>\\n<ul>\\n<li>List item 1</li>\\n<li>List item 2</li>\\n</ul>\\n<p>This is another paragraph.</p>\\n\";\n        assertEquals(expected, MarkdownToHTML.parseMarkdown(markdown));\n    }\n}", "setup_code": "", "reference_solution": "```java\n/*\n请使用StringBuilder和StringBuffer，创建一个简单的Markdown解析器，它能够将特定的Markdown语法转换为HTML。你的任务是处理以下Markdown特性：\n\n# 开头的行转换为 <h1> 标签。\n## 开头的行转换为 <h2> 标签。\n* 开头的行（后跟空格）转换为 <li> 标签（列表项）。\n文本行（不符合上述情况）转换为 <p> 标签。\n注意，Markdown语法规定，每个标记（如#，##，*）后必须紧跟一个空格。\n\n输入：\n# Header 1\nThis is a paragraph.\n## Header 2\n* List item 1\n* List item 2\n\n输出：\n<h1>Header 1</h1>\n<p>This is a paragraph.</p>\n<h2>Header 2</h2>\n<ul>\n<li>List item 1</li>\n<li>List item 2</li>\n</ul>\n*/\nimport java.util.StringTokenizer;\n\npublic class MarkdownToHTML {\n    public static String parseMarkdown(String markdown) {\n        StringBuilder html = new StringBuilder();\n        StringTokenizer tokenizer = new StringTokenizer(markdown, \"\\n\");\n        boolean processingList = false;\n\n        while (tokenizer.hasMoreTokens()) {\n            String line = tokenizer.nextToken();\n\n            if (line.startsWith(\"# \")) {\n                if (processingList) {\n                    html.append(\"</ul>\\n\");\n                    processingList = false;\n                }\n                html.append(\"<h1>\").append(line.substring(2)).append(\"</h1>\\n\");\n            }\n            else if (line.startsWith(\"## \")) {\n                if (processingList) {\n                    html.append(\"</ul>\\n\");\n                    processingList = false;\n                }\n                html.append(\"<h2>\").append(line.substring(3)).append(\"</h2>\\n\");\n            }\n            else if (line.startsWith(\"* \")) {\n                if (!processingList) {\n                    html.append(\"<ul>\\n\");\n                    processingList = true;\n                }\n                html.append(\"<li>\").append(line.substring(2)).append(\"</li>\\n\");\n            }\n            else {\n                if (processingList) {\n                    html.append(\"</ul>\\n\");\n                    processingList = false;\n                }\n                html.append(\"<p>\").append(line).append(\"</p>\\n\");\n            }\n        }\n\n        // Close the ul tag at the end of the document if necessary\n        if (processingList) {\n            html.append(\"</ul>\\n\");\n            processingList = false;\n        }\n\n        return html.toString();\n    }\n\n    public static void main(String[] args) {\n        String markdown = \"# Header 1\\nThis is a paragraph.\\n## Header 2\\n* List item 1\\n* List item 2\";\n        String html = parseMarkdown(markdown);\n        System.out.println(html);\n    }\n}\n```", "classification": "前端开发"}
{"_id": 200, "prompt": "你的任务是生成java代码来解决以下问题，生成的代码必须位于代码块```java和```之间，最多只允许有一个代码块：\n实现自己定制的MyString类，除支持string类的所有操作外\n支持trim( )功能，可以删除字符串两端的所有空格\n支持split(string separator, int N=-1)功能，可以按照原字符串中的子字符串separator将原字符串切分成多个字符串，最多切分N次, N默认值为-1, 即不限制切分次数。例如, s=”hello, ann, how are you doing?”，s.split(“,”)将s切分成3个子字符串”hello”，”ann”，”how are you doing”，s.split(“,”, 1)将s切分成2个子字符串”hello”，”ann, how are you doing”。\n\n生成代码时你需要遵循以下测试用例中测试函数体中的函数名或类名，但生成的代码中不允许包含测例：\npublic class MyStringTest {\n    @Test\n    public void testTrim() {\n        MyString s1 = new MyString(\"  hello  \");\n        assertEquals(\"hello\", s1.trim(), \"Trim should remove leading and trailing spaces.\");\n        MyString s2 = new MyString(\"one,two,three\");\n        assertArrayEquals(new String[]{\"one\", \"two,three\"}, s2.split(\",\", 1), \"Split should work with limit of 1.\");\n    }\n}", "problem": "实现自己定制的MyString类，除支持string类的所有操作外\n支持trim( )功能，可以删除字符串两端的所有空格\n支持split(string separator, int N=-1)功能，可以按照原字符串中的子字符串separator将原字符串切分成多个字符串，最多切分N次, N默认值为-1, 即不限制切分次数。例如, s=”hello, ann, how are you doing?”，s.split(“,”)将s切分成3个子字符串”hello”，”ann”，”how are you doing”，s.split(“,”, 1)将s切分成2个子字符串”hello”，”ann, how are you doing”。", "testcases": "import static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MyStringTest {\n    @Test\n    public void testTrimNoSpaces() {\n        MyString s = new MyString(\"hello\");\n        assertEquals(\"hello\", s.trim(), \"Trim should not change string without spaces.\");\n    }\n\n    @Test\n    public void testSplitUnlimited() {\n        MyString s = new MyString(\"one,two,three\");\n        assertArrayEquals(new String[]{\"one\", \"two\", \"three\"}, s.split(\",\", -1), \"Split should work without limit.\");\n    }\n\n    @Test\n    public void testSplitNone() {\n        MyString s = new MyString(\"one two three\");\n        assertArrayEquals(new String[]{\"one two three\"}, s.split(\",\", -1), \"Split should return original string if separator not found.\");\n    }\n\n    @Test\n    public void testSplitEmptyString() {\n        MyString s = new MyString(\"\");\n        assertArrayEquals(new String[]{\"\"}, s.split(\",\", -1), \"Split on empty string should return array with empty string.\");\n    }\n\n    @Test\n    public void testSplitSeparatorAtEnd() {\n        MyString s = new MyString(\"hello,\");\n        assertArrayEquals(new String[]{\"hello\"}, s.split(\",\", -1), \"Split should not return empty string at end.\");\n    }\n\n    @Test\n    public void testSplitLimitZero() {\n        MyString s = new MyString(\"one,two,three\");\n        assertArrayEquals(new String[]{\"one,two,three\"}, s.split(\",\", 0), \"Split with limit 0 should return original string.\");\n    }\n\n    @Test\n    public void testLength() {\n        MyString s = new MyString(\"hello\");\n        assertEquals(5, s.length(), \"Length should return correct string length.\");\n    }\n\n    @Test\n    public void testGetValue() {\n        MyString s = new MyString(\"test\");\n        assertEquals(\"test\", s.getValue(), \"getValue should return original string.\");\n    }\n}\n", "setup_code": "", "reference_solution": "```java\npublic class MyString {\n    private String value;\n\n    public MyString(String value) {\n        this.value = value;\n    }\n\n    public String trim() {\n        return value.trim();\n    }\n\n    public String[] split(String separator, int N) {\n        // 检查N的值，如果N=-1，则不限制切分次数\n        if (N == -1) {\n            return value.split(separator);\n        } else {\n            return value.split(separator, N + 1);\n        }\n    }\n\n    // 为了支持String类的其他所有操作，可以提供一个方法获取内部的String\n    public String getValue() {\n        return value;\n    }\n\n    // 示例：其他String类的方法代理实现，例如length()\n    public int length() {\n        return value.length();\n    }\n\n}\n\n// 使用示例\nclass TestMyString {\n    public static void main(String[] args) {\n        MyString s = new MyString(\"  hello, ann, how are you doing?  \");\n        System.out.println(\"Trimmed string: '\" + s.trim() + \"'\");\n\n        MyString s2 = new MyString(\"hello, ann, how are you doing?\");\n        String[] splitUnlimited = s2.split(\",\", -1);\n        System.out.println(\"Split without limit:\");\n        for (String str : splitUnlimited) {\n            System.out.println(\"'\" + str.trim() + \"'\");\n        }\n\n        String[] splitOnce = s2.split(\",\", 1);\n        System.out.println(\"Split once:\");\n        for (String str : splitOnce) {\n            System.out.println(\"'\" + str.trim() + \"'\");\n        }\n    }\n}\n```", "classification": "Software Engineering"}
