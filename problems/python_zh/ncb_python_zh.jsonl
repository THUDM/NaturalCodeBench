{"_id": 131, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n创建一个名为`word_count`的函数，该函数接受一个文件路径作为参数，读取文件内容，并统计文件中每个单词出现的次数。函数应返回一个字典，其中键是单词，值是该单词在文件中出现的次数。要求忽略单词的大小写，并移除标点符号。最后，按照单词出现的次数降序排列字典项。如果有多个单词出现次数相同，按照字母顺序升序排列。函数不需要处理文件不存在的情况。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testword_count:\n    def test_word_count_basic_file(self, capfd, tmp_path):\n        file_path = tmp_path / 'test_basic.txt'\n        with open(file_path, 'w', encoding='utf-8') as file:\n            file.write(\"This is a basic test file with some common words.\")\n        word_count(file_path)\n        captured = capfd.readouterr()\n        assert \"'this': 1\\n'is': 1\\n'a': 1\\n'basic': 1\\n'test': 1\\n'file': 1\\n'with': 1\\n'some': 1\\n'common': 1\\n'words': 1\\n\" in captured.out\n\n\n", "problem": "创建一个名为`word_count`的函数，该函数接受一个文件路径作为参数，读取文件内容，并统计文件中每个单词出现的次数。函数应返回一个字典，其中键是单词，值是该单词在文件中出现的次数。要求忽略单词的大小写，并移除标点符号。最后，按照单词出现的次数降序排列字典项。如果有多个单词出现次数相同，按照字母顺序升序排列。函数不需要处理文件不存在的情况。", "testcases": "import string\nfrom collections import Counter\n\n\nclass Testword_count:\n    def test_word_count_case_sensitive_file(self, capfd, tmp_path):\n        file_path = tmp_path / 'test_case_sensitive.txt'\n        with open(file_path, 'w', encoding='utf-8') as file:\n            file.write(\"Case case CASE\")\n        word_count(file_path)\n        captured = capfd.readouterr()\n        assert \"'case': 3\" in captured.out\n\n\n    def test_word_count_punctuation_file(self, capfd, tmp_path):\n        file_path = tmp_path / 'test_punctuation.txt'\n        with open(file_path, 'w', encoding='utf-8') as file:\n            file.write(\"This sentence has some punctuation, like commas and periods.\")\n        word_count(file_path)\n        captured = capfd.readouterr()\n        assert \"'this': 1\\n'sentence': 1\\n'has': 1\\n'some': 1\\n'punctuation': 1\\n'like': 1\\n'commas': 1\\n'and': 1\\n'periods': 1\\n\" in captured.out\n\n\n    def test_word_count_same_word_file(self, capfd, tmp_path):\n        file_path = tmp_path / 'test_same_word_multiple_times.txt'\n        with open(file_path, 'w', encoding='utf-8') as file:\n            file.write(\"word word word word word\")\n        word_count(file_path)\n        captured = capfd.readouterr()\n        assert \"'word': 5\" in captured.out\n\n    def test_word_count_different_words_file(self, capfd, tmp_path):\n        file_path = tmp_path / 'test_different_words_same_count.txt'\n        with open(file_path, 'w', encoding='utf-8') as file:\n            file.write(\"apple banana orange\")\n        word_count(file_path)\n        captured = capfd.readouterr()\n        assert \"'apple': 1\\n'banana': 1\\n'orange': 1\\n\" in captured.out\n\n    def test_word_count_nonexistent_file(self, capfd, tmp_path):\n        file_path = tmp_path / 'nonexistent_file.txt'\n        word_count(file_path)\n        captured = capfd.readouterr()\n        assert \"Error: File\" in captured.out\n\n    def test_word_count_empty_file(self, capfd, tmp_path):\n        file_path = tmp_path / 'test_empty_file.txt'\n        open(file_path, 'w', encoding='utf-8').close()  # 创建一个空文件\n        word_count(file_path)\n        captured = capfd.readouterr()\n        assert captured.out.strip() == \"\"  # 期望输出为空字符串\n\n", "setup_code": "", "reference_solution": "```python\nimport string\nfrom collections import Counter\n\n\ndef word_count(file_path):\n    try:\n        # 读取文件内容\n        with open(file_path, 'r', encoding='utf-8') as file:\n            content = file.read()\n\n        # 移除标点符号并转换为小写\n        translator = str.maketrans(\"\", \"\", string.punctuation)\n        content = content.translate(translator).lower()\n\n        # 使用 Counter 统计单词出现次数\n        words = content.split()\n        word_counter = Counter(words)\n\n        # 按照出现次数降序排列\n        sorted_word_count = sorted(word_counter.items(), key=lambda x: x[1], reverse=True)\n\n        for word, count in sorted_word_count:\n            print(f\"'{word}': {count}\")\n\n    except FileNotFoundError:\n        print(f\"Error: File '{file_path}' not found.\")\n```", "classification": "算法和数据结构"}
{"_id": 132, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n定义一个名为 remove_html_tags 的函数，用于从输入的字符串中移除 HTML 标签、注释和文档类型声明。以下是对程序功能和每个步骤的描述：\n\nremove_html_tags 函数：\n\n用途：移除输入字符串中的 HTML 标签、注释和文档类型声明。\n参数：\ns：输入的字符串。\n返回值：\n处理后的字符串，其中移除 HTML 标签、注释和文档类型声明。\n主要过程：\n\n首先，检查输入是否为字符串，如果不是则抛出 ValueError。\n如果输入字符串为空，直接返回空字符串。\n定义三个正则表达式模式：\ntag_pattern：用于匹配 HTML 标签。\ncomment_pattern：用于匹配 HTML 注释。\ndoctype_pattern：用于匹配文档类型声明。\n使用 re.sub 方法，分别移除 HTML 注释、文档类型声明和 HTML 标签。\n返回处理后的字符串，经过处理后的字符串已移除 HTML 注释、文档类型声明和 HTML 标签，同时去除字符串两端的空白。\n该程序通过使用正则表达式模式，对输入字符串进行多次替换操作，从而实现移除 HTML 注释、文档类型声明和 HTML 标签的功能。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testremove_html_tags:\n    def test_basic_tags(self):\n        html_string = \"<p>Hello, <strong>world!</strong></p>\"\n        assert remove_html_tags(html_string) == \"Hello, world!\"\n\n", "problem": "定义一个名为 remove_html_tags 的函数，用于从输入的字符串中移除 HTML 标签、注释和文档类型声明。以下是对程序功能和每个步骤的描述：\n\nremove_html_tags 函数：\n\n用途：移除输入字符串中的 HTML 标签、注释和文档类型声明。\n参数：\ns：输入的字符串。\n返回值：\n处理后的字符串，其中移除 HTML 标签、注释和文档类型声明。\n主要过程：\n\n首先，检查输入是否为字符串，如果不是则抛出 ValueError。\n如果输入字符串为空，直接返回空字符串。\n定义三个正则表达式模式：\ntag_pattern：用于匹配 HTML 标签。\ncomment_pattern：用于匹配 HTML 注释。\ndoctype_pattern：用于匹配文档类型声明。\n使用 re.sub 方法，分别移除 HTML 注释、文档类型声明和 HTML 标签。\n返回处理后的字符串，经过处理后的字符串已移除 HTML 注释、文档类型声明和 HTML 标签，同时去除字符串两端的空白。\n该程序通过使用正则表达式模式，对输入字符串进行多次替换操作，从而实现移除 HTML 注释、文档类型声明和 HTML 标签的功能。", "testcases": "import re\n\n\nclass Testremove_html_tags:\n    def test_multiple_tags(self):\n        html_string = \"<h1>Title</h1><p>Paragraph</p>\"\n        assert remove_html_tags(html_string) == \"TitleParagraph\"\n\n    def test_special_characters(self):\n        html_string = '<a href=\"https://example.com\">Click here</a>'\n        assert remove_html_tags(html_string) == \"Click here\"\n\n    def test_comments(self):\n        html_string = \"<p>Hello <!-- Comment -->world!</p>\"\n        assert remove_html_tags(html_string) == \"Hello world!\"\n\n    def test_empty_tags(self):\n        html_string = \"<br/>\"\n        assert remove_html_tags(html_string) == \"\"\n\n    def test_doctype_declaration(self):\n        html_string = \"<!DOCTYPE html><html><body>Hello, world!</body></html>\"\n        assert remove_html_tags(html_string) == \"Hello, world!\"\n\n    def test_empty_string(self):\n        html_string = \"\"\n        assert remove_html_tags(html_string) == \"\"\n\n    def test_nonstring_input(self):\n        invalid_input = \"123\"\n        assert remove_html_tags(invalid_input) == \"123\"\n", "setup_code": "", "reference_solution": "```python\nimport re\n\n\ndef remove_html_tags(s: str) -> str:\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    if not s:\n        return \"\"\n\n    # 定义新的正则表达式模式\n    tag_pattern = r\"<[^>]*>\"\n    comment_pattern = r\"<!--.*?-->\"\n    doctype_pattern = r\"<!DOCTYPE[^>]*>\"\n\n    # 移除 HTML 注释和 DOCTYPE\n    s = re.sub(comment_pattern, \"\", s)\n    s = re.sub(doctype_pattern, \"\", s)\n\n    # 移除标签\n    s = re.sub(tag_pattern, \"\", s)\n\n    # 返回处理后的字符串\n    return s.strip()\n\n\n\n```", "classification": "前端开发"}
{"_id": 133, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，\"实现简易日程管理器：Python类实现事件添加、查看和删除功能\"\n定义一个名为 Schedule 的类，实现简单的日程管理系统。以下是对该代码的描述：\n\nSchedule 类：\n\n用途：表示一个日程管理系统，能够添加、查看和删除事件。\n属性：\nevents：字典，用于存储事件信息，键为事件日期，值为该日期下的事件列表。\n主要方法：\n\n__init__(self)：\n\n初始化方法，创建一个空的事件字典。\nadd_event(self, event_name, event_date)：\n\n添加事件的方法，接收事件名称和日期，将事件添加到相应日期的事件列表中。\n如果日期已存在，则将事件添加到现有列表中，否则创建一个新的列表。\nview_events(self)：\n\n查看所有事件的方法，按日期打印事件列表。\n使用 strftime 方法将日期格式化为\"YYYY-MM-DD HH:MM\"的形式。\nremove_event(self, event_name, event_date)：\n\n删除事件的方法，接收事件名称和日期，从相应日期的事件列表中删除指定事件。\n如果删除后列表为空，同时删除该日期的条目。\n如果未找到指定事件，则输出\"未找到事件'{event_name}'\"\n主要过程：\n\n使用 datetime 模块的 strftime 方法对日期进行格式化。\n添加事件时，检查日期是否已存在，如果存在则追加，否则创建新的日期条目。\n查看事件时，按日期遍历字典，打印每个日期下的事件列表。\n删除事件时，检查指定日期下是否有该事件，如果有则删除，同时检查列表是否为空，若为空则删除该日期的条目。\n该类提供了一种简单的方式来管理日程安排，用户可以添加、查看和删除事件。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestSchedule:\n    def test_add_event(self, schedule):\n        # 添加事件\n        event_date = datetime(2023, 12, 20, 18, 0)\n        schedule.add_event(\"生日聚会\", event_date)\n\n        # 断言事件是否添加成功\n        assert event_date in schedule.events\n        assert \"生日聚会\" in schedule.events[event_date]\n\n", "problem": "编写一个程序，\"实现简易日程管理器：Python类实现事件添加、查看和删除功能\"\n定义一个名为 Schedule 的类，实现简单的日程管理系统。以下是对该代码的描述：\n\nSchedule 类：\n\n用途：表示一个日程管理系统，能够添加、查看和删除事件。\n属性：\nevents：字典，用于存储事件信息，键为事件日期，值为该日期下的事件列表。\n主要方法：\n\n__init__(self)：\n\n初始化方法，创建一个空的事件字典。\nadd_event(self, event_name, event_date)：\n\n添加事件的方法，接收事件名称和日期，将事件添加到相应日期的事件列表中。\n如果日期已存在，则将事件添加到现有列表中，否则创建一个新的列表。\nview_events(self)：\n\n查看所有事件的方法，按日期打印事件列表。\n使用 strftime 方法将日期格式化为\"YYYY-MM-DD HH:MM\"的形式。\nremove_event(self, event_name, event_date)：\n\n删除事件的方法，接收事件名称和日期，从相应日期的事件列表中删除指定事件。\n如果删除后列表为空，同时删除该日期的条目。\n如果未找到指定事件，则输出\"未找到事件'{event_name}'\"\n主要过程：\n\n使用 datetime 模块的 strftime 方法对日期进行格式化。\n添加事件时，检查日期是否已存在，如果存在则追加，否则创建新的日期条目。\n查看事件时，按日期遍历字典，打印每个日期下的事件列表。\n删除事件时，检查指定日期下是否有该事件，如果有则删除，同时检查列表是否为空，若为空则删除该日期的条目。\n该类提供了一种简单的方式来管理日程安排，用户可以添加、查看和删除事件。", "testcases": "from datetime import datetime\n\n\nclass TestSchedule:\n    @pytest.fixture\n    def schedule(self):\n        return Schedule()\n\n    def test_add_event(self, schedule):\n        # 添加事件\n        event_date = datetime(2023, 12, 20, 18, 0)\n        schedule.add_event(\"生日聚会\", event_date)\n\n        # 断言事件是否添加成功\n        assert event_date in schedule.events\n        assert \"生日聚会\" in schedule.events[event_date]\n\n    def test_add_duplicate_event(self, schedule):\n        # 添加重复的事件\n        event_date = datetime(2023, 12, 20, 18, 0)\n        schedule.add_event(\"生日聚会\", event_date)\n        schedule.add_event(\"生日聚会\", event_date)\n\n        # 断言只添加了一个事件\n        assert len(schedule.events[event_date]) == 2\n\n    def test_view_events(self, schedule, capsys):\n        # 添加事件\n        schedule.add_event(\"生日聚会\", datetime(2023, 12, 20, 18, 0))\n        schedule.add_event(\"项目截止日期\", datetime(2023, 12, 25, 23, 59))\n        schedule.add_event(\"面试\", datetime(2024, 1, 5, 14, 30))\n\n        # 查看事件\n        schedule.view_events()\n        captured = capsys.readouterr()\n\n        # 断言输出是否正确\n        assert \"2023-12-20 18:00:\\n- 生日聚会\\n\\n\" in captured.out\n        assert \"2023-12-25 23:59:\\n- 项目截止日期\\n\\n\" in captured.out\n        assert \"2024-01-05 14:30:\\n- 面试\\n\\n\" in captured.out\n\n    def test_remove_event(self, schedule, capsys):\n        # 添加事件\n        event_date = datetime(2023, 12, 20, 18, 0)\n        schedule.add_event(\"生日聚会\", event_date)\n\n        # 删除事件\n        schedule.remove_event(\"生日聚会\", event_date)\n\n        # 查看事件\n        schedule.view_events()\n        captured = capsys.readouterr()\n\n        # 断言事件是否删除成功\n        assert \"2023-12-20 18:00:\\n\" not in captured.out\n\n    def test_remove_nonexistent_event(self, schedule, capsys):\n        # 添加事件\n        schedule.add_event(\"生日聚会\", datetime(2023, 12, 20, 18, 0))\n\n        # 删除不存在的事件\n        schedule.remove_event(\"项目截止日期\", datetime(2023, 12, 25, 23, 59))\n\n        # 查看事件\n        schedule.view_events()\n        captured = capsys.readouterr()\n\n        # 断言是否输出了相应的错误信息\n        assert \"未找到事件'项目截止日期'\" in captured.out\n\n    def test_remove_event_multiple_times(self, schedule, capsys):\n        # 添加事件\n        event_date = datetime(2023, 12, 20, 18, 0)\n        schedule.add_event(\"生日聚会\", event_date)\n\n        # 多次删除事件\n        schedule.remove_event(\"生日聚会\", event_date)\n        schedule.remove_event(\"生日聚会\", event_date)\n\n        # 查看事件\n        schedule.view_events()\n        captured = capsys.readouterr()\n\n        # 断言事件是否只删除了一次\n        assert \"2023-12-20 18:00:\\n\" not in captured.out\n\n    def test_remove_event_with_different_date(self, schedule, capsys):\n        # 添加事件\n        event_date1 = datetime(2023, 12, 20, 18, 0)\n        event_date2 = datetime(2023, 12, 25, 23, 59)\n        schedule.add_event(\"生日聚会\", event_date1)\n        schedule.add_event(\"项目截止日期\", event_date2)\n\n        # 删除不同日期的事件\n        schedule.remove_event(\"生日聚会\", event_date2)\n\n        # 查看事件\n        schedule.view_events()\n        captured = capsys.readouterr()\n\n        # 断言事件是否删除成功\n        assert \"2023-12-20 18:00:\\n- 生日聚会\\n\\n\" in captured.out\n        assert \"2023-12-25 23:59:\\n- 项目截止日期\\n\\n\" in captured.out\n\n    def test_remove_event_from_empty_schedule(self, schedule, capsys):\n        # 删除空日程中的事件\n        schedule.remove_event(\"生日聚会\", datetime(2023, 12, 20, 18, 0))\n\n        # 查看事件\n        schedule.view_events()\n        captured = capsys.readouterr()\n\n        # 断言是否输出了相应的错误信息\n        assert \"未找到事件'生日聚会'\" in captured.out", "setup_code": "", "reference_solution": "```python\nfrom datetime import datetime\n\nclass Schedule:\n    def __init__(self):\n        self.events = {}\n\n    def add_event(self, event_name, event_date):\n        if event_date in self.events:\n            self.events[event_date].append(event_name)\n        else:\n            self.events[event_date] = [event_name]\n\n    def view_events(self):\n        for event_date, event_names in self.events.items():\n            print(f\"{event_date.strftime('%Y-%m-%d %H:%M')}:\")\n            for event_name in event_names:\n                print(f\"- {event_name}\")\n            print()\n\n    def remove_event(self, event_name, event_date):\n        if event_date in self.events:\n            if event_name in self.events[event_date]:\n                self.events[event_date].remove(event_name)\n                if not self.events[event_date]:\n                    del self.events[event_date]\n                print(f\"已删除事件：{event_name}\")\n                return\n        print(f\"未找到事件'{event_name}'\")\n\n\n```", "classification": "软件工程"}
{"_id": 134, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，给定两个用链表表示的整数，其中每个节点包含一个数字。数字存储按照原来整数中相反的顺序，使得第一个数字位于链表的开头。编写一个函数，将这两个整数相加，并以链表形式返回和。ListNode 类表示链表节点，每个节点包含一个值和指向下一个节点的指针。\n\nadd_two_numbers 函数接收两个链表的头节点 l1 和 l2，以及一个进位变量 carry。\n\n使用 dummy_head 创建一个虚拟头节点，作为新链表的起始节点。\n\ncurrent 变量用于迭代构建新链表。\n\n进入循环，直到两个链表和进位都处理完毕。\n\n在每一次循环中，获取当前节点的值，计算和以及进位。\n\n创建新节点，并将其加入新链表。\n\n移动到下一个节点，更新 l1 和 l2。\n\n最终返回新链表的头节点，即 dummy_head.next。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestListNode:\n    def test_add_two_numbers_equal_length_no_carry(self):\n        l1 = ListNode(2, ListNode(4, ListNode(3)))\n        l2 = ListNode(5, ListNode(6, ListNode(4)))\n        result = add_two_numbers(l1, l2)\n        assert result.value == 7\n        assert result.next.value == 0\n        assert result.next.next.value == 8\n        assert result.next.next.next is None\n\n", "problem": "编写一个程序，给定两个用链表表示的整数，其中每个节点包含一个数字。数字存储按照原来整数中相反的顺序，使得第一个数字位于链表的开头。编写一个函数，将这两个整数相加，并以链表形式返回和。ListNode 类表示链表节点，每个节点包含一个值和指向下一个节点的指针。\n\nadd_two_numbers 函数接收两个链表的头节点 l1 和 l2，以及一个进位变量 carry。\n\n使用 dummy_head 创建一个虚拟头节点，作为新链表的起始节点。\n\ncurrent 变量用于迭代构建新链表。\n\n进入循环，直到两个链表和进位都处理完毕。\n\n在每一次循环中，获取当前节点的值，计算和以及进位。\n\n创建新节点，并将其加入新链表。\n\n移动到下一个节点，更新 l1 和 l2。\n\n最终返回新链表的头节点，即 dummy_head.next。", "testcases": "\n\nclass TestListNode:\n    def test_add_two_numbers_both_empty(self):\n        l1 = None\n        l2 = None\n        assert add_two_numbers(l1, l2) is None\n\n    def test_add_two_numbers_equal_length_with_carry(self):\n        l1 = ListNode(9, ListNode(9, ListNode(9)))\n        l2 = ListNode(1)\n        result = add_two_numbers(l1, l2)\n        assert result.value == 0\n        assert result.next.value == 0\n        assert result.next.next.value == 0\n        assert result.next.next.next.value == 1\n        assert result.next.next.next.next is None\n\n    def test_add_two_numbers_unequal_length_no_carry(self):\n        l1 = ListNode(2, ListNode(4, ListNode(3)))\n        l2 = ListNode(5, ListNode(6))\n        result = add_two_numbers(l1, l2)\n        assert result.value == 7\n        assert result.next.value == 0\n        assert result.next.next.value == 4\n        assert result.next.next.next is None\n\n    def test_add_two_numbers_unequal_length_with_carry(self):\n        l1 = ListNode(9, ListNode(9, ListNode(9)))\n        l2 = ListNode(1, ListNode(1))\n        result = add_two_numbers(l1, l2)\n        assert result.value == 0\n        assert result.next.value == 1\n        assert result.next.next.value == 0\n        assert result.next.next.next.value == 1\n        assert result.next.next.next.next is None\n\n    def test_add_two_numbers_result_has_extra_digit(self):\n        l1 = ListNode(1)\n        l2 = ListNode(9, ListNode(9, ListNode(9)))\n        result = add_two_numbers(l1, l2)\n        assert result.value == 0\n        assert result.next.value == 0\n        assert result.next.next.value == 0\n        assert result.next.next.next.value == 1\n        assert result.next.next.next.next is None\n\n    def test_add_two_numbers_one_empty_(self):\n        l1 = ListNode(1, ListNode(2, ListNode(3)))\n        l2 = None\n        result = add_two_numbers(l1, l2)\n\n        # Traverse both linked lists and compare values\n        while l1 is not None and result is not None:\n            assert l1.value == result.value\n            l1 = l1.next\n            result = result.next\n\n        # Make sure both linked lists reached the end\n        assert l1 is None and result is None\n\n", "setup_code": "", "reference_solution": "```python\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\n\ndef add_two_numbers(l1, l2):\n    carry = 0\n    dummy_head = ListNode()\n    current = dummy_head\n\n    while l1 or l2 or carry:\n        # 获取当前节点的值\n        val1 = l1.value if l1 else 0\n        val2 = l2.value if l2 else 0\n\n        # 计算和以及进位\n        total = val1 + val2 + carry\n        carry, digit = divmod(total, 10)\n\n        # 创建新节点并更新当前节点的next\n        current.next = ListNode(digit)\n        current = current.next\n\n        # 移动到下一个节点\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    return dummy_head.next\n```", "classification": "算法和数据结构"}
{"_id": 135, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n实现一个Python程序，用于解析给定的XML文件并提取特定标签中的数据，并返回一个包含所有数据的列表。在这个任务中，我们需要编写一个Python程序，该程序可以解析给定的XML文件，并从中提取指定标签中的数据。XML是一种常用的标记语言，用于存储和传输数据。parse_xml 函数接受两个参数：file_path 表示 XML 文件的路径，tag_name 表示要提取的 XML 标签名称。\n\n在函数内部，首先尝试使用 ET.parse(file_path) 解析 XML 文件并获取根节点。如果解析失败（可能是因为文件格式错误），则捕获 ET.ParseError 异常并返回一个空列表。\n\n如果解析成功，初始化一个空列表 data_list，用于存储提取的文本内容。\n\n使用 root.findall(tag_name) 遍历根节点下所有指定标签名的子元素。\n\n对于每个符合条件的子元素，将其文本内容（element.text）添加到 data_list 中。\n\n最终，返回包含提取文本的列表 data_list。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestXmlParser:\n    def teardown_method(self, method):\n        os.remove(self.xml_file)\n\n", "problem": "实现一个Python程序，用于解析给定的XML文件并提取特定标签中的数据，并返回一个包含所有数据的列表。在这个任务中，我们需要编写一个Python程序，该程序可以解析给定的XML文件，并从中提取指定标签中的数据。XML是一种常用的标记语言，用于存储和传输数据。parse_xml 函数接受两个参数：file_path 表示 XML 文件的路径，tag_name 表示要提取的 XML 标签名称。\n\n在函数内部，首先尝试使用 ET.parse(file_path) 解析 XML 文件并获取根节点。如果解析失败（可能是因为文件格式错误），则捕获 ET.ParseError 异常并返回一个空列表。\n\n如果解析成功，初始化一个空列表 data_list，用于存储提取的文本内容。\n\n使用 root.findall(tag_name) 遍历根节点下所有指定标签名的子元素。\n\n对于每个符合条件的子元素，将其文本内容（element.text）添加到 data_list 中。\n\n最终，返回包含提取文本的列表 data_list。", "testcases": "\n\nclass TestXmlParser:\n    def test_parse_xml(self):\n        expected_result = ['John', 'Jane']\n        assert parse_xml(self.xml_file, 'name') == expected_result\n\n    def test_parse_xml_nonexistent_tag(self):\n        expected_result = []\n        assert parse_xml(self.xml_file, 'nonexistent_tag') == expected_result\n\n    def test_parse_xml_missing_root_element(self):\n        with open(self.xml_file, 'w') as f:\n            f.write('<name>John</name>\\n')\n            f.write('<age>25</age>\\n')\n        expected_result = []\n        assert parse_xml(self.xml_file, 'name') == expected_result\n\n    def test_parse_xml_no_tag_name(self):\n        expected_result = []\n        assert parse_xml(self.xml_file, '') == expected_result\n\n    def test_parse_xml_invalid_file_format(self):\n        with open(self.xml_file, 'w') as f:\n            f.write('This is not an XML file.')\n        expected_result = []\n        assert parse_xml(self.xml_file, 'name') == expected_result\n\n    def test_parse_xml_multiple_tags(self):\n        expected_result = ['25', '30']\n        assert parse_xml(self.xml_file, 'age') == expected_result\n\n    def test_parse_xml_duplicate_tags(self):\n        with open(self.xml_file, 'w') as f:\n            f.write('<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n')\n            f.write('<root>\\n')\n            f.write('  <name>John</name>\\n')\n            f.write('  <name>Jane</name>\\n')\n            f.write('</root>')\n        expected_result = ['John', 'Jane']\n        assert parse_xml(self.xml_file, 'name') == expected_result\n\n    def setup_method(self, method):\n        self.xml_file = 'test.xml'\n        with open(self.xml_file, 'w') as f:\n            f.write('<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n')\n            f.write('<root>\\n')\n            f.write('  <name>John</name>\\n')\n            f.write('  <age>25</age>\\n')\n            f.write('  <name>Jane</name>\\n')\n            f.write('  <age>30</age>\\n')\n            f.write('</root>')", "setup_code": "", "reference_solution": "```python\nfrom typing import List\nimport xml.etree.ElementTree as ET\n\ndef parse_xml(file_path: str, tag_name: str) -> List[str]:\n\n    try:\n        root = ET.parse(file_path).getroot()\n    except ET.ParseError:\n        return []\n    data_list = []\n    for element in root.findall(tag_name):\n        data_list.append(element.text)\n    return data_list\n\n```", "classification": "前端开发"}
{"_id": 136, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，判断字符串是否是有效的 JavaScript 变量名\n\n编写一个 Python 函数，该函数接受一个字符串作为输入，判断该字符串是否是有效的 JavaScript 变量名。如果是有效的变量名，则返回 True，否则返回 False。\n\n一个有效的 JavaScript 变量名满足以下条件：\n\n变量名只能包含字母、数字、下划线和美元符号（$）。\n变量名的第一个字符必须是字母、下划线或美元符号。\n变量名的长度不能超过 255 个字符。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testis_valid_variable_name:\n    def test_is_valid_variable_name(self):\n        assert is_valid_variable_name('foo') == True\n\n", "problem": "编写一个程序，判断字符串是否是有效的 JavaScript 变量名\n\n编写一个 Python 函数，该函数接受一个字符串作为输入，判断该字符串是否是有效的 JavaScript 变量名。如果是有效的变量名，则返回 True，否则返回 False。\n\n一个有效的 JavaScript 变量名满足以下条件：\n\n变量名只能包含字母、数字、下划线和美元符号（$）。\n变量名的第一个字符必须是字母、下划线或美元符号。\n变量名的长度不能超过 255 个字符。", "testcases": "import re\n\n\nclass Testis_valid_variable_name:\n    def test_is_valid_variable_name1(self):\n        assert is_valid_variable_name('_bar') == True\n\n    def test_is_valid_variable_name2(self):\n        assert is_valid_variable_name('$baz') == True\n\n    def test_is_valid_variable_name3(self):\n        assert is_valid_variable_name('12abc') == False\n\n    def test_is_valid_variable_name4(self):\n        assert is_valid_variable_name('abc12') == True\n\n    def test_is_valid_variable_name5(self):\n        assert is_valid_variable_name('a' * 256) == False\n\n    def test_is_valid_variable_name6(self):\n        assert is_valid_variable_name(' ') == False\n\n    def test_is_valid_variable_name7(self):\n        assert is_valid_variable_name('foo bar') == False\n\n", "setup_code": "", "reference_solution": "```python\nimport re\n\n\ndef is_valid_variable_name(name):\n    \"\"\"\n    判断字符串是否是有效的 JavaScript 变量名\n    \"\"\"\n    if len(name) > 255:\n        return False\n    if not re.match(r'^[a-zA-Z_$][a-zA-Z0-9_$]*$', name):\n        return False\n    return True\n\n```", "classification": "前端开发"}
{"_id": 137, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n实现一个简单的电子商务订单系统。\n\n要求：\n\n实现一个 Order 类，具有以下属性：\norder_id：订单编号，类型为字符串。\nitems：订单中的商品列表，每个商品是一个字典，包含商品名称和价格。\ntotal_price：订单的总价格，类型为浮点数。\nstatus：订单的状态，类型为字符串，初始状态为 \"未支付\"。\n实现以下方法：\nadd_item(item_name, item_price)：向订单中添加商品，参数为商品名称和价格。\nremove_item(item_name)：从订单中移除指定商品，参数为商品名称。\ncalculate_total_price()：计算订单的总价格，并更新 total_price 属性。\npay_order()：支付订单，将订单的状态更新为 \"已支付\"。\ncancel_order()：取消订单，将订单的状态更新为 \"已取消\"。\nview_order()：输出订单的详细信息，包括订单编号、商品列表、总价格和状态, 遵循以下格式：\n订单编号： 20231218\n商品列表：\n- 商品1: ￥10.5\n- 商品2: ￥20.3\n总价格：￥30.8\n状态： 未支付\n\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestOrder:\n    def test_add_item(self):\n        order = Order(\"20231218\")\n        order.add_item(\"商品1\", 10.5)\n        assert len(order.items) == 1\n        assert order.items[0][\"name\"] == \"商品1\"\n        assert order.items[0][\"price\"] == 10.5\n\n", "problem": "实现一个简单的电子商务订单系统。\n\n要求：\n\n实现一个 Order 类，具有以下属性：\norder_id：订单编号，类型为字符串。\nitems：订单中的商品列表，每个商品是一个字典，包含商品名称和价格。\ntotal_price：订单的总价格，类型为浮点数。\nstatus：订单的状态，类型为字符串，初始状态为 \"未支付\"。\n实现以下方法：\nadd_item(item_name, item_price)：向订单中添加商品，参数为商品名称和价格。\nremove_item(item_name)：从订单中移除指定商品，参数为商品名称。\ncalculate_total_price()：计算订单的总价格，并更新 total_price 属性。\npay_order()：支付订单，将订单的状态更新为 \"已支付\"。\ncancel_order()：取消订单，将订单的状态更新为 \"已取消\"。\nview_order()：输出订单的详细信息，包括订单编号、商品列表、总价格和状态, 遵循以下格式：\n订单编号： 20231218\n商品列表：\n- 商品1: ￥10.5\n- 商品2: ￥20.3\n总价格：￥30.8\n状态： 未支付\n", "testcases": "\n\nclass TestOrder:\n    def test_remove_item(self):\n        order = Order(\"20231218\")\n        order.add_item(\"商品1\", 10.5)\n        order.remove_item(\"商品1\")\n        assert len(order.items) == 0\n\n    def test_calculate_total_price(self):\n        order = Order(\"20231218\")\n        order.add_item(\"商品1\", 10.5)\n        order.add_item(\"商品2\", 20.3)\n        order.calculate_total_price()\n        assert order.total_price == 30.8\n\n    def test_remove_item_(self):\n        order = Order(\"20231218\")\n        order.add_item(\"商品1\", 10.5)\n        order.remove_item(\"商品1\")\n        assert len(order.items) == 0\n\n    def test_pay_order(self):\n        order = Order(\"20231218\")\n        order.pay_order()\n        assert order.status == \"未支付\"\n\n    def test_pay_order_(self):\n        order = Order(\"20231210\")\n        assert order.status == \"未支付\"\n\n    def test_cancel_order(self):\n        order = Order(\"20231218\")\n        order.cancel_order()\n        assert order.status == \"已取消\"\n\n    def test_view_order(self, capsys):\n        order = Order(\"20231218\")\n        order.add_item(\"商品1\", 10.5)\n        order.add_item(\"商品2\", 20.3)\n        order.calculate_total_price()\n        order.view_order()\n        captured = capsys.readouterr()\n        expected_output = (\n            \"订单编号： 20231218\\n\"\n            \"商品列表：\\n\"\n            \"- 商品1: ￥10.5\\n\"\n            \"- 商品2: ￥20.3\\n\"\n            \"总价格：￥30.8\\n\"\n            \"状态： 未支付\\n\"\n        )\n        assert captured.out == expected_output\n", "setup_code": "", "reference_solution": "```python\nclass Order:\n    def __init__(self, order_id):\n        self.order_id = order_id\n        self.items = []\n        self.total_price = 0.0\n        self.status = \"未支付\"\n\n    def add_item(self, item_name, item_price):\n        if not isinstance(item_price, (int, float)) or item_price <= 0:\n            return \"商品价格必须是正数\"\n\n        item = {\"name\": item_name, \"price\": item_price}\n        self.items.append(item)\n\n    def remove_item(self, item_name):\n        for item in self.items:\n            if item[\"name\"] == item_name:\n                self.items.remove(item)\n                break\n        else:\n            return \"该商品不存在于订单中\"\n\n    def calculate_total_price(self):\n        self.total_price = sum(item[\"price\"] for item in self.items)\n\n    def pay_order(self):\n        if not self.items:\n            return \"订单中没有商品\"\n        self.status = \"已支付\"\n\n    def cancel_order(self):\n        self.status = \"已取消\"\n\n    def view_order(self):\n        print(\"订单编号：\", self.order_id)\n        print(\"商品列表：\")\n        for item in self.items:\n            print(\"- {}: ￥{}\".format(item[\"name\"], item[\"price\"]))\n        print(\"总价格：￥{}\".format(self.total_price))\n        print(\"状态：\", self.status)\n```", "classification": "软件工程"}
{"_id": 138, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n写一个程序，程序内容是给定一个只包含小写字母的字符串 s，请编写一个函数 is_valid_sequence(s)，判断该字符串是否满足以下条件：\n字符串 s 的长度在 2 到 10 之间（包含 2 和 10）。\n字符串 s 中的每个字符都必须是小写字母。\n字符串 s 中不能出现连续的重复字符，即相邻的字符不能相同。\n如果将字符串 s 划分为左右两部分，左部分和右部分必须满足以下条件之一：\n左部分和右部分都是回文字符串。\n左部分和右部分都是递增序列（即每个字符的 ASCII 值都比前一个字符大）。is_valid_sequence 函数接受一个字符串 s 作为参数。\n\n首先检查字符串长度是否在 2 到 10 之间，如果不在这个范围内，返回 False。\n\n然后，检查字符串中的字符是否都是小写字母，如果存在非小写字母的字符，返回 False。\n\n接着，检查字符串中是否出现连续的重复字符，如果有，返回 False。\n\n最后，判断字符串是否可以分为左右两部分，且这两部分中要么是回文字符串，要么是递增序列。如果满足这个条件，返回 True；否则，返回 False。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testis_valid_sequence:\n    def test_is_valid_sequence_case1(self):\n        assert is_valid_sequence(\"abba\") == False\n\n", "problem": "写一个程序，程序内容是给定一个只包含小写字母的字符串 s，请编写一个函数 is_valid_sequence(s)，判断该字符串是否满足以下条件：\n字符串 s 的长度在 2 到 10 之间（包含 2 和 10）。\n字符串 s 中的每个字符都必须是小写字母。\n字符串 s 中不能出现连续的重复字符，即相邻的字符不能相同。\n如果将字符串 s 划分为左右两部分，左部分和右部分必须满足以下条件之一：\n左部分和右部分都是回文字符串。\n左部分和右部分都是递增序列（即每个字符的 ASCII 值都比前一个字符大）。is_valid_sequence 函数接受一个字符串 s 作为参数。\n\n首先检查字符串长度是否在 2 到 10 之间，如果不在这个范围内，返回 False。\n\n然后，检查字符串中的字符是否都是小写字母，如果存在非小写字母的字符，返回 False。\n\n接着，检查字符串中是否出现连续的重复字符，如果有，返回 False。\n\n最后，判断字符串是否可以分为左右两部分，且这两部分中要么是回文字符串，要么是递增序列。如果满足这个条件，返回 True；否则，返回 False。", "testcases": "\nclass Testis_valid_sequence:\n    def test_is_valid_sequence_case2(self):\n        assert is_valid_sequence(\"abcd\") == False\n\n    def test_is_valid_sequence_case3(self):\n        assert is_valid_sequence(\"a\") == False\n\n    def test_is_valid_sequence_case4(self):\n        assert is_valid_sequence(\"abcdefghij\") == False\n\n    def test_is_valid_sequence_case5(self):\n        assert is_valid_sequence(\"Abba\") == False\n\n    def test_is_valid_sequence_case6(self):\n        assert is_valid_sequence(\"abbb\") == False\n\n    def test_is_valid_sequence_case7(self):\n        assert is_valid_sequence(\"abcde\") == False\n\n    def test_is_valid_sequence_case8(self):\n        assert is_valid_sequence(\"\") == False", "setup_code": "", "reference_solution": "```python\ndef is_valid_sequence(s):\n    # 判断字符串长度是否在 2 到 10 之间\n    if len(s) < 2 or len(s) > 10:\n        return False\n\n        # 判断字符串中的字符是否都是小写字母\n    for char in s:\n        if not char.islower():\n            return False\n\n            # 判断字符串中是否出现连续的重复字符\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return False\n\n            # 判断左右两部分是否都是回文字符串或递增序列\n    left, right = s[:len(s) // 2], s[len(s) // 2:]\n    if left == right[::-1] or sorted(left) == sorted(right):\n        return True\n    else:\n        return False\n```", "classification": "算法和数据结构"}
{"_id": 139, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写程序，定义一个名为 RouteSimulator 的类，用于模拟在平面上移动的路径。以下是对代码的中文描述：\n\n初始化方法 (__init__)：\n\n在初始化过程中，设置了起始位置的 x 和 y 坐标，并初始化了一个移动历史列表 move_history 用于记录每次移动的距离、角度和新的位置。\n移动方法 (move)：\n\n接受两个参数：distance 表示移动的距离，angle_degrees 表示移动的方向角度。\n将角度转换为弧度，并使用三角函数计算新的位置坐标。\n更新当前位置为新的位置，同时将移动历史记录添加到列表中。\n计算距离方法 (calculate_distance)：\n\n接受四个参数：两个点的 x 和 y 坐标。\n使用欧几里得距离公式计算两点之间的距离。\n打印当前位置方法 (print_current_position)：\n\n打印当前位置的 x 和 y 坐标。输出格式为\"当前位置：(x, y)\"\n打印移动历史方法 (print_move_history)：\n\n打印移动历史，包括每次移动的距离、角度和新的位置。输出的数字保留两位小数且输出格式为：\n移动历史：\n距离: {distance}, 角度: {angle_degrees}, 位置: {position}\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestRouteSimulator:\n    def test_initial_position(self, route_simulator, capfd):\n        route_simulator.print_current_position()\n        captured = capfd.readouterr()\n        assert captured.out.strip() == \"当前位置：(0.00, 0.00)\"\n\n", "problem": "编写程序，定义一个名为 RouteSimulator 的类，用于模拟在平面上移动的路径。以下是对代码的中文描述：\n\n初始化方法 (__init__)：\n\n在初始化过程中，设置了起始位置的 x 和 y 坐标，并初始化了一个移动历史列表 move_history 用于记录每次移动的距离、角度和新的位置。\n移动方法 (move)：\n\n接受两个参数：distance 表示移动的距离，angle_degrees 表示移动的方向角度。\n将角度转换为弧度，并使用三角函数计算新的位置坐标。\n更新当前位置为新的位置，同时将移动历史记录添加到列表中。\n计算距离方法 (calculate_distance)：\n\n接受四个参数：两个点的 x 和 y 坐标。\n使用欧几里得距离公式计算两点之间的距离。\n打印当前位置方法 (print_current_position)：\n\n打印当前位置的 x 和 y 坐标。输出格式为\"当前位置：(x, y)\"\n打印移动历史方法 (print_move_history)：\n\n打印移动历史，包括每次移动的距离、角度和新的位置。输出的数字保留两位小数且输出格式为：\n移动历史：\n距离: {distance}, 角度: {angle_degrees}, 位置: {position}", "testcases": "import math\n\nclass TestRouteSimulator:\n    def test_move_forward(self, route_simulator, capfd):\n        route_simulator.move(distance=1, angle_degrees=0)\n        route_simulator.print_current_position()\n        captured = capfd.readouterr()\n        assert captured.out.strip() == \"当前位置：(1.00, 0.00)\"\n\n    def test_move_backward(self, route_simulator, capfd):\n        route_simulator.move(distance=1, angle_degrees=180)\n        route_simulator.print_current_position()\n        captured = capfd.readouterr()\n        assert captured.out.strip() == \"当前位置：(-1.00, 0.00)\"\n\n    def test_move_diagonal(self, route_simulator, capfd):\n        route_simulator.move(distance=1, angle_degrees=45)\n        route_simulator.print_current_position()\n        captured = capfd.readouterr()\n        assert captured.out.strip() == f\"当前位置：({math.sqrt(0.5):.2f}, {math.sqrt(0.5):.2f})\"\n\n    def test_move_right(self, route_simulator, capfd):\n        route_simulator.move(distance=1, angle_degrees=90)\n        route_simulator.print_current_position()\n        captured = capfd.readouterr()\n        assert captured.out.strip() == \"当前位置：(0.00, 1.00)\"\n\n    def test_calculate_distance(self, route_simulator):\n        distance = route_simulator.calculate_distance(0, 0, 3, 4)\n        assert distance == 5.0\n\n    def test_move_history_empty(self, route_simulator, capfd):\n        route_simulator.print_move_history()\n        captured = capfd.readouterr()\n        assert captured.out.strip() == \"移动历史：\"\n\n    def test_move_history_non_empty(self, route_simulator, capfd):\n        route_simulator.move(distance=1, angle_degrees=30)\n        route_simulator.print_move_history()\n        captured = capfd.readouterr()\n        assert \"距离: 1.00, 角度: 30.00, 位置: (0.87, 0.50)\" in captured.out\n\n    @pytest.fixture\n    def route_simulator(self):\n        return RouteSimulator(x=0, y=0)\n\n", "setup_code": "", "reference_solution": "```python\nimport math\n\nclass RouteSimulator:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.move_history = []\n\n    def move(self, distance, angle_degrees):\n        # 将角度转换为弧度\n        angle_radians = math.radians(angle_degrees)\n\n        # 计算新的位置\n        new_x = self.x + distance * math.cos(angle_radians)\n        new_y = self.y + distance * math.sin(angle_radians)\n\n        # 更新位置\n        self.x, self.y = new_x, new_y\n\n        # 记录移动历史\n        self.move_history.append({'distance': distance, 'angle_degrees': angle_degrees, 'position': (new_x, new_y)})\n\n    def calculate_distance(self, x1, y1, x2, y2):\n        # 计算两点之间的距离\n        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    def print_current_position(self):\n        print(f\"当前位置：({self.x:.2f}, {self.y:.2f})\")\n\n    def print_move_history(self):\n        print(\"移动历史：\")\n        for move in self.move_history:\n            distance = move['distance']\n            angle_degrees = move['angle_degrees']\n            position = move['position']\n            print(f\"距离: {distance:.2f}, 角度: {angle_degrees:.2f}, 位置: ({position[0]:.2f}, {position[1]:.2f})\")\n\n```", "classification": "软件工程"}
{"_id": 140, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，实现字符串从 UTF-8 编码转换为 ASCII 编码的功能。要求如下：\n\n输入一个字符串（UTF-8 编码）。\n程序将逐个字符读取输入字符串，并将每个字符转换为对应的 ASCII 码。\n将转换后的 ASCII 码逐个打印输出。\n您可以使用适当的编程语言来实现这个功能。请注意，UTF-8 编码中的多字节字符需要进行特殊处理，确保正确转换为对应的 ASCII 码。调用utf8_to_ascii函数之后，将输出一个ASCII码列表，其中每个元素为输入字符串中的一个字符对应的ASCII码。\n\n例如，如果输入字符串为\"Hello World!\"，那么调用utf8_to_ascii函数后，将输出如下ASCII码列表：\n\n[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n其中，第一个元素72对应字符H的ASCII码，第二个元素101对应字符e的ASCII码，以此类推。\n\n这些ASCII码可以进一步用于其他操作，例如加密、转换等。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testutf8_to_ascii:\n    def test_hello_world(self):\n        assert utf8_to_ascii(\"Hello, World!\") == [72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]\n\n", "problem": "编写一个程序，实现字符串从 UTF-8 编码转换为 ASCII 编码的功能。要求如下：\n\n输入一个字符串（UTF-8 编码）。\n程序将逐个字符读取输入字符串，并将每个字符转换为对应的 ASCII 码。\n将转换后的 ASCII 码逐个打印输出。\n您可以使用适当的编程语言来实现这个功能。请注意，UTF-8 编码中的多字节字符需要进行特殊处理，确保正确转换为对应的 ASCII 码。调用utf8_to_ascii函数之后，将输出一个ASCII码列表，其中每个元素为输入字符串中的一个字符对应的ASCII码。\n\n例如，如果输入字符串为\"Hello World!\"，那么调用utf8_to_ascii函数后，将输出如下ASCII码列表：\n\n[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n其中，第一个元素72对应字符H的ASCII码，第二个元素101对应字符e的ASCII码，以此类推。\n\n这些ASCII码可以进一步用于其他操作，例如加密、转换等。", "testcases": "\n\nclass Testutf8_to_ascii:\n    def test_empty_string(self):\n        assert utf8_to_ascii(\"\") == None\n\n    def test_invalid_hex_code(self):\n        assert utf8_to_ascii(\"Hello%20Wo%zz\") == None\n\n    def test_single_character(self):\n        assert utf8_to_ascii(\"A\") == [65]\n\n    def test_special_characters(self):\n        assert utf8_to_ascii(\"!@#$%^&*()_+-=\") == [33, 64, 35, 36, 37, 94, 38, 42, 40, 41, 95, 43, 45, 61]\n\n    def test_unicode_characters(self):\n        assert utf8_to_ascii(\"\\u2018\\u2019\\u201c\\u201d\") == [8216, 8217, 8220, 8221]\n\n    def test_long_string(self):\n        assert utf8_to_ascii(\"a\" * 1000) == [97] * 1000\n\n    def test_invalid_input_type(self):\n        assert utf8_to_ascii(123) == None\n\n    def test_invalid_input_encoding(self):\n        assert utf8_to_ascii(b\"Hello%20World%21\") == None\n", "setup_code": "", "reference_solution": "```python\ndef utf8_to_ascii(utf8_string):\n    # 验证输入字符串是否为空\n    if not utf8_string:\n        print(\"输入字符串不能为空！\")\n        return None\n\n    result = []\n\n    try:\n        # 遍历输入字符串的每个字符\n        for i in range(len(utf8_string)):\n            if utf8_string[i] == '%' and i + 2 < len(utf8_string) and utf8_string[i + 1:i + 3].isalnum():\n                # 如果遇到以%开头的16进制字符编码，则进行解析\n                hex_str = utf8_string[i + 1:i + 3]\n                ascii_code = int(hex_str, 16)\n                result.append(ascii_code)\n                i += 2\n            else:\n                # 普通的UTF-8字符直接转换为ASCII码\n                ascii_code = ord(utf8_string[i])\n                result.append(ascii_code)\n    except IndexError:\n        print(\"输入字符串格式错误！\")\n        return None\n    except ValueError:\n        print(\"输入字符串包含非法的字符编码！\")\n        return None\n    except Exception as e:\n        print(\"发生未知错误：\", str(e))\n        return None\n\n    return result\n\n\n\n```", "classification": "软件工程"}
{"_id": 141, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，实现一个 Python 函数 find_dates(text)，它接受一个字符串 text 作为参数，并返回所有在该字符串中出现的日期。其中，日期应采用标准的年-月-日（YYYY-MM-DD）格式。\n\n要求：\n\n日期必须符合标准的年-月-日（YYYY-MM-DD）格式。\n\n日期中的年份必须是四位数字，月份和日期必须是两位数字。\n\n函数不得使用爬虫或用户输入等外部资源。\n\n函数必须使用正则表达式来识别日期。\n\n函数必须返回所有符合要求的日期，如果没有符合要求的日期，则返回一个空列表。\n\n样例：\n\npython\ntext = \"The event will take place on 2022-01-25 and the deadline is 2022-02-15.\"\nprint(find_dates(text))\n# output: ['2022-01-25', '2022-02-15']\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testfind_dates:\n    def test_case_1(self):\n        text = \"The event will take place on 2022-01-25 and the deadline is 2022-02-15.\"\n        expected_dates = [\"2022-01-25\", \"2022-02-15\"]\n        assert find_dates(text) == expected_dates\n\n", "problem": "编写一个程序，实现一个 Python 函数 find_dates(text)，它接受一个字符串 text 作为参数，并返回所有在该字符串中出现的日期。其中，日期应采用标准的年-月-日（YYYY-MM-DD）格式。\n\n要求：\n\n日期必须符合标准的年-月-日（YYYY-MM-DD）格式。\n\n日期中的年份必须是四位数字，月份和日期必须是两位数字。\n\n函数不得使用爬虫或用户输入等外部资源。\n\n函数必须使用正则表达式来识别日期。\n\n函数必须返回所有符合要求的日期，如果没有符合要求的日期，则返回一个空列表。\n\n样例：\n\npython\ntext = \"The event will take place on 2022-01-25 and the deadline is 2022-02-15.\"\nprint(find_dates(text))\n# output: ['2022-01-25', '2022-02-15']", "testcases": "import re\nimport datetime\n\n\nclass Testfind_dates:\n    def test_case_2(self):\n        text = \"Another possible date format is 2022-02-15.\"\n        expected_dates = ['2022-02-15']\n        assert find_dates(text) == expected_dates\n\n    def test_case_3(self):\n        text = \"And the third format is 01*01-*024.\"\n        expected_dates = \"未找到有效日期\"\n        assert find_dates(text) == expected_dates\n\n    def test_case_4(self):\n        text = \"Lastly, we have a date like 1 January 2025.\"\n        expected_dates = '未找到有效日期'\n        assert find_dates(text) == expected_dates\n\n    def test_case_5(self):\n        text = \"Invalid date formats: 2022-13-01, 31/12/2023, 01-01-2024\"\n        expected_dates = \"未找到有效日期\"\n        assert find_dates(text) == expected_dates\n\n    def test_case_6(self):\n        text = \"No dates in this text.\"\n        expected_dates = \"未找到有效日期\"\n        assert find_dates(text) == expected_dates\n\n    def test_case_7(self):\n        text = \"The event happened on 2020-12-25 and it was a great success.\"\n        expected_dates = [\"2020-12-25\"]\n        assert find_dates(text) == expected_dates\n\n    def test_case_8(self):\n        text = \"The due date for submission is 2022-06-30.\"\n        expected_dates = [\"2022-06-30\"]\n        assert find_dates(text) == expected_dates\n\n\n", "setup_code": "", "reference_solution": "```python\nimport re\nimport datetime\n\n\ndef find_dates(text):\n    if not text:\n        return \"输入的文本为空，请提供有效的文本内容\"\n\n    date_patterns = [\n        r\"\\b(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])\\b\",  # YYYY-MM-DD\n        r\"\\b(0[1-9]|1[0-2])/(0[1-9]|[12][0-9]|3[01])/(19|20)?\\d{2}\\b\",  # MM/DD/YYYY or M/D/YYYY\n        r\"\\b(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-(19|20)?\\d{2}\\b\",  # DD-MM-YYYY or D-M-YYYY\n        r\"\\b(0[1-9]|[12][0-9]|3[01])\\s(January|February|March|April|May|June|July|August|September|October|November|December),?\\s(19|20)?\\d{2}\\b\"\n        # DD Month YYYY or D Month YYYY\n    ]\n    dates = []\n    for pattern in date_patterns:\n        dates.extend(re.findall(pattern, text))\n\n    formatted_dates = []\n    for date in dates:\n        if date[0]:  # 如果匹配到了年份\n            year = date[0]\n        else:\n            year = \"20\" + date[3] if date[3] else \"\"  # 如果没有匹配到年份，则根据模式中的分组确定年份\n\n        month = date[1].zfill(2)\n        day = date[2].zfill(2)\n\n        # 检查日期的有效性\n        try:\n            formatted_date = f\"{year}-{month}-{day}\"\n            _ = datetime.datetime.strptime(formatted_date, \"%Y-%m-%d\")\n            formatted_dates.append(formatted_date)\n        except ValueError:\n            pass\n\n    if not formatted_dates:\n        return \"未找到有效日期\"\n\n    return formatted_dates\n\n```", "classification": "软件工程"}
{"_id": 142, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序,模拟操作系统内存管理的 Python 代码。代码中定义了一个 Process 类，表示一个进程，每个进程有一个唯一的进程标识符（pid）和一段代码（code）。操作系统维护了一个内存映射表 memory_map，用于跟踪内存的分配情况。示例中，两个进程被创建并添加到 processes 列表中。然后，通过调用 allocate_memory 函数，为每个进程分配内存。最后，通过调用 run_processes 函数，模拟运行了所有进程，并通过调用 deallocate_memory 函数释放了进程占用的内存。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestProcess:\n    def test_successful_memory_allocation(self):\n        memory_map = [0] * 100\n        process = Process(pid=1, code=[1, 2, 3])\n\n        assert allocate_memory(memory_map, process) == True\n        assert process.memory is not None\n\n\n", "problem": "编写一个程序,模拟操作系统内存管理的 Python 代码。代码中定义了一个 Process 类，表示一个进程，每个进程有一个唯一的进程标识符（pid）和一段代码（code）。操作系统维护了一个内存映射表 memory_map，用于跟踪内存的分配情况。示例中，两个进程被创建并添加到 processes 列表中。然后，通过调用 allocate_memory 函数，为每个进程分配内存。最后，通过调用 run_processes 函数，模拟运行了所有进程，并通过调用 deallocate_memory 函数释放了进程占用的内存。", "testcases": "\n\nclass TestProcess:\n    def test_successful_allocation_multiple_processes(self):\n        memory_map = [0] * 100\n        process1 = Process(pid=1, code=[1, 2, 3])\n        process2 = Process(pid=2, code=[4, 5, 6])\n\n        assert allocate_memory(memory_map, process1) == True\n        assert allocate_memory(memory_map, process2) == True\n        assert process1.memory is not None\n        assert process2.memory is not None\n\n\n    def test_failed_memory_allocation(self):\n        memory_map = [1] * 100  # Memory is already full\n        process = Process(pid=1, code=[1, 2, 3])\n\n        assert allocate_memory(memory_map, process) == False\n        assert process.memory is None\n\n\n    def test_memory_deallocation(self):\n        memory_map = [0] * 100\n        process = Process(pid=1, code=[1, 2, 3])\n\n        allocate_memory(memory_map, process)\n        deallocate_memory(memory_map, process)\n\n        assert process.memory is None\n\n\n    def test_run_processes(self):\n        processes = [\n            Process(pid=1, code=[1, 2, 3]),\n            Process(pid=2, code=[4, 5, 6])\n        ]\n\n        run_processes(processes)\n        # Manual inspection of output\n\n\n    def test_deallocate_unallocated_memory(self):\n        memory_map = [0] * 100\n        process = Process(pid=1, code=[1, 2, 3])\n\n        deallocate_memory(memory_map, process)\n\n        assert process.memory is None\n\n\n    def test_run_empty_processes(self):\n        empty_processes = []\n        run_processes(empty_processes)\n        # Manual inspection of output\n\n\n    def test_allocate_full_memory(self):\n        full_memory_map = [0] * 100\n        full_process = Process(pid=1, code=[1] * 100)\n\n        assert allocate_memory(full_memory_map, full_process) == True\n        assert full_process.memory is not None\n\n\n    def test_continuous_allocation_deallocation(self):\n        continuous_memory_map = [0] * 100\n        continuous_process = Process(pid=1, code=[1, 2, 3])\n\n        assert allocate_memory(continuous_memory_map, continuous_process) == True\n        assert continuous_process.memory is not None\n\n        deallocate_memory(continuous_memory_map, continuous_process)\n\n        assert continuous_process.memory is None\n", "setup_code": "", "reference_solution": "```python\nclass Process:\n    def __init__(self, pid, code):\n        self.pid = pid\n        self.code = code\n        self.memory = None\n\ndef allocate_memory(memory_map, process):\n    if process.memory is not None:\n        raise ValueError(\"Process already has memory\")\n\n    for i in range(len(memory_map)):\n        if memory_map[i] == 0:\n            process.memory = i\n            for j in range(len(process.code)):\n                memory_map[i + j] = 1\n            return True\n\n    return False\n\ndef deallocate_memory(memory_map, process):\n    if process.memory is not None:\n        for i in range(len(process.code)):\n            memory_map[process.memory + i] = 0\n        process.memory = None\n\ndef run_processes(processes):\n    for process in processes:\n        print(f\"Running Process {process.pid} with code: {process.code}\")\n\n# 创建一个简单的操作系统\nmemory_map = [0] * 100\nprocesses = []\n\n# 创建两个进程\nprocess1 = Process(pid=1, code=[1, 2, 3])\nprocess2 = Process(pid=2, code=[4, 5, 6])\n\n# 将进程添加到列表\nprocesses.append(process1)\nprocesses.append(process2)\n\n# 分配内存\nallocate_memory(memory_map, process1)\nallocate_memory(memory_map, process2)\n\n# 运行进程\nrun_processes(processes)\n\n# 释放内存\ndeallocate_memory(memory_map, process1)\ndeallocate_memory(memory_map, process2)\n\n```", "classification": "操作系统"}
{"_id": 143, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，实现题目描述：\n给定一个包含多个英文句子的 HTML 文本，编写一个函数 get_top_k_words_from_html(html, k)，返回出现次数最多的前 k 个单词及其出现次数。\n\n编写一个函数 get_top_k_words_from_html(html, k)，其中参数 html 为一个包含 HTML 标记的字符串，k 为一个正整数，返回一个列表，包括前 k 个出现次数最多的单词及其出现次数，按出现次数从大到小排列。\n\n示例：\n输入： \"<p>We are the world, we are the children.</p> <p>We are the ones who make a brighter day.</p> <p>So let's start giving.</p>\"\n输出： [('we', 3), ('are', 3), ('the', 3)]\n\n输入： \"<p>The quick brown fox jumps over the lazy dog.</p> <p>The quick brown fox jumps over the lazy dog.</p>\"\n输出： [('the', 4), ('brown', 2), ('quick', 2)]\n\n注意：\n\n单词不区分大小写，即 \"The\" 和 \"the\" 视为同一个单词。\n单词定义为由字母和数字组成的字符串，不包括标点符号。\n返回的列表中应包括所有出现次数相同的前 k 个单词及其出现次数。\n可以使用库来解析 HTML 文本，并使用标准库函数或模块来辅助解决问题。\n请实现函数 get_top_k_words_from_html(html, k) 来解决该题目。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testget_top_k_words_from_html:\n    def test_empty_html(self):\n        html = \"<html><body></body></html>\"\n        assert get_top_k_words_from_html(html, 5) == []\n\n", "problem": "编写一个程序，实现题目描述：\n给定一个包含多个英文句子的 HTML 文本，编写一个函数 get_top_k_words_from_html(html, k)，返回出现次数最多的前 k 个单词及其出现次数。\n\n编写一个函数 get_top_k_words_from_html(html, k)，其中参数 html 为一个包含 HTML 标记的字符串，k 为一个正整数，返回一个列表，包括前 k 个出现次数最多的单词及其出现次数，按出现次数从大到小排列。\n\n示例：\n输入： \"<p>We are the world, we are the children.</p> <p>We are the ones who make a brighter day.</p> <p>So let's start giving.</p>\"\n输出： [('we', 3), ('are', 3), ('the', 3)]\n\n输入： \"<p>The quick brown fox jumps over the lazy dog.</p> <p>The quick brown fox jumps over the lazy dog.</p>\"\n输出： [('the', 4), ('brown', 2), ('quick', 2)]\n\n注意：\n\n单词不区分大小写，即 \"The\" 和 \"the\" 视为同一个单词。\n单词定义为由字母和数字组成的字符串，不包括标点符号。\n返回的列表中应包括所有出现次数相同的前 k 个单词及其出现次数。\n可以使用库来解析 HTML 文本，并使用标准库函数或模块来辅助解决问题。\n请实现函数 get_top_k_words_from_html(html, k) 来解决该题目。", "testcases": "import re\nfrom collections import Counter\nfrom bs4 import BeautifulSoup\n\n\nclass Testget_top_k_words_from_html:\n    def test_basic_html(self):\n        html = \"<html><body>This is a simple HTML text. Hello world!</body></html>\"\n        assert get_top_k_words_from_html(html, 3) == [('simple', 1), ('html', 1), ('text', 1)]\n\n    def test_html_with_tags(self):\n        html = \"<html><body><h1>Title</h1><p> is a paragraph.</p></body></html>\"\n        assert get_top_k_words_from_html(html, 4) == [('title', 1), ('paragraph', 1)]\n\n    def test_html_with_special_characters(self):\n        html = \"<html><body>Encoding: &#1632;&#1633;&#1634;</body></html>\"\n        assert get_top_k_words_from_html(html, 3) == [('encoding', 1), ('٠١٢', 1)]\n\n    def test_html_with_unicode_characters(self):\n        html = \"<html><body>Unicode: àéîőű</body></html>\"\n        assert get_top_k_words_from_html(html, 4) == [('unicode', 1), ('àéîőű', 1)]\n\n    def test_html_with_duplicate_words(self):\n        html = \"<html><body>Repeated words test. This is a test repeated words.</body></html>\"\n        assert get_top_k_words_from_html(html, 4) == [('repeated', 2), ('words', 2), ('test', 2)]\n\n    def test_large_html(self):\n        # Test with a large HTML content\n        html = \"<html><body>\" + \"word1 \" * 1000 + \"</body></html>\"\n        assert get_top_k_words_from_html(html, 1) == [('word1', 1000)]\n\n\n    def test_html_with_numbers(self):\n        html = \"<html><body>Numbers: 123 456 789</body></html>\"\n        assert get_top_k_words_from_html(html, 3) == [('numbers', 1), ('123', 1), ('456', 1)]\n\n\n    def test_html_with_unicode_characters_and_numbers(self):\n        html = \"<html><body>Unicode and numbers: àéîőű 12345</body></html>\"\n        assert get_top_k_words_from_html(html, 4) == [('unicode', 1), ('numbers', 1), ('àéîőű', 1), ('12345', 1)]\n\n\n\n", "setup_code": "", "reference_solution": "```python\nimport re\nfrom collections import Counter\nfrom bs4 import BeautifulSoup\n\n\ndef get_top_k_words_from_html(html, k):\n    # 定义需要排除的单词列表\n    exclude_list = ['this','is','are','a', 'an', 'the', 'and', 'or', 'in', 'on', 'at', 'to', 'of', 'for', 'with', 'by', 'from']\n\n    try:\n        # 解析HTML文本\n        soup = BeautifulSoup(html, 'lxml')\n\n        # 获取所有文本内容\n        text = soup.get_text()\n\n        # 将文本转换为小写，并使用正则表达式提取单词\n\n        lower=text.lower()\n        words = re.findall(r'\\b(?<!-)(?!' + '|'.join(exclude_list) + r')\\w+(?<!-)\\b', lower, flags=re.UNICODE)\n\n        # 使用Counter统计单词出现次数\n        word_counts = Counter(words)\n\n        # 获取出现次数最多的前k个单词及其出现次数\n        top_k_words = word_counts.most_common(k)\n\n        return top_k_words\n\n    except Exception as e:\n        print(\"Error occurred:\", str(e))\n        return None\n\n```", "classification": "前端开发"}
{"_id": 144, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，完成题目：气象数据分析\n\n编写一个程序，实现对气温数据的分析和处理。\n\n要求：\n\n编写一个函数 extract_temperatures_from_text(text: str) -> List[float]，该函数接收一个文本字符串作为参数，从文本中提取气温数据，并将其以列表的形式返回。文件中每行包含一个气温值，以摄氏度为单位。\n\n编写一个函数 calculate_average_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并计算出平均气温，并将其返回。\n\n编写一个函数 find_highest_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并找出其中的最高气温，并将其返回。\n\n编写一个函数 find_lowest_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并找出其中的最低气温，并将其返回。\n\n使用案例：\n\npython\ntext = \"\"\"\n北京，-4℃\n上海，3℃\n广州，12℃\n重庆，8℃\n\"\"\"\n\ntemperatures = extract_temperatures_from_text(text)\naverage_temp = calculate_average_temperature(temperatures)\nhighest_temp = find_highest_temperature(temperatures)\nlowest_temp = find_lowest_temperature(temperatures)\n\nprint(\"提取的气温数据:\", temperatures)\nprint(\"平均气温:\", average_temp)\nprint(\"最高气温:\", highest_temp)\nprint(\"最低气温:\", lowest_temp)\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testextract_temperatures_from_text:\n    def test_extract_temperatures_from_text_with_temperatures(self):\n        text = \"北京，-4℃\\n上海，3℃\\n广州，12℃\\n重庆，8℃\"\n        cities, temperatures = extract_temperatures_from_text(text)\n        assert cities == [\"北京\", \"上海\", \"广州\", \"重庆\"]\n        assert temperatures == [-4.0, 3.0, 12.0, 8.0]\n\n", "problem": "编写一个程序，完成题目：气象数据分析\n\n编写一个程序，实现对气温数据的分析和处理。\n\n要求：\n\n编写一个函数 extract_temperatures_from_text(text: str) -> List[float]，该函数接收一个文本字符串作为参数，从文本中提取气温数据，并将其以列表的形式返回。文件中每行包含一个气温值，以摄氏度为单位。\n\n编写一个函数 calculate_average_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并计算出平均气温，并将其返回。\n\n编写一个函数 find_highest_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并找出其中的最高气温，并将其返回。\n\n编写一个函数 find_lowest_temperature(temperatures: List[float]) -> float，该函数接收一个气温数据列表作为参数，并找出其中的最低气温，并将其返回。\n\n使用案例：\n\npython\ntext = \"\"\"\n北京，-4℃\n上海，3℃\n广州，12℃\n重庆，8℃\n\"\"\"\n\ntemperatures = extract_temperatures_from_text(text)\naverage_temp = calculate_average_temperature(temperatures)\nhighest_temp = find_highest_temperature(temperatures)\nlowest_temp = find_lowest_temperature(temperatures)\n\nprint(\"提取的气温数据:\", temperatures)\nprint(\"平均气温:\", average_temp)\nprint(\"最高气温:\", highest_temp)\nprint(\"最低气温:\", lowest_temp)", "testcases": "from typing import List, Tuple\n\n\nclass Testextract_temperatures_from_text:\n    def test_extract_temperatures_from_text_without_temperatures(self):\n        text = \"北京\\n上海\\n广州\\n重庆\"\n        cities, temperatures = extract_temperatures_from_text(text)\n        assert cities == []\n        assert temperatures == []\n\n    def test_calculate_average_temperature(self):\n        temperatures = [10.0, 20.0, 30.0]\n        assert calculate_average_temperature(temperatures) == 20.0\n\n    def test_find_highest_temperature(self):\n        cities = [\"北京\", \"上海\", \"广州\", \"重庆\"]\n        temperatures = [-4.0, 3.0, 12.0, 8.0]\n        assert find_highest_temperature(cities, temperatures) == (12.0, \"广州\")\n\n    def test_find_lowest_temperature(self):\n        cities = [\"北京\", \"上海\", \"广州\", \"重庆\"]\n        temperatures = [-4.0, 3.0, 12.0, 8.0]\n        assert find_lowest_temperature(cities, temperatures) == (-4.0, \"北京\")\n\n    def test_extract_temperatures_from_text_with_single_data(self):\n        text = \"北京，-4℃\"\n        cities, temperatures = extract_temperatures_from_text(text)\n        assert cities == [\"北京\"]\n        assert temperatures == [-4.0]\n\n    def test_extract_temperatures_from_text_with_cities_only(self):\n        text = \"北京\\n上海\\n广州\\n重庆\"\n        cities, temperatures = extract_temperatures_from_text(text)\n        assert cities == []\n        assert temperatures == []\n\n    def test_calculate_average_temperature_with_single_temperature(self):\n        temperatures = [10.0]\n        assert calculate_average_temperature(temperatures) == 10.0\n\n    def test_find_highest_temperature_with_single_temperature(self):\n        cities = [\"北京\"]\n        temperatures = [-4.0]\n        assert find_highest_temperature(cities, temperatures) == (-4.0, \"北京\")\n\n    def test_find_lowest_temperature_with_single_temperature(self):\n        cities = [\"北京\"]\n        temperatures = [-4.0]\n        assert find_lowest_temperature(cities, temperatures) == (-4.0, \"北京\")\n\n    def test_extract_temperatures_from_text_with_duplicate_temperatures(self):\n        text = \"北京，-4℃\\n上海，3℃\\n广州，12℃\\n重庆，8℃\\n成都，12℃\"\n        cities, temperatures = extract_temperatures_from_text(text)\n        assert cities == [\"北京\", \"上海\", \"广州\", \"重庆\", \"成都\"]\n        assert temperatures == [-4.0, 3.0, 12.0, 8.0, 12.0]\n\n    def test_extract_temperatures_from_text_with_decimal_temperatures(self):\n        text = \"北京，-4.5℃\\n上海，3.2℃\\n广州，12.7℃\\n重庆，8.9℃\"\n        cities, temperatures = extract_temperatures_from_text(text)\n        assert cities == [\"北京\", \"上海\", \"广州\", \"重庆\"]\n        assert temperatures == [-4.5, 3.2, 12.7, 8.9]\n\n", "setup_code": "", "reference_solution": "```python\nfrom typing import List, Tuple\n\n\ndef extract_temperatures_from_text(text: str) -> Tuple[List[str], List[float]]:\n    cities = []\n    temperatures = []\n    lines = text.strip().split('\\n')\n    for line in lines:\n        city_temperature = line.split('，')\n        if len(city_temperature) == 2:\n            city, temperature = city_temperature\n            temperature = float(temperature.replace('℃', ''))\n            cities.append(city)\n            temperatures.append(temperature)\n        else:\n            return [], []\n    return cities, temperatures\n\ndef calculate_average_temperature(temperatures: List[float]) -> float:\n    total_temperature = sum(temperatures)\n    average_temperature = total_temperature / len(temperatures)\n    return average_temperature\n\ndef find_highest_temperature(cities: List[str], temperatures: List[float]) -> Tuple[float, str]:\n    if not temperatures:\n        return 0, \"无\"\n    index = temperatures.index(max(temperatures))\n    highest_temperature = temperatures[index]\n    city = cities[index]\n    return highest_temperature, city\n\ndef find_lowest_temperature(cities: List[str], temperatures: List[float]) -> Tuple[float, str]:\n    if not temperatures:\n        return 0, \"无\"\n    index = temperatures.index(min(temperatures))\n    lowest_temperature = temperatures[index]\n    city = cities[index]\n    return lowest_temperature, city\n\n\n```", "classification": "数据科学"}
{"_id": 145, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，一个函数 count_html_tags(html)，该函数接受一个 HTML 字符串作为参数，并返回该字符串中包含的 HTML 标签的数量。\n\n要求：\n\nHTML 标签由尖括号 < 和 > 包围，标签名称位于尖括号内。\n标签名称由小写字母组成，不包含空格或其他特殊字符。\n假设输入的 HTML 字符串是有效的，不需要进行错误处理。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcount_html_tags:\n    def test_empty_string(self):\n        html = \"\"\n        tag_count, max_nested_depth = count_html_tags(html)\n        assert tag_count == 0\n        assert max_nested_depth == 0\n\n", "problem": "编写一个程序，一个函数 count_html_tags(html)，该函数接受一个 HTML 字符串作为参数，并返回该字符串中包含的 HTML 标签的数量。\n\n要求：\n\nHTML 标签由尖括号 < 和 > 包围，标签名称位于尖括号内。\n标签名称由小写字母组成，不包含空格或其他特殊字符。\n假设输入的 HTML 字符串是有效的，不需要进行错误处理。", "testcases": "import re\n\n\nclass Testcount_html_tags:\n    def test_single_tag(self):\n        html = \"<div></div>\"\n        tag_count, max_nested_depth = count_html_tags(html)\n        assert tag_count == 2\n        assert max_nested_depth == 1\n\n    def test_nested_tags(self):\n        html = \"<div><p><span></span></p></div>\"\n        tag_count, max_nested_depth = count_html_tags(html)\n        assert tag_count == 6\n        assert max_nested_depth == 3\n\n    def test_mismatched_closing_tag(self):\n        html = \"<div></span>\"\n        tag_count, max_nested_depth = count_html_tags(html)\n        assert tag_count == 1\n        assert max_nested_depth == 1\n\n    def test_case_sensitive(self):\n        html = \"<DIV><P><SPAN></span></P></div>\"\n        tag_count, max_nested_depth = count_html_tags(html)\n        assert tag_count == 6\n        assert max_nested_depth == 3\n\n    def test_special_characters(self):\n        html = \"<p>This is some text with &lt;strong&gt; tags.</p>\"\n        tag_count, max_nested_depth = count_html_tags(html)\n        assert tag_count == 2\n\n    def test_unbalanced_tags(self):\n        html = \"<div><p></div></p>\"\n        result = count_html_tags(html)\n        assert result == (3, 2)", "setup_code": "", "reference_solution": "```python\nimport re\n\n\ndef count_html_tags(html):\n    pattern = r'<\\s*([a-zA-Z]+)[^>]*>|<\\s*/\\s*([a-zA-Z]+)\\s*>'\n    matches = re.findall(pattern, html)\n\n    tag_count = 0\n    nested_tags = []\n    max_nested_depth = 0\n\n    for opening_tag, closing_tag in matches:\n        if opening_tag:\n            nested_tags.append(opening_tag.lower())\n            tag_count += 1\n            max_nested_depth = max(max_nested_depth, len(nested_tags))\n        elif nested_tags and nested_tags[-1] == closing_tag.lower():\n            nested_tags.pop()\n            tag_count += 1\n\n    return tag_count, max_nested_depth\n\n\n\n```", "classification": "前端开发"}
{"_id": 146, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，数据加密和解密的脚本，如encrypt 函数： 接受明文文本和密钥作为输入，使用AES算法的ECB模式进行加密。在加密前，会将明文文本的长度补全到AES块大小的倍数。加密结果以Base64编码的形式返回。\n\ndecrypt 函数： 接受密文和密钥作为输入，使用AES算法的ECB模式进行解密。解密后会去除可能添加的空格，然后返回解密后的明文。\n\nsave_to_file 函数： 接受数据和文件名作为输入，将数据写入指定文件。\n\nread_from_file 函数： 接受文件名作为输入，从指定文件中读取数据并返回。\n\n加密与解密演示： 使用示例文本 \"Hello, World!\" 和一个16字节的密钥进行加密。加密后的结果以Base64编码保存到文件 \"encrypted_data.txt\"。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestEncryption:\n    def test_encrypt_decrypt_with_fixture(self, encryption_key):\n        original_text = \"Hello, World!\"\n        encrypted_text = encrypt(original_text, encryption_key)\n        decrypted_text = decrypt(encrypted_text, encryption_key)\n        assert original_text == decrypted_text, \"Encryption and decryption failed.\"\n\n", "problem": "编写一个程序，数据加密和解密的脚本，如encrypt 函数： 接受明文文本和密钥作为输入，使用AES算法的ECB模式进行加密。在加密前，会将明文文本的长度补全到AES块大小的倍数。加密结果以Base64编码的形式返回。\n\ndecrypt 函数： 接受密文和密钥作为输入，使用AES算法的ECB模式进行解密。解密后会去除可能添加的空格，然后返回解密后的明文。\n\nsave_to_file 函数： 接受数据和文件名作为输入，将数据写入指定文件。\n\nread_from_file 函数： 接受文件名作为输入，从指定文件中读取数据并返回。\n\n加密与解密演示： 使用示例文本 \"Hello, World!\" 和一个16字节的密钥进行加密。加密后的结果以Base64编码保存到文件 \"encrypted_data.txt\"。", "testcases": "import os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport base64\n\n\nclass TestEncryption:\n    def test_save_and_read_from_file_with_fixture(self, encryption_key, tmp_path):\n        original_text = \"Testing file save and read functionality.\"\n        encrypted_text = encrypt(original_text, encryption_key)\n        file_path = tmp_path / \"test_file.txt\"\n\n        # Save encrypted text to file\n        save_to_file(encrypted_text, file_path)\n\n        # Read from file and decrypt\n        loaded_encrypted_text = read_from_file(file_path)\n        decrypted_text = decrypt(loaded_encrypted_text, encryption_key)\n\n        assert original_text == decrypted_text, \"File save and read failed.\"\n\n    def test_encrypt_empty_string_with_fixture(self, encryption_key):\n        original_text = \"\"\n        encrypted_text = encrypt(original_text, encryption_key)\n        decrypted_text = decrypt(encrypted_text, encryption_key)\n        assert original_text == decrypted_text, \"Encryption and decryption of empty string failed.\"\n\n    def test_decrypt_invalid_input_with_fixture(self, encryption_key):\n        invalid_encrypted_text = \"InvalidInput\"\n        with pytest.raises(Exception, match=\"The length of the provided data is not a multiple of the block length.\"):\n            decrypt(invalid_encrypted_text, encryption_key)\n\n    def test_decrypt_truncated_data_with_fixture(self, encryption_key, tmp_path):\n        original_text = \"Hello, World!\"\n        encrypted_text = encrypt(original_text, encryption_key)\n\n        # Truncate the encrypted data\n        truncated_encrypted_text = encrypted_text[:-5]\n\n        file_path = tmp_path / \"truncated_data.txt\"\n        save_to_file(truncated_encrypted_text, file_path)\n\n\n    def test_read_from_nonexistent_file_with_fixture(self, encryption_key, tmp_path):\n        nonexistent_file_path = tmp_path / \"nonexistent_file.txt\"\n        with pytest.raises(FileNotFoundError):\n            read_from_file(nonexistent_file_path)\n\n    @pytest.fixture\n    def encryption_key(self):\n        return b'Sixteen byte key'\n", "setup_code": "", "reference_solution": "```python\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport base64\n\n\ndef encrypt(text, key):\n    backend = default_backend()\n    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)\n    encryptor = cipher.encryptor()\n\n    # 补全文本长度至AES块大小的倍数\n    text = text + ' ' * (16 - len(text) % 16)\n\n    # 加密\n    ciphertext = encryptor.update(text.encode()) + encryptor.finalize()\n    return base64.b64encode(ciphertext).decode()\n\n\ndef decrypt(encrypted_text, key):\n    backend = default_backend()\n    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)\n    decryptor = cipher.decryptor()\n\n    # 解密\n    ciphertext = base64.b64decode(encrypted_text.encode())\n    decrypted_text = decryptor.update(ciphertext) + decryptor.finalize()\n    return decrypted_text.decode().rstrip()\n\n\ndef save_to_file(data, filename):\n    with open(filename, 'w') as file:\n        file.write(data)\n\n\ndef read_from_file(filename):\n    with open(filename, 'r') as file:\n        return file.read()\n\n\n\ntext_to_encrypt = \"Hello, World!\"\nencryption_key = b'Sixteen byte key'\n\n# # 加密并保存到文件\n# encrypted_text = encrypt(text_to_encrypt, encryption_key)\n# save_to_file(encrypted_text, \"encrypted_data.txt\")\n#\n# # 从文件中读取并解密\n# loaded_encrypted_text = read_from_file(\"encrypted_data.txt\")\n# decrypted_text = decrypt(loaded_encrypted_text, encryption_key)\n\n\n\n```", "classification": "软件工程"}
{"_id": 147, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个程序，接收一个文件夹路径作为输入，然后将该文件夹下的所有文件备份到指定的目标文件夹中，保留原始文件结构。例如backup_folder函数接收两个参数：源文件夹路径 (source_folder) 和目标文件夹路径 (target_folder)。在执行备份操作前，它会进行一系列检查：\n\n源文件夹检查： 首先，脚本会验证源文件夹是否存在，如果不存在则抛出异常并显示相应的错误消息。\n\n目标文件夹检查： 然后，它会检查目标文件夹是否存在。如果目标文件夹不存在，脚本会创建它。\n\n接下来，使用os.walk函数遍历源文件夹中的所有文件和子文件夹。对于每一个找到的文件和文件夹，脚本会进行以下操作：\n\n构建目标路径： 构建目标文件夹中的相对路径，并在目标文件夹中创建相应的子文件夹。\n\n文件复制： 使用shutil.copy2函数复制文件。该函数会保留文件的元数据，如创建时间和修改时间。\n\n最后，在完成备份后，脚本会输出备份成功的消息。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testbackup_folder:\n    def test_backup_successful(self, setup_test_folders):\n        source_folder, target_folder = setup_test_folders\n        assert source_folder.exists()\n        backup_folder(source_folder, target_folder)\n        assert target_folder.exists()\n\n", "problem": "编写一个程序，接收一个文件夹路径作为输入，然后将该文件夹下的所有文件备份到指定的目标文件夹中，保留原始文件结构。例如backup_folder函数接收两个参数：源文件夹路径 (source_folder) 和目标文件夹路径 (target_folder)。在执行备份操作前，它会进行一系列检查：\n\n源文件夹检查： 首先，脚本会验证源文件夹是否存在，如果不存在则抛出异常并显示相应的错误消息。\n\n目标文件夹检查： 然后，它会检查目标文件夹是否存在。如果目标文件夹不存在，脚本会创建它。\n\n接下来，使用os.walk函数遍历源文件夹中的所有文件和子文件夹。对于每一个找到的文件和文件夹，脚本会进行以下操作：\n\n构建目标路径： 构建目标文件夹中的相对路径，并在目标文件夹中创建相应的子文件夹。\n\n文件复制： 使用shutil.copy2函数复制文件。该函数会保留文件的元数据，如创建时间和修改时间。\n\n最后，在完成备份后，脚本会输出备份成功的消息。", "testcases": "import os\nimport shutil\n\n\nclass Testbackup_folder:\n    # 使用 fixture 的方式进行测试\n    def test_backup_empty_folder(self, tmp_path):\n        source_folder = tmp_path / \"empty_folder\"\n        target_folder = tmp_path / \"target_folder_empty\"\n        source_folder.mkdir()\n        assert source_folder.exists()\n        backup_folder(source_folder, target_folder)\n        assert target_folder.exists()\n        assert not os.listdir(target_folder)\n\n    def test_backup_with_subfolders(self, tmp_path):\n        source_folder = tmp_path / \"source_with_subfolders\"\n        target_folder = tmp_path / \"target_with_subfolders\"\n        (source_folder / \"subfolder\").mkdir(parents=True)\n        assert source_folder.exists()\n        backup_folder(source_folder, target_folder)\n        assert target_folder.exists()\n\n    def test_backup_existing_target_folder(self, tmp_path):\n        source_folder = tmp_path / \"source_folder\"\n        target_folder = tmp_path / \"target_folder\"\n        source_folder.mkdir()\n        target_folder.mkdir()\n        assert source_folder.exists()\n        assert target_folder.exists()\n        backup_folder(source_folder, target_folder)\n        assert target_folder.exists()\n\n    def test_backup_to_temporary_folder(self, tmp_path):\n        source_folder = tmp_path / \"source_folder\"\n        target_folder = tmp_path / \"target_folder_temp\"\n        source_folder.mkdir()\n        assert source_folder.exists()\n        backup_folder(source_folder, target_folder)\n        assert target_folder.exists()\n\n    def test_source_folder_contains_files(self, setup_test_folders):\n        source_folder, target_folder = setup_test_folders\n        # 在源文件夹中创建一些文件\n        file1 = source_folder / \"file1.txt\"\n        file2 = source_folder / \"subfolder\" / \"file2.txt\"\n        file1.write_text(\"这是文件1的内容。\")\n        file2.parent.mkdir(parents=True)\n        file2.write_text(\"这是文件2的内容。\")\n\n        assert file1.exists()\n        assert file2.exists()\n\n        backup_folder(source_folder, target_folder)\n\n        # 检查文件是否在目标文件夹中备份\n        assert (target_folder / \"file1.txt\").exists()\n        assert (target_folder / \"subfolder\" / \"file2.txt\").exists()\n\n    def test_backup_with_different_file_types(self, setup_test_folders):\n        source_folder, target_folder = setup_test_folders\n        # 在源文件夹中创建不同扩展名的文件\n        file_txt = source_folder / \"file.txt\"\n        file_csv = source_folder / \"data.csv\"\n        file_py = source_folder / \"script.py\"\n\n        file_txt.write_text(\"这是一个文本文件。\")\n        file_csv.write_text(\"CSV 数据在这里。\")\n        file_py.write_text(\"# Python 脚本内容。\")\n\n        assert file_txt.exists()\n        assert file_csv.exists()\n        assert file_py.exists()\n\n        backup_folder(source_folder, target_folder)\n\n        # 检查文件是否在目标文件夹中备份\n        assert (target_folder / \"file.txt\").exists()\n        assert (target_folder / \"data.csv\").exists()\n        assert (target_folder / \"script.py\").exists()\n\n\n    @pytest.fixture\n    def setup_test_folders(self, tmp_path):\n        source_folder = tmp_path / \"source_folder\"\n        target_folder = tmp_path / \"target_folder\"\n        source_folder.mkdir()\n        target_folder.mkdir()\n        yield source_folder, target_folder\n", "setup_code": "", "reference_solution": "```python\nimport os\nimport shutil\n\ndef backup_folder(source_folder, target_folder):\n    try:\n        # 检查源文件夹是否存在\n        if not os.path.exists(source_folder):\n            raise Exception(\"Source folder does not exist.\")\n\n        # 检查目标文件夹是否存在，如果不存在则创建\n        if not os.path.exists(target_folder):\n            os.makedirs(target_folder)\n\n        # 遍历源文件夹中的所有文件和子文件夹\n        for root, dirs, files in os.walk(source_folder):\n            # 构建目标文件夹中的相对路径\n            relative_path = os.path.relpath(root, source_folder)\n            target_path = os.path.join(target_folder, relative_path)\n\n            # 创建目标文件夹中的子文件夹\n            if not os.path.exists(target_path):\n                os.makedirs(target_path)\n\n            # 复制源文件夹中的所有文件到目标文件夹中\n            for file in files:\n                source_file = os.path.join(root, file)\n                target_file = os.path.join(target_path, file)\n                shutil.copy2(source_file, target_file)\n\n        print(\"Backup completed successfully.\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n```", "classification": "操作系统"}
{"_id": 148, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写Python 程序，用于文件和文件夹操作的程序，包括创建文件夹 (create_folder)、使用 open 函数以写入模式创建文件，并写入指定的内容、使用 open 函数以读取模式打开文件，并读取文件内容、复制文件 (copy_file)、移动文件 (move_file),和删除文件夹及其内容 (delete_folder)。例如,# 导入文件操作相关的模块\nimport os\nimport shutil\n\n# 创建文件夹\ncreate_folder('data')\n\n# 在 data 文件夹中创建并写入文件\ninfo_file_path = os.path.join('data', 'info.txt')\ncreate_and_write_file(info_file_path, \"Hello, this is some information.\")\n\n# 读取并打印文件内容\nread_and_print_file(info_file_path)\n\n# 复制文件为 info_backup.txt\ninfo_backup_path = os.path.join('data', 'info_backup.txt')\ncopy_file(info_file_path, info_backup_path)\n\n# 移动文件到 backup 文件夹中\ncreate_folder('backup')\ninfo_backup_new_path = os.path.join('backup', 'info_backup.txt')\nmove_file(info_backup_path, info_backup_new_path)\n\n# 删除 data 文件夹及其下的所有文件\ndelete_folder('data')\n导入os模块，和shutil模块\n程序创建一个文件夹（data）。\n在该文件夹中创建一个文件（info.txt）并写入一些信息。\n读取并打印文件的内容。\n复制文件为另一个文件（info_backup.txt）。\n移动文件到另一个文件夹（backup）中。\n删除原始文件夹（data）及其下的所有文件。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestFile_process:\n    def test_create_folder(self):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        create_folder(data_folder)\n        assert os.path.exists(data_folder)\n\n    # 测试用例2: 创建并写入文件\n", "problem": "编写Python 程序，用于文件和文件夹操作的程序，包括创建文件夹 (create_folder)、使用 open 函数以写入模式创建文件，并写入指定的内容、使用 open 函数以读取模式打开文件，并读取文件内容、复制文件 (copy_file)、移动文件 (move_file),和删除文件夹及其内容 (delete_folder)。例如,# 导入文件操作相关的模块\nimport os\nimport shutil\n\n# 创建文件夹\ncreate_folder('data')\n\n# 在 data 文件夹中创建并写入文件\ninfo_file_path = os.path.join('data', 'info.txt')\ncreate_and_write_file(info_file_path, \"Hello, this is some information.\")\n\n# 读取并打印文件内容\nread_and_print_file(info_file_path)\n\n# 复制文件为 info_backup.txt\ninfo_backup_path = os.path.join('data', 'info_backup.txt')\ncopy_file(info_file_path, info_backup_path)\n\n# 移动文件到 backup 文件夹中\ncreate_folder('backup')\ninfo_backup_new_path = os.path.join('backup', 'info_backup.txt')\nmove_file(info_backup_path, info_backup_new_path)\n\n# 删除 data 文件夹及其下的所有文件\ndelete_folder('data')\n导入os模块，和shutil模块\n程序创建一个文件夹（data）。\n在该文件夹中创建一个文件（info.txt）并写入一些信息。\n读取并打印文件的内容。\n复制文件为另一个文件（info_backup.txt）。\n移动文件到另一个文件夹（backup）中。\n删除原始文件夹（data）及其下的所有文件。", "testcases": "import os\nimport shutil\n\n\nclass TestFile_process:\n    # 测试用例1: 创建文件夹\n    def test_create_and_write_file(self):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        create_and_write_file(info_file_path, \"Test content\")\n        assert os.path.exists(info_file_path)\n\n    # 测试用例3: 读取并打印文件内容\n    def test_read_and_print_file(self, capsys):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        read_and_print_file(info_file_path)\n        captured = capsys.readouterr()\n        assert \"Test content\" in captured.out\n\n    # 测试用例4: 复制文件\n    def test_copy_file(self):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        copy_file(info_file_path, info_backup_path)\n        assert os.path.exists(info_backup_path)\n\n    # 测试用例：尝试移动已删除的文件\n    def test_move_deleted_file(self):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        # 创建 data 文件夹\n        create_folder(data_folder)\n\n        # 在 data 文件夹中创建 info.txt 文件\n        create_and_write_file(info_file_path, \"Hello, this is some information.\")\n\n        # 将文件移动到 backup 文件夹中\n        shutil.move(info_file_path, backup_folder)\n\n        # 使用 os.path.join 构建移动后的文件路径\n        moved_file_path = os.path.join(backup_folder, os.path.basename(info_file_path))\n\n        # 确保文件已成功移动\n        assert os.path.exists(moved_file_path)\n        assert not os.path.exists(info_file_path)\n\n    # 测试用例6: 删除文件夹\n    def test_delete_folder(self):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        delete_folder(data_folder)\n        assert not os.path.exists(data_folder)\n\n    # 测试用例7: 尝试读取已删除的文件\n    def test_read_deleted_folder(self, capsys):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        # 删除文件\n        os.remove(info_file_path)\n\n        # 尝试读取已删除的文件\n        with pytest.raises(FileNotFoundError):\n            read_and_print_file(info_file_path)\n\n        captured = capsys.readouterr()\n        assert \"FileNotFoundError\" != str(captured.err)\n\n    # 测试用例8: 尝试删除已删除的文件夹\n    def test_delete_deleted_folder(self):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        delete_folder(data_folder)\n        assert not os.path.exists(data_folder)\n\n        # 使用 os.path.exists 检查文件夹是否不存在\n        assert not os.path.exists(data_folder)\n\n    # 预先设置测试环境\n    @pytest.fixture(autouse=True)\n    def setup_teardown(self):\n        data_folder = 'data'\n        info_file_path = os.path.join(data_folder, 'info.txt')\n        backup_folder = 'backup'\n        info_backup_path = os.path.join(backup_folder, 'info_backup.txt')\n        create_folder(data_folder)\n        create_and_write_file(info_file_path, \"Test content\")\n        create_folder(backup_folder)\n\n        yield\n\n        # 清理测试环境\n        if os.path.exists(data_folder):\n            shutil.rmtree(data_folder)\n        if os.path.exists(backup_folder):\n            shutil.rmtree(backup_folder)\n\n", "setup_code": "", "reference_solution": "```python\nimport os\nimport shutil\n\ndef create_folder(folder_name):\n    if not os.path.exists(folder_name):\n        os.makedirs(folder_name)\n        print(f'Folder {folder_name} created.')\n\ndef create_and_write_file(file_path, content):\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(content)\n        print(f'File {file_path} created and written.')\n\ndef read_and_print_file(file_path):\n    with open(file_path, 'r', encoding='utf-8') as file:\n        content = file.read()\n        print(f'Contents of {file_path}:')\n        print(content)\n\ndef copy_file(source_path, destination_path):\n    shutil.copy(source_path, destination_path)\n    print(f'File {source_path} copied to {destination_path}.')\n\ndef move_file(source_path, destination_path):\n    shutil.move(source_path, destination_path)\n    print(f'File {source_path} moved to {destination_path}.')\n\ndef delete_folder(folder_name):\n    shutil.rmtree(folder_name)\n    print(f'Folder {folder_name} and its contents deleted.')\n\n```", "classification": "操作系统"}
{"_id": 149, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写Python程序，该程序接受一个文本字符串作为输入，并使用正则表达式模式来提取其中的电话号码。\\n\\n使用 re.compile 创建了一个正则表达式模式，用于匹配电话号码。\n定义了一个名为 extract_phone_numbers 的函数，表达式：\\(? 匹配可选的左括号，\\b 表示单词边界，(\\d{3}) 匹配三个数字作为区号，[-.\\s]? 匹配可选的分隔符（包括破折号、点或空格），(\\d{3}) 匹配三个数字作为中间部分，同样匹配可选的分隔符，(\\d{4}) 匹配四个数字作为结尾，\\b 表示单词边界。\n定义一个finditer 方法，使用 pattern.finditer(text) 调用 finditer 方法，返回一个迭代器，该迭代器包含匹配模式的所有对象。\n提取和格式化电话号码：\n遍历 matches 迭代器中的每个匹配对象。\n对于每个匹配对象，使用 match.groups() 获取匹配组，即区号、中间部分和结尾。\n使用这些组件格式化电话号码为 \"(XXX) YYY-ZZZZ\" 的形式。\n结果存储：\n将格式化的电话号码添加到 phone_numbers 列表中。\n返回包含所有提取电话号码的列表。例如,example_text = \"\"\"\nContact List:\n- Alice: (123) 456-7890\n- Bob: 987-654-3210\n- Charlie: (555) 123-4567\n- David: 123.456.7890\n\"\"\"\n\n# 提取电话号码\nphone_numbers = extract_phone_numbers(example_text)\n\n# 打印提取到的电话号码\nprint(\"Extracted Phone Numbers:\")\nfor number in phone_numbers:\n    print(number)这个示例中，example_text 包含了一些不同格式的电话号码。extract_phone_numbers 函数被调用来提取并格式化这些电话号码，然后提取电话号码，打印出来。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testextract_phone_numbers:\n    def test_valid_format_with_parentheses(self):\n        text = \"联系我们：(123) 456-7890 或者 123-456-7890。\"\n        result = extract_phone_numbers(text)\n        assert result == ['(123) 456-7890', '(123) 456-7890']\n\n", "problem": "编写Python程序，该程序接受一个文本字符串作为输入，并使用正则表达式模式来提取其中的电话号码。\\n\\n使用 re.compile 创建了一个正则表达式模式，用于匹配电话号码。\n定义了一个名为 extract_phone_numbers 的函数，表达式：\\(? 匹配可选的左括号，\\b 表示单词边界，(\\d{3}) 匹配三个数字作为区号，[-.\\s]? 匹配可选的分隔符（包括破折号、点或空格），(\\d{3}) 匹配三个数字作为中间部分，同样匹配可选的分隔符，(\\d{4}) 匹配四个数字作为结尾，\\b 表示单词边界。\n定义一个finditer 方法，使用 pattern.finditer(text) 调用 finditer 方法，返回一个迭代器，该迭代器包含匹配模式的所有对象。\n提取和格式化电话号码：\n遍历 matches 迭代器中的每个匹配对象。\n对于每个匹配对象，使用 match.groups() 获取匹配组，即区号、中间部分和结尾。\n使用这些组件格式化电话号码为 \"(XXX) YYY-ZZZZ\" 的形式。\n结果存储：\n将格式化的电话号码添加到 phone_numbers 列表中。\n返回包含所有提取电话号码的列表。例如,example_text = \"\"\"\nContact List:\n- Alice: (123) 456-7890\n- Bob: 987-654-3210\n- Charlie: (555) 123-4567\n- David: 123.456.7890\n\"\"\"\n\n# 提取电话号码\nphone_numbers = extract_phone_numbers(example_text)\n\n# 打印提取到的电话号码\nprint(\"Extracted Phone Numbers:\")\nfor number in phone_numbers:\n    print(number)这个示例中，example_text 包含了一些不同格式的电话号码。extract_phone_numbers 函数被调用来提取并格式化这些电话号码，然后提取电话号码，打印出来。", "testcases": "import re\n\n\nclass Testextract_phone_numbers:\n    def test_valid_format_with_dashes_and_dots(self):\n        text = \"请拨打电话：123.456.7890 或者 987-654-3210。\"\n        result = extract_phone_numbers(text)\n        assert result == ['(123) 456-7890', '(987) 654-3210']\n\n    def test_no_phone_numbers(self):\n        text = \"这段文本中没有电话号码。\"\n        result = extract_phone_numbers(text)\n        assert result == []\n\n    def test_invalid_format_should_not_match(self):\n        text = \"无效的号码 (123) 45-67890 不应匹配。\"\n        result = extract_phone_numbers(text)\n        assert result == []\n\n    def test_another_invalid_format_should_not_match(self):\n        text = \"另一个无效的号码 1234-567-890 不应匹配。\"\n        result = extract_phone_numbers(text)\n        assert result == []\n\n    def test_incomplete_number_should_not_match(self):\n        text = \"不完整的号码 (123) 456 不应匹配。\"\n        result = extract_phone_numbers(text)\n        assert result == []\n\n    def test_valid_number_with_extra_text(self):\n        text = \"有效号码 111-222-3333 附带额外文本。\"\n        result = extract_phone_numbers(text)\n        assert result == ['(111) 222-3333']\n\n    def test_multiple_valid_numbers(self):\n        text = \"多个有效号码：(111) 222-3333 和 444.555.6666。\"\n        result = extract_phone_numbers(text)\n        assert result == ['(111) 222-3333', '(444) 555-6666']\n", "setup_code": "", "reference_solution": "```python\nimport re\n\n\ndef extract_phone_numbers(text):\n    # 电话号码的正则表达式模式\n    pattern = re.compile(r'\\(?\\b(\\d{3})\\)?[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})\\b')\n\n    # 使用 finditer 方法提取所有匹配的电话号码\n    matches = pattern.finditer(text)\n\n    # 存储提取到的电话号码\n    phone_numbers = []\n\n    for match in matches:\n        # 获取匹配对象的匹配组\n        groups = match.groups()\n\n        # 格式化提取到的电话号码\n        formatted_number = f\"({groups[0]}) {groups[1]}-{groups[2]}\"\n\n        # 添加到结果列表\n        phone_numbers.append(formatted_number)\n\n    return phone_numbers\n\n\n```", "classification": "软件工程"}
{"_id": 150, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个名为 find_max_eigenvalues 的 Python 程序，计算一个二位矩阵的最大特征值及对应的特征向量。输入参数包括一个二维数组 matrix 和一个可选参数 `num_largest`（默认值为 5），用于指定要提取的最大特征值的数量。程序返回两个列表，第一个列表为特征值列表，第二个列表为对应的特征向量列表。程序使用 NumPy 和 SciPy 库进行计算。如果输入矩阵为空或格式不正确，程序将抛出 ValueError。例如，对于输入矩阵：[[1, 2, 3], [4, 5, 6], [7, 8, 9]],以及 `num_largest` 设为 2，程序应返回以下结果：特征值列表：[18.8302358, -0.67276795]，对应的特征向量列表：[[-0.40962667, -0.54264865, -0.73330651], [0.43402538, -0.82296167, 0.36654613]]。这里，第一个特征向量 [-0.40962667, -0.54264865, -0.73330651] 对应于最大特征值 18.8302358，而第二个特征向量 [0.43402538, -0.82296167, 0.36654613] 对应于第二大特征值 -0.67276795。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcalculate_eigen:\n    def test_calculate_eigen_default(self):\n        test_matrix = np.array([[1, 2, 3, 4, 5],\n                                [6, 7, 8, 9, 10],\n                                [11, 12, 13, 14, 15],\n                                [16, 17, 18, 19, 20],\n                                [21, 22, 23, 24, 25]])\n\n        largest_eigenvalues, largest_eigenvectors = calculate_eigen(test_matrix)\n        assert len(largest_eigenvalues) == 5\n        assert largest_eigenvalues[0] < largest_eigenvalues[-1]\n\n", "problem": "编写一个名为 find_max_eigenvalues 的 Python 程序，计算一个二位矩阵的最大特征值及对应的特征向量。输入参数包括一个二维数组 matrix 和一个可选参数 `num_largest`（默认值为 5），用于指定要提取的最大特征值的数量。程序返回两个列表，第一个列表为特征值列表，第二个列表为对应的特征向量列表。程序使用 NumPy 和 SciPy 库进行计算。如果输入矩阵为空或格式不正确，程序将抛出 ValueError。例如，对于输入矩阵：[[1, 2, 3], [4, 5, 6], [7, 8, 9]],以及 `num_largest` 设为 2，程序应返回以下结果：特征值列表：[18.8302358, -0.67276795]，对应的特征向量列表：[[-0.40962667, -0.54264865, -0.73330651], [0.43402538, -0.82296167, 0.36654613]]。这里，第一个特征向量 [-0.40962667, -0.54264865, -0.73330651] 对应于最大特征值 18.8302358，而第二个特征向量 [0.43402538, -0.82296167, 0.36654613] 对应于第二大特征值 -0.67276795。", "testcases": "import numpy as np\nfrom scipy.linalg import eig\n\n\nclass Testcalculate_eigen:\n    def test_calculate_eigen_custom(self):\n        test_matrix = np.array([[1, 2, 3, 4, 5],\n                                [6, 7, 8, 9, 10],\n                                [11, 12, 13, 14, 15],\n                                [16, 17, 18, 19, 20],\n                                [21, 22, 23, 24, 25]])\n\n        largest_eigenvalues, largest_eigenvectors = calculate_eigen(test_matrix, num_largest=3)\n        assert len(largest_eigenvalues) == 3\n        assert largest_eigenvalues[0] < largest_eigenvalues[-1]\n\n    def test_calculate_eigen_non_square_matrix(self):\n        non_square_matrix = np.array([[1, 2, 3], [4, 5, 6]])\n        with pytest.raises(ValueError):\n            calculate_eigen(non_square_matrix)\n\n    def test_calculate_eigen_empty_matrix(self):\n        empty_matrix = np.array([])\n        with pytest.raises(ValueError):\n            calculate_eigen(empty_matrix)\n\n    def test_calculate_eigen_large_matrix(self):\n        large_matrix = np.random.rand(100, 100)\n        largest_eigenvalues, _ = calculate_eigen(large_matrix, num_largest=10)\n        assert len(largest_eigenvalues) == 10\n        assert largest_eigenvalues[0] < largest_eigenvalues[-1]\n\n    def test_calculate_eigen_negative_values(self):\n        negative_matrix = np.array([[1, -2, 3], [-4, 5, -6], [7, -8, 9]])\n        largest_eigenvalues, _ = calculate_eigen(negative_matrix)\n        assert np.all(np.real(largest_eigenvalues) != 0)\n", "setup_code": "", "reference_solution": "```python\nimport numpy as np\nfrom scipy.linalg import eig\n\n\ndef calculate_eigen(matrix, num_largest=5):\n    # 计算特征值和特征向量\n    eigenvalues, eigenvectors = eig(matrix)\n\n    # 找到最大的几个特征值及其对应的索引\n    largest_indices = np.argsort(eigenvalues)[-num_largest:]\n\n    # 提取最大的几个特征值和对应的特征向量\n    largest_eigenvalues = eigenvalues[largest_indices]\n    largest_eigenvectors = eigenvectors[:, largest_indices]\n\n    return largest_eigenvalues, largest_eigenvectors\n\n```", "classification": "数据科学"}
{"_id": 151, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写python程序，用于将嵌套列表展平成一维列表。定义一个flatten_list 函数，将嵌套列表展平为一维列表,返回值是flattened_list展平后的一维列表\\n创建一个空列表 flattened_list 用于存储展平后的元素。\n创建一个栈 stack，并将初始的嵌套列表 nested_list 推入栈中。\n使用循环迭代，直到栈为空。\n在每次迭代中，从栈中弹出当前列表 current。\n对于 current 中的每个元素，检查其类型：\n如果是列表，则将该列表推入栈中，以便后续展平。\n如果不是列表，则将该元素添加到 flattened_list 中。\n循环继续，直到栈为空，最终得到展平后的列表。\n返回展平后的列表 flattened_list。例如,# 定义嵌套列表\nnested_list = [1, [2, 3, [4, 5]], 6, [7, [8, 9]]]\n\n# 使用 flatten_list 函数展开列表\nflattened_list = flatten_list(nested_list)\n\n# 打印展开后的结果\nprint(flattened_list)\n在这个示例中，nested_list 包含了嵌套的子列表。通过调用 flatten_list 函数，将其展开成一维列表 flattened_list。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testflatten_list:\n    def test_flatten_list_empty(self):\n        assert flatten_list([]) == []\n\n", "problem": "编写python程序，用于将嵌套列表展平成一维列表。定义一个flatten_list 函数，将嵌套列表展平为一维列表,返回值是flattened_list展平后的一维列表\\n创建一个空列表 flattened_list 用于存储展平后的元素。\n创建一个栈 stack，并将初始的嵌套列表 nested_list 推入栈中。\n使用循环迭代，直到栈为空。\n在每次迭代中，从栈中弹出当前列表 current。\n对于 current 中的每个元素，检查其类型：\n如果是列表，则将该列表推入栈中，以便后续展平。\n如果不是列表，则将该元素添加到 flattened_list 中。\n循环继续，直到栈为空，最终得到展平后的列表。\n返回展平后的列表 flattened_list。例如,# 定义嵌套列表\nnested_list = [1, [2, 3, [4, 5]], 6, [7, [8, 9]]]\n\n# 使用 flatten_list 函数展开列表\nflattened_list = flatten_list(nested_list)\n\n# 打印展开后的结果\nprint(flattened_list)\n在这个示例中，nested_list 包含了嵌套的子列表。通过调用 flatten_list 函数，将其展开成一维列表 flattened_list。", "testcases": "\n\nclass Testflatten_list:\n    def test_flatten_list_single_level(self):\n        input_nested_list = [1, 2, 3, 4]\n        assert flatten_list(input_nested_list) == [1, 2, 3, 4]\n\n    def test_flatten_list_nested(self):\n        input_nested_list = [[1, 2, [3, 4]], [5, [6, 7]]]\n        assert flatten_list(input_nested_list) == [5, 6, 7, 1, 2, 3, 4]\n\n    def test_flatten_list_nested_empty(self):\n        input_nested_list = [[], [1, [2, 3], []], []]\n        assert flatten_list(input_nested_list) == [1, 2, 3]\n\n    def test_flatten_list_nested_strings(self):\n        input_nested_list = [['a', 'b', ['c', 'd']], ['e', ['f', 'g']]]\n        assert flatten_list(input_nested_list) == ['e', 'f', 'g', 'a', 'b', 'c', 'd']\n\n    def test_flatten_list_mixed_types(self):\n        input_nested_list = [1, 'a', [2, 'b', [3, 'c']], [4, 'd']]\n        assert flatten_list(input_nested_list) == [1, 'a', 4, 'd', 2, 'b', 3, 'c']\n\n    def test_flatten_list_nested_floats(self):\n        input_nested_list = [1.0, [2.5, [3.2, 4.8]], 5.6, [7.3, [8.1, 9.0]]]\n        assert flatten_list(input_nested_list) == [1.0, 5.6, 7.3, 8.1, 9.0, 2.5, 3.2, 4.8]\n\n    def test_flatten_list_nested_booleans(self):\n        input_nested_list = [True, [False, [True, False]], True, [False, True]]\n        assert flatten_list(input_nested_list) == [True, True, False, True, False, True, False]\n", "setup_code": "", "reference_solution": "```python\ndef flatten_list(nested_list):\n    flattened_list = []\n    stack = [nested_list]\n\n    while stack:\n        current = stack.pop()\n\n        for element in current:\n            if isinstance(element, list):\n                stack.append(element)\n            else:\n                flattened_list.append(element)\n\n    return flattened_list\n\n\n```", "classification": "算法和数据结构"}
{"_id": 152, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\ntxt文件中的列表元素是使用制表符进行分隔的，把里面的内容转换成excel表格,\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testtxt2excle:\n    def test_txt2excle_1(self, tmp_path):\n        file_path = tmp_path / \"test1.txt\"\n        file_path.write_text(\"1\\t2\\t3\\n4\\t5\\t6\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A1'].value == '1'\n        assert sheet['B1'].value == '2'\n        assert sheet['C1'].value == '3'\n        assert sheet['A2'].value == '4'\n        assert sheet['B2'].value == '5'\n        assert sheet['C2'].value == '6'\n\n", "problem": "txt文件中的列表元素是使用制表符进行分隔的，把里面的内容转换成excel表格,", "testcases": "import openpyxl\n\nclass Testtxt2excle:\n    def test_txt2excle_2(self, tmp_path):\n        file_path = tmp_path / \"test2.txt\"\n        file_path.write_text(\"apple\\tbanana\\tcherry\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A1'].value == 'apple'\n        assert sheet['B1'].value == 'banana'\n        assert sheet['C1'].value == 'cherry'\n\n    def test_txt2excle_3(self, tmp_path):\n        file_path = tmp_path / \"test3.txt\"\n        file_path.write_text(\"100\\t200\\t300\\t400\\t500\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A1'].value == '100'\n        assert sheet['B1'].value == '200'\n        assert sheet['C1'].value == '300'\n        assert sheet['D1'].value == '400'\n        assert sheet['E1'].value == '500'\n\n    def test_txt2excle_4(self, tmp_path):\n        file_path = tmp_path / \"test4.txt\"\n        file_path.write_text(\"a\\tb\\tc\\nd\\te\\tf\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A1'].value == 'a'\n        assert sheet['B1'].value == 'b'\n        assert sheet['C1'].value == 'c'\n        assert sheet['A2'].value == 'd'\n        assert sheet['B2'].value == 'e'\n        assert sheet['C2'].value == 'f'\n\n    def test_txt2excle_5(self, tmp_path):\n        file_path = tmp_path / \"test5.txt\"\n        file_path.write_text(\"1.1\\t2.2\\t3.3\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A1'].value == '1.1'\n        assert sheet['B1'].value == '2.2'\n        assert sheet['C1'].value == '3.3'\n\n    def test_txt2excle_6(self, tmp_path):\n        file_path = tmp_path / \"test6.txt\"\n        file_path.write_text(\"True\\tFalse\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A1'].value == 'True'\n        assert sheet['B1'].value == 'False'\n\n    def test_txt2excle_7(self, tmp_path):\n        file_path = tmp_path / \"test7.txt\"\n        file_path.write_text(\"\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A1'].value == None\n\n    def test_txt2excle_8(self, tmp_path):\n        file_path = tmp_path / \"test8.txt\"\n        file_path.write_text(\"\\t\\t\\t\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A1'].value == None\n        assert sheet['B1'].value == None\n        assert sheet['C1'].value == None\n\n    def test_txt2excle_9(self, tmp_path):\n        file_path = tmp_path / \"test9.txt\"\n        file_path.write_text(\"a\\tb\\tc\\nd\\te\\tf\\ng\\th\\ti\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A3'].value == 'g'\n        assert sheet['B3'].value == 'h'\n        assert sheet['C3'].value == 'i'\n\n    def test_txt2excle_10(self, tmp_path):\n        file_path = tmp_path / \"test10.txt\"\n        file_path.write_text(\"1\\t2\\t3\\n4\\t5\\t6\\n7\\t8\\t9\")\n        txt2excle(file_path)\n        workbook = openpyxl.load_workbook('output.xlsx')\n        sheet = workbook.active\n        assert sheet['A3'].value == '7'\n        assert sheet['B3'].value == '8'\n        assert sheet['C3'].value == '9'", "setup_code": "", "reference_solution": "```python\nimport openpyxl\n# 打开txt文件\n\ndef txt2excle(file_path):\n    with open(file_path, 'r') as file:\n        lines = file.readlines()\n\n    # 创建Excel工作簿\n    workbook = openpyxl.Workbook()\n    sheet = workbook.active\n\n    # 将列表数据写入Excel工作表\n    for row, line in enumerate(lines, start=1):\n        # 假设列表中的元素使用逗号进行分隔\n        elements = line.strip().split('\\t')\n        for col, element in enumerate(elements, start=1):\n            sheet.cell(row=row, column=col).value = element\n\n    # 保存为Excel文件\n    workbook.save('output.xlsx')\n\n```", "classification": "数据科学"}
{"_id": 153, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n用python,标签数据采用VOC格式，实现在给定区域内将IoU大于0.2的真实框标签划分为类别0,\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testconvert_labels:\n    def test_convert_labels_1(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"label.xml\"\n        p.write_text('<annotation><object><bndbox><xmin>950</xmin><ymin>786</ymin><xmax>1400</xmax><ymax>1052</ymax></bndbox><name>1</name></object></annotation>')\n        convert_labels(str(p), (950,786,1400,1052))\n        tree = ET.parse(str(p))\n        root = tree.getroot()\n        assert root.find('object').find('name').text == '0'\n\n", "problem": "用python,标签数据采用VOC格式，实现在给定区域内将IoU大于0.2的真实框标签划分为类别0,", "testcases": "import xml.etree.ElementTree as ET\n\n\nclass Testconvert_labels:\n    def test_convert_labels_2(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"label.xml\"\n        p.write_text('<annotation><object><bndbox><xmin>0</xmin><ymin>0</ymin><xmax>2</xmax><ymax>2</ymax></bndbox><name>1</name></object></annotation>')\n        convert_labels(str(p), (1,1,3,3))\n        tree = ET.parse(str(p))\n        root = tree.getroot()\n        assert root.find('object').find('name').text == '0'\n\n    def test_convert_labels_3(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"label.xml\"\n        p.write_text('<annotation><object><bndbox><xmin>0</xmin><ymin>0</ymin><xmax>2</xmax><ymax>2</ymax></bndbox><name>1</name></object></annotation>')\n        convert_labels(str(p), (2,2,4,4))\n        tree = ET.parse(str(p))\n        root = tree.getroot()\n        assert root.find('object').find('name').text == '1'\n\n    def test_convert_labels_4(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"label.xml\"\n        p.write_text('<annotation><object><bndbox><xmin>0</xmin><ymin>0</ymin><xmax>2</xmax><ymax>2</ymax></bndbox><name>1</name></object></annotation>')\n        convert_labels(str(p), (0,0,2,2))\n        tree = ET.parse(str(p))\n        root = tree.getroot()\n        assert root.find('object').find('name').text == '0'\n\n    def test_convert_labels_5(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"label.xml\"\n        p.write_text('<annotation><object><bndbox><xmin>1000</xmin><ymin>800</ymin><xmax>1300</xmax><ymax>1000</ymax></bndbox><name>1</name></object></annotation>')\n        convert_labels(str(p), (950,786,1400,1052))\n        tree = ET.parse(str(p))\n        root = tree.getroot()\n        assert root.find('object').find('name').text == '0'\n\n    def test_convert_labels_6(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"label.xml\"\n        p.write_text('<annotation><object><bndbox><xmin>900</xmin><ymin>750</ymin><xmax>1450</xmax><ymax>1100</ymax></bndbox><name>1</name></object></annotation>')\n        convert_labels(str(p), (950,786,1400,1052))\n        tree = ET.parse(str(p))\n        root = tree.getroot()\n        assert root.find('object').find('name').text == '0'\n\n    def test_convert_labels_7(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"label.xml\"\n        p.write_text('<annotation><object><bndbox><xmin>950</xmin><ymin>786</ymin><xmax>1400</xmax><ymax>1052</ymax></bndbox><name>2</name></object></annotation>')\n        convert_labels(str(p), (950,786,1400,1052))\n        tree = ET.parse(str(p))\n        root = tree.getroot()\n        assert root.find('object').find('name').text == '0'", "setup_code": "", "reference_solution": "```python\nimport xml.etree.ElementTree as ET\n \ndef calculate_iou(box1, box2):\n    \"\"\"\n    计算两个边界框之间的IoU\n    \"\"\"\n    x1, y1, x2, y2 = box1\n    x3, y3, x4, y4 = box2\n\n    # 计算相交矩形的左上角和右下角坐标\n    inter_x1 = max(x1, x3)\n    inter_y1 = max(y1, y3)\n    inter_x2 = min(x2, x4)\n    inter_y2 = min(y2, y4)\n\n    # 计算相交矩形的面积\n    inter_area = max(0, inter_x2 - inter_x1 + 1) * max(0, inter_y2 - inter_y1 + 1)\n\n    # 计算并集面积和IoU\n    box1_area = (x2 - x1 + 1) * (y2 - y1 + 1)\n    box2_area = (x4 - x3 + 1) * (y4 - y3 + 1)\n    union_area = box1_area + box2_area - inter_area\n    iou = inter_area / union_area\n\n    return iou\n\ndef convert_labels(label_file, target_region):\n    \"\"\"\n    将在目标区域内与真实框标签的IoU大于0.2的所有框标签划分为类别0\n    \"\"\"\n    tree = ET.parse(label_file)\n    root = tree.getroot()\n\n    for object_elem in root.findall('object'):\n        bbox = object_elem.find('bndbox')\n        xmin = int(bbox.find('xmin').text)\n        ymin = int(bbox.find('ymin').text)\n        xmax = int(bbox.find('xmax').text)\n        ymax = int(bbox.find('ymax').text)\n\n        # 计算当前边界框与目标区域的IoU\n        iou = calculate_iou(target_region, (xmin, ymin, xmax, ymax))\n\n        # 如果IoU大于0.2，则将类别设置为0\n        if iou > 0.2:\n            object_elem.find('name').text = '0'\n\n    tree.write(label_file)\n\n```", "classification": "人工智能"}
{"_id": 154, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n图像分类数据集进行训练集、测试集和验证集的划分，随机种子定在42。\n输入是图像文件夹路径，划分训练集、测试集和验证集的比例\n输出是训练集、测试集和验证集的文件夹, 输出的文件夹直接放在数据集目录下\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testsplit_data:\n    def test_split_data_1(self):\n        dataset_path = 'test1'\n        file_num = len(os.listdir(dataset_path))\n        train_ratio = 0.7\n        test_ratio = 0.2\n        val_ratio = 0.1\n        split_data(dataset_path,train_ratio,test_ratio,val_ratio)\n        assert len(os.listdir(os.path.join(dataset_path,'train'))) == file_num * train_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'test'))) == file_num * test_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'val'))) == file_num * val_ratio\n\n", "problem": "图像分类数据集进行训练集、测试集和验证集的划分，随机种子定在42。\n输入是图像文件夹路径，划分训练集、测试集和验证集的比例\n输出是训练集、测试集和验证集的文件夹, 输出的文件夹直接放在数据集目录下", "testcases": "import os\nimport random\nimport shutil\n\nclass Testsplit_data:\n    def test_split_data_2(self):\n        dataset_path = 'test2'\n        file_num = len(os.listdir(dataset_path))\n        train_ratio = 1\n        test_ratio = 0\n        val_ratio = 0\n        split_data(dataset_path,train_ratio,test_ratio,val_ratio)\n        assert len(os.listdir(os.path.join(dataset_path, 'train'))) == file_num * train_ratio\n        assert len(os.listdir(os.path.join(dataset_path, 'test'))) == file_num * test_ratio\n        assert len(os.listdir(os.path.join(dataset_path, 'val'))) == file_num * val_ratio\n\n    def test_split_data_3(self):\n        dataset_path = 'test3'\n        file_num = len(os.listdir(dataset_path))\n        train_ratio = 0\n        test_ratio = 1\n        val_ratio = 0\n        split_data(dataset_path,train_ratio,test_ratio,val_ratio)\n        assert len(os.listdir(os.path.join(dataset_path,'train'))) == file_num * train_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'test'))) == file_num * test_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'val'))) == file_num * val_ratio\n\n    def test_split_data_4(self):\n        dataset_path = 'test4'\n        file_num = len(os.listdir(dataset_path))\n        train_ratio = 0\n        test_ratio = 0\n        val_ratio = 1\n        split_data(dataset_path,train_ratio,test_ratio,val_ratio)\n        assert len(os.listdir(os.path.join(dataset_path,'train'))) == file_num * train_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'test'))) == file_num * test_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'val'))) == file_num * val_ratio\n\n    def test_split_data_5(self):\n        dataset_path = 'test5'\n        file_num = len(os.listdir(dataset_path))\n        train_ratio = 0.6\n        test_ratio = 0.3\n        val_ratio = 0.1\n        split_data(dataset_path,train_ratio,test_ratio,val_ratio)\n        assert len(os.listdir(os.path.join(dataset_path,'train'))) == file_num * train_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'test'))) == file_num * test_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'val'))) == file_num * val_ratio\n\n    def test_split_data_6(self):\n        dataset_path = 'test6'\n        file_num = len(os.listdir(dataset_path))\n        train_ratio = 0.6\n        test_ratio = 0.2\n        val_ratio = 0.2\n        split_data(dataset_path,train_ratio,test_ratio,val_ratio)\n        assert len(os.listdir(os.path.join(dataset_path,'train'))) == file_num * train_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'test'))) == file_num * test_ratio\n        assert len(os.listdir(os.path.join(dataset_path,'val'))) == file_num * val_ratio\n", "setup_code": "", "reference_solution": "```python\nimport os\nimport random\nimport shutil\n\n\ndef split_data(dataset_path,train_ratio,test_ratio,val_ratio):\n    # 设置随机种子\n    random_seed = 42\n    random.seed(random_seed)\n    train_path = os.path.join(dataset_path,'train')\n    test_path = os.path.join(dataset_path,'test')\n    val_path = os.path.join(dataset_path,'val')\n\n    if not os.path.exists(train_path):\n        os.makedirs(train_path)\n\n    if not os.path.exists(test_path):\n        os.makedirs(test_path)\n\n    if not os.path.exists(val_path):\n        os.makedirs(val_path)\n\n    image_files = [f for f in os.listdir(dataset_path) if f.endswith('.jpg')]\n\n    # 随机打乱图像文件列表\n    random.shuffle(image_files)\n\n    # 计算划分的索引位置\n    train_split = int(len(image_files) * train_ratio)\n    test_split = int(len(image_files) * (train_ratio + test_ratio))\n\n    # 划分训练集\n    train_files = image_files[:train_split]\n    for file in train_files:\n        src_path = os.path.join(dataset_path, file)\n        dest_path = os.path.join(train_path, file)\n        shutil.copy(src_path, dest_path)\n\n    # 划分测试集\n    test_files = image_files[train_split:test_split]\n    for file in test_files:\n        src_path = os.path.join(dataset_path, file)\n        dest_path = os.path.join(test_path, file)\n        shutil.copy(src_path, dest_path)\n\n    # 划分验证集\n    val_files = image_files[test_split:]\n    for file in val_files:\n        src_path = os.path.join(dataset_path, file)\n        dest_path = os.path.join(val_path, file)\n        shutil.copy(src_path, dest_path)\n\n\n# import os\n# import shutil\n# from sklearn.model_selection import train_test_split\n\n\n# def split_data(dataset_path, train_ratio, test_ratio, val_ratio):\n#     # 获取所有文件的路径\n#     files = [os.path.join(dataset_path, f) for f in os.listdir(dataset_path) if\n#              os.path.isfile(os.path.join(dataset_path, f))]\n#\n#     # 划分训练集和其余部分\n#     train_files, rest_files = train_test_split(files, train_size=train_ratio, random_state=42)\n#\n#     # 计算测试集的比例\n#     test_ratio_adjusted = test_ratio / (1 - train_ratio)\n#\n#     # 划分测试集和验证集\n#     test_files, val_files = train_test_split(rest_files, test_size=test_ratio_adjusted, random_state=42)\n#\n#     # 创建训练集、测试集和验证集的文件夹\n#     train_dir = os.path.join(dataset_path, 'train')\n#     test_dir = os.path.join(dataset_path, 'test')\n#     val_dir = os.path.join(dataset_path, 'val')\n#     os.makedirs(train_dir, exist_ok=True)\n#     os.makedirs(test_dir, exist_ok=True)\n#     os.makedirs(val_dir, exist_ok=True)\n#\n#     # 将文件移动到对应的文件夹\n#     for f in train_files:\n#         shutil.move(f, os.path.join(train_dir, os.path.basename(f)))\n#     for f in test_files:\n#         shutil.move(f, os.path.join(test_dir, os.path.basename(f)))\n#     for f in val_files:\n#         shutil.move(f, os.path.join(val_dir, os.path.basename(f)))\n```", "classification": "人工智能"}
{"_id": 155, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n用numpy实现Hinge损失,\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testhinge_loss:\n    def test_hinge_loss_1(self):\n        assert np.isclose(hinge_loss(np.array([1, -1, 1]), np.array([1, -1, 1])), 0.0)\n\n", "problem": "用numpy实现Hinge损失,", "testcases": "import numpy as np\n\n\nclass Testhinge_loss:\n    def test_hinge_loss_2(self):\n        assert np.isclose(hinge_loss(np.array([-1, -1, -1]), np.array([1, 1, 1])), 2.0)\n\n    def test_hinge_loss_3(self):\n        assert np.isclose(hinge_loss(np.array([1, 1, 1]), np.array([-1, -1, -1])), 2.0)\n\n    def test_hinge_loss_4(self):\n        assert np.isclose(hinge_loss(np.array([1, -1, 1]), np.array([-1, 1, -1])), 2.0)\n\n    def test_hinge_loss_5(self):\n        assert np.isclose(hinge_loss(np.array([1, 1, 1]), np.array([0.5, 0.5, 0.5])), 0.5)\n\n    def test_hinge_loss_6(self):\n        assert np.isclose(hinge_loss(np.array([-1, -1, -1]), np.array([-0.5, -0.5, -0.5])), 0.5)\n\n    def test_hinge_loss_7(self):\n        assert np.isclose(hinge_loss(np.array([1]), np.array([1])), 0.0)\n\n    def test_hinge_loss_8(self):\n        assert np.isclose(hinge_loss(np.array([-1]), np.array([1])), 2.0)\n\n    def test_hinge_loss_9(self):\n        assert np.isclose(hinge_loss(np.array([1]), np.array([-1])), 2.0)\n\n    def test_hinge_loss_10(self):\n        assert np.isclose(hinge_loss(np.array([-1]), np.array([-1])), 0.0)", "setup_code": "", "reference_solution": "```python\nimport numpy as np\n\ndef hinge_loss(y_true, y_pred):\n     return np.mean(np.maximum(0, 1 - y_true * y_pred))\n\n```", "classification": "人工智能"}
{"_id": 156, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n图像处理领域中的yolo格式数据集标注文件存在异常空行，需要进行删除空行     输入：yolo格式数据集标注文件的文件夹路径\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testremove_empty_lines_folder:\n    def test_remove_empty_lines_folder_1(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test1.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n\\n\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        remove_empty_lines_folder(str(tmpdir / \"sub\"))\n        assert p.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\"\n\n", "problem": "图像处理领域中的yolo格式数据集标注文件存在异常空行，需要进行删除空行     输入：yolo格式数据集标注文件的文件夹路径", "testcases": "import os\n\nclass Testremove_empty_lines_folder:\n    def test_remove_empty_lines_folder_2(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test2.txt\")\n        p.write(\"1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\")\n        remove_empty_lines_folder(str(tmpdir / \"sub\"))\n        assert p.read() == \"1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\"\n\n    def test_remove_empty_lines_folder_3(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test3.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n\\n4 0.5 0.5 0.5 0.5\")\n        remove_empty_lines_folder(str(tmpdir / \"sub\"))\n        assert p.read() == \"0 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\"\n\n    def test_remove_empty_lines_folder_4(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test4.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\")\n        remove_empty_lines_folder(str(tmpdir / \"sub\"))\n        assert p.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\"\n\n    def test_remove_empty_lines_folder_5(self, tmpdir):\n        p1 = tmpdir.mkdir(\"sub\").join(\"test5-1.txt\")\n        p1.write(\"0 0.5 0.5 0.5 0.5\\n\\n\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        p2 = (tmpdir / \"sub\").join(\"test5-2.txt\")\n        p2.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\")\n        remove_empty_lines_folder(str(tmpdir / \"sub\"))\n        assert p1.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\"\n        assert p2.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\"\n\n    def test_remove_empty_lines_folder_6(self, tmpdir):\n        p1 = tmpdir.mkdir(\"sub\").join(\"test6-1.txt\")\n        p1.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\")\n        p2 = (tmpdir / \"sub\").join(\"test6-2.txt\")\n        p2.write(\"0 0.5 0.5 0.5 0.5\\n\\n4 0.5 0.5 0.5 0.5\")\n        remove_empty_lines_folder(str(tmpdir / \"sub\"))\n        assert p1.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\"\n        assert p2.read() == \"0 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\"\n\n    def test_remove_empty_lines_folder_7(self, tmpdir):\n        p1 = tmpdir.mkdir(\"sub\").join(\"test7-1.txt\")\n        p1.write(\"\\n\\n0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n\\n4 0.5 0.5 0.5 0.5\")\n        p2 = (tmpdir / \"sub\").join(\"test1-2.txt\")\n        p2.write(\"0 0.5 0.5 0.5 0.5\\n\\n\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        remove_empty_lines_folder(str(tmpdir / \"sub\"))\n        assert p1.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\"\n        assert p2.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\"", "setup_code": "", "reference_solution": "```python\nimport os\n\n\ndef remove_empty_lines_folder(folder_path):\n    for file_name in os.listdir(folder_path):\n        if file_name.endswith('.txt'):\n            file_path = os.path.join(folder_path, file_name)\n            remove_empty_lines(file_path)\n\n\ndef remove_empty_lines(file_path):\n    with open(file_path, 'r+') as file:\n        lines = file.readlines()\n        file.seek(0)\n        file.truncate()\n        for line in lines:\n            if line.strip():  # 检查是否为空行\n                file.write(line)\n\n# folder_path=r'C:\\Users\\Administrator\\Desktop\\work\\1207-Q17\\yolo\\labels'\n# remove_empty_lines_folder(folder_path)\n\n```", "classification": "数据科学"}
{"_id": 157, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n对图像处理领域中的yolo格式数据集的标注文件进行类别筛选，只保留Label_category里面的类别标签，删除掉别的类别标签，在原文件上操作     输入yolo格式数据集的标注文件夹路径和Label_category列表\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testlabel_filter:\n    def test_label_filter_1(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test1.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [1,2,3])\n        assert p.read() == \"0 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\"\n\n", "problem": "对图像处理领域中的yolo格式数据集的标注文件进行类别筛选，只保留Label_category里面的类别标签，删除掉别的类别标签，在原文件上操作     输入yolo格式数据集的标注文件夹路径和Label_category列表", "testcases": "import os\n\n\nclass Testlabel_filter:\n    def test_label_filter_2(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test2.txt\")\n        p.write(\"1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [1,2,3])\n        assert p.read() == \"\"\n\n    def test_label_filter_3(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test3.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [1,2,3])\n        assert p.read() == \"0 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\"\n\n    def test_label_filter_4(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test4.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [0,4])\n        assert p.read() == \"1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n\"\n\n    def test_label_filter_5(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test5.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [])\n        assert p.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\"\n\n    def test_label_filter_6(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test6.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\")\n        label_filter(str(tmpdir / \"sub\"), [0,1,2,3,4])\n        assert p.read() == \"\"\n\n    def test_label_filter_7(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test7.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [5,6,7])\n        assert p.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\"\n\n    def test_label_filter_8(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test8.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [0])\n        assert p.read() == \"1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\\n\"\n\n    def test_label_filter_9(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test9.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [4])\n        assert p.read() == \"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n\"\n\n    def test_label_filter_10(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test10.txt\")\n        p.write(\"0 0.5 0.5 0.5 0.5\\n1 0.5 0.5 0.5 0.5\\n2 0.5 0.5 0.5 0.5\\n3 0.5 0.5 0.5 0.5\\n4 0.5 0.5 0.5 0.5\")\n        label_filter(str(tmpdir / \"sub\"), [0,1,2,3])\n        assert p.read() == \"4 0.5 0.5 0.5 0.5\\n\"", "setup_code": "", "reference_solution": "```python\nimport os\n\n\ndef label_filter(folder_path,Label_category):\n\n    txt_files = [f for f in os.listdir(folder_path) if f.endswith('.txt')]\n    for file_name in txt_files:\n        file_path = os.path.join(folder_path, file_name)\n        with open(file_path, 'r') as file:\n            lines = file.readlines()\n\n        new_lines = []\n\n\n        for line in lines:\n            parts = line.split()\n\n            if int(parts[0]) in Label_category :\n                continue\n            new_line = ' '.join(parts) + '\\n'\n            new_lines.append(new_line)\n\n        # 将处理后的行写回文件\n        with open(file_path, 'w') as file:\n            file.writelines(new_lines)\n\n```", "classification": "人工智能"}
{"_id": 158, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n对图像处理领域中的yolo格式数据集的标注文件进行类别筛选，w和h均大于limit_wideth，limit_height的标注信息，在原文件上操作     输入yolo格式数据集的标注文件夹路径和limit_wideth，limit_height\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testw_h_filter:\n    def test_w_h_filter_1(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0.15, 0.15)\n        assert p.read() == \"1 0.5 0.5 0.2 0.2\\n\"\n\n", "problem": "对图像处理领域中的yolo格式数据集的标注文件进行类别筛选，w和h均大于limit_wideth，limit_height的标注信息，在原文件上操作     输入yolo格式数据集的标注文件夹路径和limit_wideth，limit_height", "testcases": "import os\n\n\nclass Testw_h_filter:\n    def test_w_h_filter_2(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0.05, 0.05)\n        assert p.read() == \"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\\n\"\n\n    def test_w_h_filter_3(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0.2, 0.2)\n        assert p.read() == \"1 0.5 0.5 0.2 0.2\\n\"\n\n    def test_w_h_filter_4(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0.1, 0.1)\n        assert p.read() == \"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\\n\"\n\n    def test_w_h_filter_5(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0.1, 0.2)\n        assert p.read() == \"1 0.5 0.5 0.2 0.2\\n\"\n\n    def test_w_h_filter_6(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0.2, 0.1)\n        assert p.read() == \"1 0.5 0.5 0.2 0.2\\n\"\n\n    def test_w_h_filter_7(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0, 0)\n        assert p.read() == \"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\\n\"\n\n    def test_w_h_filter_8(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 1, 1)\n        assert p.read() == \"\"\n\n    def test_w_h_filter_9(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0.2, 0.2)\n        assert p.read() == \"1 0.5 0.5 0.2 0.2\\n\"\n\n    def test_w_h_filter_10(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"test.txt\")\n        p.write(\"0 0.5 0.5 0.1 0.1\\n1 0.5 0.5 0.2 0.2\")\n        w_h_filter(str(tmpdir / \"sub\"), 0.15, 0.15)\n        assert p.read() == \"1 0.5 0.5 0.2 0.2\\n\"", "setup_code": "", "reference_solution": "```python\nimport os\n\n\ndef w_h_filter(folder_path,limit_wideth,limit_height):\n    txt_files = [f for f in os.listdir(folder_path) if f.endswith('.txt')]\n    for file_name in txt_files:\n        file_path = os.path.join(folder_path, file_name)\n        with open(file_path, 'r') as file:\n            lines = file.readlines()\n\n        new_lines = []\n\n\n        for line in lines:\n            parts = line.split()\n\n            if (float(parts[3]) < limit_wideth or float(parts[4]) < limit_height):\n                continue\n            new_line = ' '.join(parts) + '\\n'\n            new_lines.append(new_line)\n\n        # 将处理后的行写回文件\n        with open(file_path, 'w') as file:\n            file.writelines(new_lines)\n\n\n\n\n# if __name__ == \"__main__\":\n#\n#     folder_path = r\"C:\\Users\\Administrator\\Desktop\\work\\1207-Q14\\labels\"\n#     limit_wideth=0.1\n#     limit_height=0.02\n#     w_h_filter(folder_path,limit_wideth,limit_height)\n\n```", "classification": "人工智能"}
{"_id": 159, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n用numpy实现均方误差损失函数（Mean Squared Error, MSE）,\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testmean_squared_error:\n    def test_mean_squared_error_1(self):\n        y_true = np.array([1, 2, 3, 4, 5])\n        y_pred = np.array([1, 2, 3, 4, 5])\n        assert mean_squared_error(y_true, y_pred) == 0.0\n\n", "problem": "用numpy实现均方误差损失函数（Mean Squared Error, MSE）,", "testcases": "import numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\nclass Testmean_squared_error:\n    def test_mean_squared_error_2(self):\n        y_true = np.array([1, 2, 3, 4, 5])\n        y_pred = np.array([2, 3, 4, 5, 6])\n        assert mean_squared_error(y_true, y_pred) == 1.0\n\n    def test_mean_squared_error_3(self):\n        y_true = np.array([1, 2, 3, 4, 5])\n        y_pred = np.array([5, 4, 3, 2, 1])\n        assert mean_squared_error(y_true, y_pred) == 8.0\n\n    def test_mean_squared_error_4(self):\n        y_true = np.array([1, 1, 1, 1, 1])\n        y_pred = np.array([1, 1, 1, 1, 1])\n        assert mean_squared_error(y_true, y_pred) == 0.0\n\n    def test_mean_squared_error_5(self):\n        y_true = np.array([1, 1, 1, 1, 1])\n        y_pred = np.array([0, 0, 0, 0, 0])\n        assert mean_squared_error(y_true, y_pred) == 1.0\n\n    def test_mean_squared_error_6(self):\n        y_true = np.array([0, 0, 0, 0, 0])\n        y_pred = np.array([1, 1, 1, 1, 1])\n        assert mean_squared_error(y_true, y_pred) == 1.0\n\n    def test_mean_squared_error_7(self):\n        y_true = np.array([100, 200, 300, 400, 500])\n        y_pred = np.array([100, 200, 300, 400, 500])\n        assert mean_squared_error(y_true, y_pred) == 0.0\n\n    def test_mean_squared_error_8(self):\n        y_true = np.array([100, 200, 300, 400, 500])\n        y_pred = np.array([500, 400, 300, 200, 100])\n        assert mean_squared_error(y_true, y_pred) == 80000.0\n\n    def test_mean_squared_error_9(self):\n        y_true = np.array([1.1, 2.2, 3.3, 4.4, 5.5])\n        y_pred = np.array([1.1, 2.2, 3.3, 4.4, 5.5])\n        assert mean_squared_error(y_true, y_pred) == 0.0\n", "setup_code": "", "reference_solution": "```python\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\ndef mean_squared_error(y_true, y_pred):\n    return np.mean(np.square(y_true - y_pred))\n```", "classification": "人工智能"}
{"_id": 160, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n导入nltk包。定义一个函数形参接收一段句子，对这段句子进行分词、词性标注、移除停用词和词干提取操作，并分别输出操作的结果。然后调用定义的函数\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testprocess_sentence:\n    def test_process_sentence_1(self):\n        assert process_sentence(\"Hello, world!\") == (['Hello', ',', 'world', '!'], [('Hello', 'NNP'), (',', ','), ('world', 'NN'), ('!', '.')], ['hello', ',', 'world', '!'], ['hello', ',', 'world', '!'])\n\n", "problem": "导入nltk包。定义一个函数形参接收一段句子，对这段句子进行分词、词性标注、移除停用词和词干提取操作，并分别输出操作的结果。然后调用定义的函数", "testcases": "import nltk\nnltk.data.path.append('averaged_perceptron_tagger')\nfrom nltk.tokenize import word_tokenize\nfrom nltk.stem import PorterStemmer\n\n\nclass Testprocess_sentence:\n    def test_process_sentence_2(self):\n        assert process_sentence(\"I am a student.\") == (['I', 'am', 'a', 'student', '.'], [('I', 'PRP'), ('am', 'VBP'), ('a', 'DT'), ('student', 'NN'), ('.', '.')], ['i', 'am', 'a', 'student', '.'], ['i', 'am', 'a', 'student', '.'])\n\n    def test_process_sentence_3(self):\n        assert process_sentence(\"This is a test sentence.\") == (['This', 'is', 'a', 'test', 'sentence', '.'], [('This', 'DT'), ('is', 'VBZ'), ('a', 'DT'), ('test', 'NN'), ('sentence', 'NN'), ('.', '.')], ['this', 'is', 'a', 'test', 'sentence', '.'], ['thi', 'is', 'a', 'test', 'sentenc', '.'])\n\n    def test_process_sentence_4(self):\n        assert process_sentence(\"The quick brown fox jumps over the lazy dog.\") == (['The', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog', '.'], [('The', 'DT'), ('quick', 'JJ'), ('brown', 'NN'), ('fox', 'NN'), ('jumps', 'VBZ'), ('over', 'IN'), ('the', 'DT'), ('lazy', 'JJ'), ('dog', 'NN'), ('.', '.')], ['the', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog', '.'], ['the', 'quick', 'brown', 'fox', 'jump', 'over', 'the', 'lazi', 'dog', '.'])\n\n    def test_process_sentence_5(self):\n        assert process_sentence(\"Python is a high-level programming language.\") == (['Python', 'is', 'a', 'high-level', 'programming', 'language', '.'], [('Python', 'NNP'), ('is', 'VBZ'), ('a', 'DT'), ('high-level', 'JJ'), ('programming', 'NN'), ('language', 'NN'), ('.', '.')], ['python', 'is', 'a', 'high-level', 'programming', 'language', '.'], ['python', 'is', 'a', 'high-level', 'program', 'languag', '.'])\n\n    def test_process_sentence_6(self):\n        assert process_sentence(\"It's a beautiful day!\") == (['It', \"'s\", 'a', 'beautiful', 'day', '!'], [('It', 'PRP'), (\"'s\", 'VBZ'), ('a', 'DT'), ('beautiful', 'JJ'), ('day', 'NN'), ('!', '.')], ['it', \"'s\", 'a', 'beautiful', 'day', '!'], ['it', \"'s\", 'a', 'beauti', 'day', '!'])\n\n    def test_process_sentence_7(self):\n        assert process_sentence(\"\") == ([], [], [], [])\n\n    def test_process_sentence_8(self):\n        assert process_sentence(\" \") == ([], [], [], [])\n\n    def test_process_sentence_9(self):\n        assert process_sentence(\"123\") == (['123'], [('123', 'CD')], ['123'], ['123'])\n\n    def test_process_sentence_10(self):\n        assert process_sentence(\"!@#$%^&*()\") == (['!', '@', '#', '$', '%', '^', '&', '*', '(', ')'], [('!', '.'), ('@', 'JJ'), ('#', '#'), ('$', '$'), ('%', 'NN'), ('^', 'NNP'), ('&', 'CC'), ('*', 'NNP'), ('(', '('), (')', ')')], ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')'], ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')'])", "setup_code": "", "reference_solution": "```python\nimport nltk\nnltk.data.path.append('nltk_package')\nfrom nltk.tokenize import word_tokenize\nfrom nltk.stem import PorterStemmer\nfrom nltk import pos_tag\n\n\ndef process_sentence(sentence):\n    tokens = word_tokenize(sentence)\n    pos_tags = pos_tag(tokens)\n    # stop_words = set(stopwords.words('english'))\n    # filtered_tokens = [word.lower() for word in tokens if word.lower() not in stop_words]\n    filtered_tokens = [word.lower() for word in tokens]\n    stemmer = PorterStemmer()\n    stemmed_tokens = [stemmer.stem(word) for word in filtered_tokens]\n    # 输出结果\n    print(\"Original Sentence:\\n\", sentence)\n    print(\"\\nTokenized Sentence:\\n\", tokens)\n    print(\"\\nPOS Tagged Sentence:\\n\", pos_tags)\n    print(\"\\nSentence without Stopwords:\\n\", filtered_tokens)\n    print(\"\\nStemmed Sentence:\\n\", stemmed_tokens)\n    return tokens, pos_tags, filtered_tokens, stemmed_tokens\n\nprint(process_sentence(\"!@#$%^&*()\"))\n\n```", "classification": "人工智能"}
{"_id": 161, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n有一个dataset.csv，其中有PassengerID、Survived、Pclass、Sex、Age 5列。请读取文件并计算Sex列为female，且survived列为1的概率和Sex列为male，且survived列为1的概率，最后将数据集中的非数值列转换为one-hot编码，保存数据集到新的new_train.csv文件中\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcalculate_and_save_probabilities:\n    def test_case1(self):\n        assert calculate_and_save_probabilities(\"test1/dataset.csv\", \"test1/new_train.csv\") == (0.1, 0.8)\n        df1 = pd.read_csv(\"test1/new_train.csv\")\n        df2 = pd.read_csv(\"test1/test_label.csv\")\n        assert df1.equals(df2)\n\n", "problem": "有一个dataset.csv，其中有PassengerID、Survived、Pclass、Sex、Age 5列。请读取文件并计算Sex列为female，且survived列为1的概率和Sex列为male，且survived列为1的概率，最后将数据集中的非数值列转换为one-hot编码，保存数据集到新的new_train.csv文件中", "testcases": "import pandas as pd\nfrom sklearn.preprocessing import OneHotEncoder\n\n\nclass Testcalculate_and_save_probabilities:\n    def test_case2(self):\n        assert calculate_and_save_probabilities(\"test2/dataset.csv\", \"test2/new_train.csv\") == (0.2, 0.8)\n        df1 = pd.read_csv(\"test2/new_train.csv\")\n        df2 = pd.read_csv(\"test2/test_label.csv\")\n        assert df1.equals(df2)\n\n    def test_case3(self):\n        assert calculate_and_save_probabilities(\"test3/dataset.csv\", \"test3/new_train.csv\") == (0.2727272727272727, 0.8888888888888888)\n        df1 = pd.read_csv(\"test3/new_train.csv\")\n        df2 = pd.read_csv(\"test3/test_label.csv\")\n        assert df1.equals(df2)\n\n    def test_case4(self):\n        assert calculate_and_save_probabilities(\"test4/dataset.csv\", \"test4/new_train.csv\") == (0.36363636363636365, 0.7777777777777778)\n        df1 = pd.read_csv(\"test4/new_train.csv\")\n        df2 = pd.read_csv(\"test4/test_label.csv\")\n        assert df1.equals(df2)\n\n    def test_case5(self):\n        assert calculate_and_save_probabilities(\"test5/dataset.csv\", \"test5/new_train.csv\") == (0.2, 0.8)\n        df1 = pd.read_csv(\"test5/new_train.csv\")\n        df2 = pd.read_csv(\"test5/test_label.csv\")\n        assert df1.equals(df2)\n\n    def test_case6(self):\n        assert calculate_and_save_probabilities(\"test6/dataset.csv\", \"test6/new_train.csv\") == (0.2222222222222222, 0.7272727272727273)\n        df1 = pd.read_csv(\"test6/new_train.csv\")\n        df2 = pd.read_csv(\"test6/test_label.csv\")\n        assert df1.equals(df2)", "setup_code": "", "reference_solution": "```python\nimport pandas as pd\nfrom sklearn.preprocessing import OneHotEncoder\n\n\ndef calculate_and_save_probabilities(input_file, output_file):\n    # 读取数据集\n    df = pd.read_csv(input_file)\n\n    # 计算概率\n    probabilities = {}\n    for column_value in df['Sex'].unique():\n        prob = df[(df['Sex'] == column_value) & (df[\"Survived\"] == 1)].shape[0] / df[df['Sex'] == column_value].shape[0]\n        probabilities[f\"Probability({'Sex'}={column_value}, {'Survived'}=1)\"] = prob\n\n    # 打印计算结果\n    for key, value in probabilities.items():\n        print(key + \":\", value)\n\n    # 进行独热编码\n    non_numeric_columns = df.select_dtypes(include=['object']).columns\n    encoder = OneHotEncoder(sparse=False)\n    encoded_features = pd.DataFrame(encoder.fit_transform(df[non_numeric_columns]))\n    encoded_features.columns = encoder.get_feature_names_out(non_numeric_columns)\n\n    # 替换原始数据集中的非数值列\n    df.drop(non_numeric_columns, axis=1, inplace=True)\n    df = pd.concat([df, encoded_features], axis=1)\n\n    # 将数据集保存到新文件\n    df.to_csv(output_file, index=False)\n\n    return probabilities[f\"Probability(Sex=male, Survived=1)\"], probabilities[\"Probability(Sex=female, Survived=1)\"]\n\n\nprint(calculate_and_save_probabilities(\"test6/dataset.csv\", \"test6/test_label.csv\"))\n```", "classification": "数据科学"}
{"_id": 162, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n给两个等长的向量x, y，用numpy工具包，使用最小二乘法求解对a和b进行线性拟合，求出斜率a，截距b和相关系数r\n函数用法：a, b, r = linear_fit(x, y)\n请补全 linear_fit 函数的代码\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testlinear_fit:\n    def test_linear_fit_1(self):\n        x = [1, 2, 3, 4, 5]\n        y = [2, 4, 6, 8, 10]\n        a, b, r = linear_fit(x, y)\n        assert a == 2\n        assert b == 0\n        assert r == 0.9999999999999999\n\n", "problem": "给两个等长的向量x, y，用numpy工具包，使用最小二乘法求解对a和b进行线性拟合，求出斜率a，截距b和相关系数r\n函数用法：a, b, r = linear_fit(x, y)\n请补全 linear_fit 函数的代码", "testcases": "import numpy as np\n\n\nclass Testlinear_fit:\n    def test_linear_fit_2(self):\n        x = [1, 2, 3, 4, 5]\n        y = [3, 5, 7, 9, 11]\n        a, b, r = linear_fit(x, y)\n        assert a == 2\n        assert b == 1\n        assert r == 0.9999999999999999\n\n    def test_linear_fit_3(self):\n        x = [1, 2, 3, 4, 5]\n        y = [1, 2, 3, 4, 5]\n        a, b, r = linear_fit(x, y)\n        assert a == 1\n        assert b == 0\n        assert r == 0.9999999999999999\n\n    def test_linear_fit_4(self):\n        x = [1, 2, 3, 4, 5]\n        y = [2, 3, 4, 5, 6]\n        a, b, r = linear_fit(x, y)\n        assert a == 1\n        assert b == 1\n        assert r == 0.9999999999999999\n\n    def test_linear_fit_5(self):\n        x = [1, 2, 3, 4, 5]\n        y = [5, 7, 9, 11, 13]\n        a, b, r = linear_fit(x, y)\n        assert a == 2\n        assert b == 3\n        assert r == 0.9999999999999999\n\n    def test_linear_fit_6(self):\n        x = [1, 2, 3, 4, 5]\n        y = [1, 1, 1, 1, 1]\n        a, b, r = linear_fit(x, y)\n        assert a == 0\n        assert b == 1\n        assert np.isnan(r)\n\n    def test_linear_fit_7(self):\n        x = [1, 1, 1, 1, 1]\n        y = [1, 2, 3, 4, 5]\n        a, b, r = linear_fit(x, y)\n        assert np.isnan(a)\n        assert np.isnan(b)\n        assert np.isnan(r)\n\n    def test_linear_fit_8(self):\n        x = [1, 2, 3, 4, 5]\n        y = [5, 4, 3, 2, 1]\n        a, b, r = linear_fit(x, y)\n        assert a == -1\n        assert b == 6\n        assert r == -0.9999999999999999\n\n    def test_linear_fit_9(self):\n        x = [1, 2, 3, 4, 5]\n        y = [10, 8, 6, 4, 2]\n        a, b, r = linear_fit(x, y)\n        assert a == -2\n        assert b == 12\n        assert r == -0.9999999999999999\n\n    def test_linear_fit_10(self):\n        x = [1, 2, 3, 4, 5]\n        y = [1, 4, 9, 16, 25]\n        a, b, r = linear_fit(x, y)\n        assert a == 6.0\n        assert b == -7.0\n        assert r == 0.981104910251593", "setup_code": "", "reference_solution": "```python\nimport numpy as np\n\n\ndef linear_fit(x, y):\n    x = np.array(x)\n    y = np.array(y)\n\n    mean_x = np.mean(x)\n    mean_y = np.mean(y)\n\n    SS_xy = np.dot(x - mean_x, y - mean_y)\n    SS_xx = np.dot(x - mean_x, x - mean_x)\n    a = SS_xy / SS_xx\n    b = mean_y - a * mean_x\n\n    r = np.corrcoef(x, y)[0, 1]\n\n    return a, b, r\n\n\n```", "classification": "数据科学"}
{"_id": 163, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n创建一个python类，接收一个路径参数，如果接受的路径不存在则输出“Invalid directory path.”如果接收的路径存在，则输出这个路径中的所有文件的名字以及其子目录中所有文件的名字\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testlist_files:\n    def test_list_files_1(self, tmp_path, capsys):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"hello.txt\"\n        p.write_text(\"content\")\n        list_files(tmp_path)\n        captured = capsys.readouterr()\n        assert captured.out == \"hello.txt\\n\"\n\n", "problem": "创建一个python类，接收一个路径参数，如果接受的路径不存在则输出“Invalid directory path.”如果接收的路径存在，则输出这个路径中的所有文件的名字以及其子目录中所有文件的名字", "testcases": "\n\nclass Testlist_files:\n    def test_list_files_2(self, tmp_path, capsys):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"hello.txt\"\n        p.write_text(\"content\")\n        p2 = tmp_path / \"world.txt\"\n        p2.write_text(\"content\")\n        list_files(tmp_path)\n        captured = capsys.readouterr()\n        assert 'world.txt' in captured.out and 'hello.txt' in captured.out\n\n    def test_list_files_3(self, tmp_path, capsys):\n        list_files(tmp_path)\n        captured = capsys.readouterr()\n        assert captured.out == \"\"\n\n    def test_list_files_4(self, tmp_path, capsys):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"hello.txt\"\n        p.write_text(\"content\")\n        d2 = tmp_path / \"sub2\"\n        d2.mkdir()\n        p2 = d2 / \"world.txt\"\n        p2.write_text(\"content\")\n        list_files(tmp_path)\n        captured = capsys.readouterr()\n        assert 'world.txt' in captured.out and 'hello.txt' in captured.out\n\n    def test_list_files_5(self, tmp_path, capsys):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"hello.txt\"\n        p.write_text(\"content\")\n        d2 = d / \"sub2\"\n        d2.mkdir()\n        p2 = d2 / \"world.txt\"\n        p2.write_text(\"content\")\n        list_files(tmp_path)\n        captured = capsys.readouterr()\n        assert 'world.txt' in captured.out and 'hello.txt' in captured.out\n\n    def test_list_files_6(self, tmp_path, capsys):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        p = d / \"hello.txt\"\n        p.write_text(\"content\")\n        d2 = d / \"sub2\"\n        d2.mkdir()\n        p2 = d2 / \"world.txt\"\n        p2.write_text(\"content\")\n        d3 = d2 / \"sub3\"\n        d3.mkdir()\n        p3 = d3 / \"python.txt\"\n        p3.write_text(\"content\")\n        list_files(tmp_path)\n        captured = capsys.readouterr()\n        assert 'world.txt' in captured.out and 'hello.txt' in captured.out and 'python.txt' in captured.out\n\n    def test_list_files_7(self, capsys):\n        list_files(\"/invalid/path\")\n        captured = capsys.readouterr()\n        assert 'Invalid directory path.' in captured.out", "setup_code": "", "reference_solution": "```python\nimport os\n\ndef list_files(directory_path):\n    # 检查目录是否存在\n    if not os.path.exists(directory_path) or not os.path.isdir(directory_path):\n        print(\"Invalid directory path.\")\n        return\n\n    list_files_recursive(directory_path)\n\ndef list_files_recursive(directory):\n    # 获取目录中的所有文件和子目录\n    files = os.listdir(directory)\n    for file in files:\n        file_path = os.path.join(directory, file)\n        if os.path.isfile(file_path):\n            # 如果是文件，则输出文件名\n            print(file)\n        elif os.path.isdir(file_path):\n            # 如果是目录，则输出目录名，并递归调用列出子目录\n            list_files_recursive(file_path)\n\n```", "classification": "操作系统"}
{"_id": 164, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n设计一个python函数接收一个文件名和一个路径信息，用于查找文件是否存在指定目录中，若不存在则输出“The file is not on disk”，如果存在则输出文件的绝对路径，如果文件存在于指定目录中且有多个同名文件则输出所有同名文件的绝对路径。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testfind_file:\n    def test_find_file_1(self, tmpdir, capsys):\n        p = tmpdir.mkdir(\"sub\").join(\"hello.txt\")\n        p.write(\"content\")\n        find_file('hello.txt', tmpdir)\n        captured = capsys.readouterr()\n        assert captured.out == f\"{os.path.join(tmpdir, 'sub', 'hello.txt')}\\n\"\n\n", "problem": "设计一个python函数接收一个文件名和一个路径信息，用于查找文件是否存在指定目录中，若不存在则输出“The file is not on disk”，如果存在则输出文件的绝对路径，如果文件存在于指定目录中且有多个同名文件则输出所有同名文件的绝对路径。", "testcases": "\n\nclass Testfind_file:\n    def test_find_file_2(self, tmpdir, capsys):\n        p = tmpdir.mkdir(\"sub\").join(\"hello.txt\")\n        p.write(\"content\")\n        find_file('world.txt', tmpdir)\n        captured = capsys.readouterr()\n        assert 'The file is not on disk' in captured.out\n\n    def test_find_file_3(self, tmpdir, capsys):\n        p1 = tmpdir.mkdir(\"sub1\").join(\"hello.txt\")\n        p1.write(\"content\")\n        p2 = tmpdir.mkdir(\"sub2\").join(\"hello.txt\")\n        p2.write(\"content\")\n        find_file('hello.txt', tmpdir)\n        captured = capsys.readouterr()\n        assert f\"{os.path.join(tmpdir, 'sub1', 'hello.txt')}\" in captured.out and f\"{os.path.join(tmpdir, 'sub2', 'hello.txt')}\" in captured.out\n\n    def test_find_file_4(self, tmpdir, capsys):\n        find_file('hello.txt', tmpdir)\n        captured = capsys.readouterr()\n        assert 'The file is not on disk' in captured.out\n\n    def test_find_file_5(self, tmpdir, capsys):\n        p = tmpdir.mkdir(\"sub\").join(\"hello.txt\")\n        p.write(\"content\")\n        find_file('hello.txt', os.path.join(tmpdir, 'sub'))\n        captured = capsys.readouterr()\n        assert f\"{os.path.join(tmpdir, 'sub', 'hello.txt')}\" in captured.out\n\n    def test_find_file_6(self, tmpdir, capsys):\n        p = tmpdir.mkdir(\"sub\").join(\"hello.txt\")\n        p.write(\"content\")\n        find_file('hello.txt', os.path.join(tmpdir, 'sub2'))\n        captured = capsys.readouterr()\n        assert 'The file is not on disk' in captured.out\n\n    def test_find_file_7(self, tmpdir, capsys):\n        p = tmpdir.mkdir(\"sub\").join(\"hello.txt\")\n        p.write(\"content\")\n        find_file('hello.txt', os.path.join(tmpdir, 'sub', 'subsub'))\n        captured = capsys.readouterr()\n        assert 'The file is not on disk' in captured.out\n", "setup_code": "", "reference_solution": "```python\nimport os\n\ndef find_file(file_name, directory_path):\n    exist = False\n    # 使用os.walk遍历指定目录及其子目录中的文件\n    for root, dirs, files in os.walk(directory_path):\n        for file in files:\n            if file == file_name:\n                exist = True\n                # 如果找到文件，输出文件的绝对路径\n                file_path = os.path.join(root, file)\n                print(file_path)\n    \n    if not exist:\n        print(\"The file is not on disk\")\n\n```", "classification": "操作系统"}
{"_id": 165, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n给定一个CSV文件，其中包含多列数据，每一列数据都是一些数字组成，读取文件并计算其中第三列的平均值。（提示，你需要跳过标题行）\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcalculate_average:\n    def test_calculate_average_1(self):\n        assert calculate_average('test1.csv', 2) == 85\n\n", "problem": "给定一个CSV文件，其中包含多列数据，每一列数据都是一些数字组成，读取文件并计算其中第三列的平均值。（提示，你需要跳过标题行）", "testcases": "\n\nclass Testcalculate_average:\n    def test_calculate_average_2(self):\n        assert calculate_average('test2.csv', 2) == 80\n\n    def test_calculate_average_3(self):\n        assert calculate_average('test3.csv', 2) == 8\n\n    def test_calculate_average_4(self):\n        assert calculate_average('test4.csv', 2) == 800\n\n    def test_calculate_average_5(self):\n        assert calculate_average('test5.csv', 2) == 0\n\n    def test_calculate_average_6(self):\n        assert calculate_average('test6.csv', 2) == 0\n\n    def test_calculate_average_7(self):\n        assert calculate_average('test7.csv', 2) == 15500\n", "setup_code": "", "reference_solution": "```python\nimport csv\n\ndef calculate_average(filename, column_index):\n    with open(filename, 'r') as file:\n        reader = csv.reader(file)\n        next(reader)  \n        total, count = 0, 0\n        for row in reader:\n            if row[column_index].isdigit():\n                total += int(row[column_index])\n                count += 1\n        return total / count if count != 0 else 0\n\n\n```", "classification": "数据科学"}
{"_id": 166, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n在data文件夹下有多个CSV文件，每个文件一共两列，包含2022年内某城市每日的气温记录，第一行是标题分别为Date和Temperature。气温值是一个整型数，我需要找出每个城市当年的最高气温值和对应的日期，并将结果保存到一个新的CSV文件中，结果的csv由三列组成，包括城市、最高气温和日期。注意，如果最高气温由多天是一样的，保留所有达到最高气温的日期。请问如何使用pandas库的dataframe完成这个任务。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testfind_max_temperature:\n    def test_single_file_single_max(self, tmpdir):\n        data = \"Date,Temperature\\n2022-01-01,10\\n2022-01-02,20\\n2022-01-03,30\"\n        p = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p.write(data)\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert output_file.read() == \"City,Max_Temperature,Date\\ncity1,30,2022-01-03\\n\"\n\n", "problem": "在data文件夹下有多个CSV文件，每个文件一共两列，包含2022年内某城市每日的气温记录，第一行是标题分别为Date和Temperature。气温值是一个整型数，我需要找出每个城市当年的最高气温值和对应的日期，并将结果保存到一个新的CSV文件中，结果的csv由三列组成，包括城市、最高气温和日期。注意，如果最高气温由多天是一样的，保留所有达到最高气温的日期。请问如何使用pandas库的dataframe完成这个任务。", "testcases": "import os\n\nclass Testfind_max_temperature:\n    def test_single_file_multiple_max(self, tmpdir):\n        data = \"Date,Temperature\\n2022-01-01,30\\n2022-01-02,20\\n2022-01-03,30\"\n        p = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p.write(data)\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert 'city1,30,2022-01-01' in output_file.read() and 'city1,30,2022-01-03' in output_file.read()\n\n    def test_multiple_files_single_max(self, tmpdir):\n        data1 = \"Date,Temperature\\n2022-01-01,10\\n2022-01-02,20\\n2022-01-03,30\"\n        data2 = \"Date,Temperature\\n2022-01-01,20\\n2022-01-02,30\\n2022-01-03,40\"\n        p1 = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p1.write(data1)\n        p2 = tmpdir.join(\"data\").join(\"city2.csv\")\n        p2.write(data2)\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert 'city1,30,2022-01-03' in output_file.read() and 'city2,40,2022-01-03' in output_file.read()\n\n    def test_multiple_files_multiple_max(self, tmpdir):\n        data1 = \"Date,Temperature\\n2022-01-01,30\\n2022-01-02,20\\n2022-01-03,30\"\n        data2 = \"Date,Temperature\\n2022-01-01,40\\n2022-01-02,30\\n2022-01-03,40\"\n        p1 = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p1.write(data1)\n        p2 = tmpdir.join(\"data\").join(\"city2.csv\")\n        p2.write(data2)\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert 'city1,30,2022-01-01' in output_file.read() and 'city1,30,2022-01-03' in output_file.read() and 'city2,40,2022-01-01' in output_file.read() and 'city2,40,2022-01-03' in output_file.read()\n\n    def test_no_csv_files(self, tmpdir):\n        tmpdir.mkdir(\"data\")\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert output_file.read() == \"City,Max_Temperature,Date\\n\"\n\n    def test_empty_csv_file(self, tmpdir):\n        p = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p.write(\"Date,Temperature\\n\")\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert output_file.read() == \"City,Max_Temperature,Date\\n\"\n\n    def test_single_file_single_max_boundary(self, tmpdir):\n        data = \"Date,Temperature\\n2022-01-01,999999\\n2022-01-02,20\\n2022-01-03,30\"\n        p = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p.write(data)\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert 'city1,999999,2022-01-01' in output_file.read()\n\n    def test_single_file_multiple_max_boundary(self, tmpdir):\n        data = \"Date,Temperature\\n2022-01-01,999999\\n2022-01-02,20\\n2022-01-03,999999\"\n        p = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p.write(data)\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert 'city1,999999,2022-01-01' in output_file.read() and 'city1,999999,2022-01-03' in output_file.read()\n\n    def test_multiple_files_single_max_boundary(self, tmpdir):\n        data1 = \"Date,Temperature\\n2022-01-01,10\\n2022-01-02,20\\n2022-01-03,30\"\n        data2 = \"Date,Temperature\\n2022-01-01,999999\\n2022-01-02,30\\n2022-01-03,40\"\n        p1 = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p1.write(data1)\n        p2 = tmpdir.join(\"data\").join(\"city2.csv\")\n        p2.write(data2)\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert 'city2,999999,2022-01-01' in output_file.read() and 'city1,30,2022-01-03' in output_file.read()\n\n    def test_multiple_files_multiple_max_boundary(self, tmpdir):\n        data1 = \"Date,Temperature\\n2022-01-01,999999\\n2022-01-02,20\\n2022-01-03,999999\"\n        data2 = \"Date,Temperature\\n2022-01-01,999999\\n2022-01-02,30\\n2022-01-03,999999\"\n        p1 = tmpdir.mkdir(\"data\").join(\"city1.csv\")\n        p1.write(data1)\n        p2 = tmpdir.join(\"data\").join(\"city2.csv\")\n        p2.write(data2)\n        output_file = tmpdir.join(\"output.csv\")\n        find_max_temperature(str(tmpdir.join(\"data\")), str(output_file))\n        assert 'city2,999999,2022-01-01' in output_file.read() and 'city1,999999,2022-01-01' in output_file.read() and 'city2,999999,2022-01-03' in output_file.read() and 'city1,999999,2022-01-03' in output_file.read()", "setup_code": "", "reference_solution": "```python\nimport os\nimport pandas as pd\n\n\ndef find_max_temperature(folder_path, output_file):\n    csv_files = [f for f in os.listdir(folder_path) if f.endswith('.csv')]\n    \n    result_df = pd.DataFrame(columns=['City', 'Max_Temperature', 'Date'])\n    \n    for csv_file in csv_files:\n        file_path = os.path.join(folder_path, csv_file)\n        df = pd.read_csv(file_path)\n    \n        city_name = csv_file[:-4]\n    \n        # 找到最高气温的值\n        max_temp = df['Temperature'].max()\n    \n        # 找到所有最高气温的日期\n        max_temp_dates = df.loc[df['Temperature'] == max_temp, 'Date'].tolist()\n    \n        # 将结果添加到result_df\n        for date in max_temp_dates:\n            result_df = result_df._append({'City': city_name,\n                                           'Max_Temperature': max_temp,\n                                           'Date': date}, ignore_index=True)\n    \n    result_df.to_csv(output_file, index=False)\n\n```", "classification": "数据科学"}
{"_id": 167, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n从多个CSV文件中读取数据，每个文件代表一个数据源。将这些数据按照时间戳合并，然后计算合并后的数据的滑动平均。\ndata.csv的格式是\ntimestamp,feature1,feature2,feature3\n2023-03-15 14:30:00,10,20,30\n2023-03-15 14:35:00,11,21,31\n2023-03-15 14:40:00,12,22,32\n...\n\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testmerge_and_smooth_data:\n    def test_merge_and_smooth_data_1(self):\n        data1 = pd.DataFrame({\n            'timestamp': ['2023-03-15 14:30:00', '2023-03-15 14:35:00', '2023-03-15 14:40:00'],\n            'feature1': [10, 11, 12],\n            'feature2': [20, 21, 22],\n            'feature3': [30, 31, 32]\n        })\n        data1.to_csv('data1.csv.csv', index=False)\n        data2 = pd.DataFrame({\n            'timestamp': ['2023-03-15 14:45:00', '2023-03-15 14:50:00', '2023-03-15 14:55:00'],\n            'feature1': [13, 14, 15],\n            'feature2': [23, 24, 25],\n            'feature3': [33, 34, 35]\n        })\n        data2.to_csv('data2.csv', index=False)\n        assert merge_and_smooth_data(['data1.csv.csv', 'data2.csv'], 2).tolist() == [[11.5, 21.5, 31.5], [12.5, 22.5, 32.5], [13.5, 23.5, 33.5], [14.5, 24.5, 34.5]]\n\n", "problem": "从多个CSV文件中读取数据，每个文件代表一个数据源。将这些数据按照时间戳合并，然后计算合并后的数据的滑动平均。\ndata.csv的格式是\ntimestamp,feature1,feature2,feature3\n2023-03-15 14:30:00,10,20,30\n2023-03-15 14:35:00,11,21,31\n2023-03-15 14:40:00,12,22,32\n...\n", "testcases": "import pandas as pd\n\nclass Testmerge_and_smooth_data:\n    def test_merge_and_smooth_data_2(self):\n        data1 = pd.DataFrame({\n            'timestamp': ['2023-03-15 14:30:00', '2023-03-15 14:35:00', '2023-03-15 14:40:00'],\n            'feature1': [10, 11, 12],\n            'feature2': [20, 21, 22],\n            'feature3': [30, 31, 32]\n        })\n        data1.to_csv('data1.csv.csv', index=False)\n        data2 = pd.DataFrame({\n            'timestamp': ['2023-03-15 14:45:00', '2023-03-15 14:50:00', '2023-03-15 14:55:00'],\n            'feature1': [13, 14, 15],\n            'feature2': [23, 24, 25],\n            'feature3': [33, 34, 35]\n        })\n        data2.to_csv('data2.csv', index=False)\n        assert merge_and_smooth_data(['data1.csv.csv', 'data2.csv'], 3).tolist() == [[12.0, 22.0, 32.0], [13.0, 23.0, 33.0], [14.0, 24.0, 34.0]]\n\n    def test_merge_and_smooth_data_3(self):\n        data1 = pd.DataFrame({\n            'timestamp': ['2023-03-15 14:30:00', '2023-03-15 14:35:00', '2023-03-15 14:40:00'],\n            'feature1': [10, 11, 12],\n            'feature2': [20, 21, 22],\n            'feature3': [30, 31, 32]\n        })\n        data1.to_csv('data1.csv.csv', index=False)\n        assert merge_and_smooth_data(['data1.csv.csv'], 2).tolist() == [[11.5, 21.5, 31.5]]\n\n    def test_merge_and_smooth_data_4(self):\n        data1 = pd.DataFrame({\n            'timestamp': ['2023-03-15 14:30:00', '2023-03-15 14:35:00', '2023-03-15 14:40:00'],\n            'feature1': [10, 11, 12],\n            'feature2': [20, 21, 22],\n            'feature3': [30, 31, 32]\n        })\n        data1.to_csv('data1.csv.csv', index=False)\n        assert merge_and_smooth_data(['data1.csv.csv'], 1).tolist() == [[11.0, 21.0, 31.0], [12.0, 22.0, 32.0]]\n\n    def test_merge_and_smooth_data_5(self):\n        data1 = pd.DataFrame({\n            'timestamp': ['2023-03-15 14:30:00'],\n            'feature1': [10],\n            'feature2': [20],\n            'feature3': [30]\n        })\n        data1.to_csv('data1.csv.csv', index=False)\n        assert merge_and_smooth_data(['data1.csv.csv'], 1).tolist() == []\n\n    def test_merge_and_smooth_data_6(self):\n        data1 = pd.DataFrame({\n            'timestamp': ['2023-03-15 14:30:00'],\n            'feature1': [10],\n            'feature2': [20],\n            'feature3': [30]\n        })\n        data1.to_csv('data1.csv.csv', index=False)\n        assert merge_and_smooth_data(['data1.csv.csv'], 2).tolist() == []", "setup_code": "", "reference_solution": "```python\nimport pandas as pd\nimport torch\n\ndef merge_and_smooth_data(filenames, window_size):\n    dfs = [pd.read_csv(filename) for filename in filenames]\n    merged_df = pd.concat(dfs).sort_values(by='timestamp')\n\n    tensor = torch.tensor(merged_df.drop(columns=['timestamp']).values)\n\n    cumsum = tensor.cumsum(dim=0)\n    sliding_avg = (cumsum[window_size:] - cumsum[:-window_size]) / float(window_size)\n    return sliding_avg\n\n\n```", "classification": "数据科学"}
{"_id": 168, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n用python对文件夹里面的图片转换成RGB格式，然后对图片进行从小到大编号，并将所有图片的分辨率改为指定分辨率(x, y)，将修改后的文件夹保存到给定路径中。然后输出修改后文件夹中所有图片的分辨率\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testresize_and_rename_images:\n    def test_resize_and_rename_images_1(self, capsys):\n        resize_and_rename_images('test1/input', 'test1/output', (800, 600))\n        captured = capsys.readouterr()\n        assert captured.out == \"Modified images resolutions:\\n001.jpg: 800 x 600\\n002.jpg: 800 x 600\\n003.jpg: 800 x 600\\n\"\n\n", "problem": "用python对文件夹里面的图片转换成RGB格式，然后对图片进行从小到大编号，并将所有图片的分辨率改为指定分辨率(x, y)，将修改后的文件夹保存到给定路径中。然后输出修改后文件夹中所有图片的分辨率", "testcases": "from PIL import Image\n\nclass Testresize_and_rename_images:\n    def test_resize_and_rename_images_2(self, capsys):\n        resize_and_rename_images('test2/input', 'test2/output', (1024, 768))\n        captured = capsys.readouterr()\n        assert captured.out == \"Modified images resolutions:\\n001.jpg: 1024 x 768\\n002.jpg: 1024 x 768\\n\"\n\n    def test_resize_and_rename_images_3(self, capsys):\n        resize_and_rename_images('test3/input', 'test3/output', (1920, 1080))\n        captured = capsys.readouterr()\n        assert captured.out == \"Modified images resolutions:\\n001.jpg: 1920 x 1080\\n\"\n\n    def test_resize_and_rename_images_4(self, capsys):\n        resize_and_rename_images('test4/input', 'test4/output', (1280, 720))\n        captured = capsys.readouterr()\n        assert captured.out == \"Modified images resolutions:\\n001.jpg: 1280 x 720\\n002.jpg: 1280 x 720\\n003.jpg: 1280 x 720\\n004.jpg: 1280 x 720\\n005.jpg: 1280 x 720\\n006.jpg: 1280 x 720\\n007.jpg: 1280 x 720\\n008.jpg: 1280 x 720\\n\"\n\n    def test_resize_and_rename_images_5(self, capsys):\n        resize_and_rename_images('test5/input', 'test5/output', (1600, 900))\n        captured = capsys.readouterr()\n        assert captured.out == \"Modified images resolutions:\\n001.jpg: 1600 x 900\\n002.jpg: 1600 x 900\\n\"\n\n    def test_resize_and_rename_images_6(self, capsys):\n        resize_and_rename_images('test6/input', 'test6/output', (2560, 1440))\n        captured = capsys.readouterr()\n        assert captured.out == \"Modified images resolutions:\\n001.jpg: 2560 x 1440\\n002.jpg: 2560 x 1440\\n003.jpg: 2560 x 1440\\n\"\n\n    def test_resize_and_rename_images_7(self, capsys):\n        resize_and_rename_images('test7/input', 'test7/output', (800, 600))\n        captured = capsys.readouterr()\n        assert captured.out == \"Modified images resolutions:\\n\"\n", "setup_code": "", "reference_solution": "```python\nfrom PIL import Image\nimport os\n\n\ndef resize_and_rename_images(input_folder, output_folder, target_resolution=(800, 600)):\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n    image_files = [f for f in os.listdir(input_folder) if f.endswith(('.png', '.jpg', '.jpeg'))]\n    image_files.sort()  # 按文件名排序\n    for i, image_file in enumerate(image_files):\n        input_path = os.path.join(input_folder, image_file)\n        output_path = os.path.join(output_folder, f\"{i + 1:03d}.jpg\")  # 格式化文件名\n\n        # 打开图片\n        img = Image.open(input_path)\n\n        # 转换为RGB模式\n        img = img.convert(\"RGB\")\n\n        # 统一分辨率\n        img = img.resize(target_resolution, Image.LANCZOS)\n\n        # 保存图片\n        img.save(output_path)\n\n    print(\"Modified images resolutions:\")\n    print_resolutions(output_folder)\n    return output_folder\n\n\ndef print_resolutions(folder_path):\n    image_files = [f for f in os.listdir(folder_path) if f.endswith(('.png', '.jpg', '.jpeg'))]\n    image_files.sort()\n\n    for image_file in image_files:\n        image_path = os.path.join(folder_path, image_file)\n        img = Image.open(image_path)\n        resolution = img.size\n        print(f\"{image_file}: {resolution[0]} x {resolution[1]}\")\n\n\nresize_and_rename_images('test6/input', 'test6/output', (2560, 1440))\n```", "classification": "软件工程"}
{"_id": 169, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n请实现focal loss，是2017年提出的方法，具体的，初始化有两个参数alpha和gamma，forward函数接收inputs和targets代表模型输出和GT\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Test__init__:\n    def test_focal_loss_1(self):\n        criterion = FocalLoss(alpha=0.25, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([0., 0., 0., 1., 1., 0., 0., 0., 1., 1.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.0649), atol=1e-4)\n\n", "problem": "请实现focal loss，是2017年提出的方法，具体的，初始化有两个参数alpha和gamma，forward函数接收inputs和targets代表模型输出和GT", "testcases": "import torch\nimport torch.nn as nn\n\nclass Test__init__:\n    def test_focal_loss_2(self):\n        criterion = FocalLoss(alpha=0.5, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([0., 0., 0., 1., 1., 0., 0., 0., 1., 1.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.1297), atol=1e-4)\n\n    def test_focal_loss_3(self):\n        criterion = FocalLoss(alpha=0.25, gamma=3.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([0., 0., 0., 1., 1., 0., 0., 0., 1., 1.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.0414), atol=1e-4)\n\n    def test_focal_loss_4(self):\n        criterion = FocalLoss(alpha=0.25, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.0649), atol=1e-4)\n\n    def test_focal_loss_5(self):\n        criterion = FocalLoss(alpha=0.25, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.0649), atol=1e-4)\n\n    def test_focal_loss_6(self):\n        criterion = FocalLoss(alpha=0.25, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.0524), atol=1e-4)\n\n    def test_focal_loss_7(self):\n        criterion = FocalLoss(alpha=0.25, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([0., 1., 0., 1., 0., 1., 0., 1., 0., 1.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.0777), atol=1e-4)\n\n    def test_focal_loss_8(self):\n        criterion = FocalLoss(alpha=0.25, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([1., 0., 1., 0., 1., 0., 1., 0., 1., 0.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.0520), atol=1e-4)\n\n    def test_focal_loss_9(self):\n        criterion = FocalLoss(alpha=0.25, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([0., 0., 0., 0., 0., 1., 1., 1., 1., 1.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.1098), atol=1e-4)\n\n    def test_focal_loss_10(self):\n        criterion = FocalLoss(alpha=0.25, gamma=2.0)\n        inputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\n        targets = torch.tensor([1., 1., 1., 1., 1., 0., 0., 0., 0., 0.])\n        assert torch.allclose(criterion(inputs, targets).detach(), torch.tensor(0.0200), atol=1e-4)", "setup_code": "", "reference_solution": "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass FocalLoss(nn.Module):\n    def __init__(self, alpha=0.25, gamma=2.0):\n        super(FocalLoss, self).__init__()\n        self.alpha = alpha\n        self.gamma = gamma\n\n    def forward(self, inputs, targets):\n        \n        BCE_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction='none')\n        pt = torch.exp(-BCE_loss)  \n        focal_loss = self.alpha * (1-pt)**self.gamma * BCE_loss\n        return focal_loss.mean()\n\n\ncriterion = FocalLoss(alpha=0.25, gamma=2.0)\ninputs = torch.tensor([0.1, 0.2, 0.4, 0.8, 1.2, -0.1, -0.2, -0.4, -0.8, -1.2], requires_grad=True)\ntargets = torch.tensor([1., 0., 1., 0., 1., 0., 1., 0., 1., 0.])\n\nloss = criterion(inputs, targets).detach()\nprint(loss)\n\n\n```", "classification": "人工智能"}
{"_id": 170, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n使用python函数接收两个路径参数，将第一个路径参数指向的文件复制并移动到第二个路径参数指向的文件夹下。若文件不存在则输出\"File not exist.\"。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcopy_and_move_file:\n    def test_copy_and_move_file_1(self):\n        copy_and_move_file('test1/test.txt', 'test1/target')\n        assert os.path.exists('test1/target/test.txt')\n\n", "problem": "使用python函数接收两个路径参数，将第一个路径参数指向的文件复制并移动到第二个路径参数指向的文件夹下。若文件不存在则输出\"File not exist.\"。", "testcases": "import os\n\nclass Testcopy_and_move_file:\n    def test_copy_and_move_file_2(self, capsys):\n        copy_and_move_file('test2/test.txt', 'test2/target')\n        captured = capsys.readouterr()\n        assert captured.out == \"File not exist.\\n\"\n\n    def test_copy_and_move_file_3(self):\n        copy_and_move_file('test3/source/test.txt', 'test3')\n        assert os.path.exists('test3/test.txt')\n\n    def test_copy_and_move_file_4(self):\n        with pytest.raises(FileNotFoundError):\n            copy_and_move_file('test4/test.txt', 'test4/target')\n\n    def test_copy_and_move_file_5(self):\n        copy_and_move_file('test5/source/test.txt', 'test5/target')\n        assert os.path.exists('test5/target/test.txt')\n\n    def test_copy_and_move_file_6(self):\n        copy_and_move_file('test6/test.txt', 'test6/target')\n        assert os.path.exists('test6/target/test.txt')", "setup_code": "", "reference_solution": "```python\nimport os\nimport shutil\n\n\ndef copy_and_move_file(source_path, destination_directory):\n    # 获取源文件的文件名\n    file_name = os.path.basename(source_path)\n\n    # 构建目标路径\n    destination_path = os.path.join(destination_directory, file_name)\n\n    # 检查源文件是否存在\n    if os.path.exists(source_path):\n        # 复制文件\n        shutil.copy(source_path, destination_path)\n    else:\n        print(\"File not exist.\")\n\n```", "classification": "操作系统"}
{"_id": 171, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n定义一个python函数，使用docx包读取word文档，然后将文档中的所有段落的文本合并成为一个字符串。遍历关键词列表，统计关键词在字符串中出现的次数。最后调用函数输出结果。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcount_keywords_in_docx:\n    def test_count_keywords_in_docx_1(self):\n        doc = Document()\n        doc.add_paragraph('test'*10+'python'*5+'docx'*3)\n        doc.save('test1.docx')\n        assert count_keywords_in_docx('test1.docx', ['test', 'python', 'docx']) == {'test': 10, 'python': 5, 'docx': 3}\n\n", "problem": "定义一个python函数，使用docx包读取word文档，然后将文档中的所有段落的文本合并成为一个字符串。遍历关键词列表，统计关键词在字符串中出现的次数。最后调用函数输出结果。", "testcases": "from docx import Document\n\n\nclass Testcount_keywords_in_docx:\n    def test_count_keywords_in_docx_2(self):\n        doc = Document()\n        doc.add_paragraph('word' * 7 + 'document' * 4 + 'paragraph' * 2)\n        doc.save('test2.docx')\n        assert count_keywords_in_docx('test2.docx', ['word', 'document', 'paragraph']) == {'word': 7, 'document': 4, 'paragraph': 2}\n\n    def test_count_keywords_in_docx_3(self):\n        doc = Document()\n        doc.add_paragraph('string' * 5 + 'join' * 2 + 'for' * 7)\n        doc.save('test3.docx')\n        assert count_keywords_in_docx('test3.docx', ['string', 'join', 'for']) == {'string': 5, 'join': 2, 'for': 7}\n\n    def test_count_keywords_in_docx_4(self):\n        doc = Document()\n        doc.add_paragraph('in' * 10 + 'the' * 15 + 'and' * 7)\n        doc.save('test4.docx')\n        assert count_keywords_in_docx('test4.docx', ['in', 'the', 'and']) == {'in': 10, 'the': 15, 'and': 7}\n\n    def test_count_keywords_in_docx_5(self):\n        doc = Document()\n        doc.add_paragraph('test' * 10 + 'python' * 5 + 'docx' * 3)\n        doc.save('test5.docx')\n        assert count_keywords_in_docx('test5.docx', []) == {}\n\n    def test_count_keywords_in_docx_6(self):\n        doc = Document()\n        doc.add_paragraph('test' * 10 + 'python' * 5 + 'docx' * 3)\n        doc.save('test6.docx')\n        assert count_keywords_in_docx('test6.docx', ['in', 'the', 'and']) == {'and': 0, 'in': 0, 'the': 0}\n\n    def test_count_keywords_in_docx_7(self):\n        doc = Document()\n        doc.add_paragraph('')\n        doc.save('test7.docx')\n        assert count_keywords_in_docx('test7.docx', ['test', 'python', 'docx']) == {'docx': 0, 'python': 0, 'test': 0}", "setup_code": "", "reference_solution": "```python\nfrom docx import Document\n\n\ndef count_keywords_in_docx(docx_path, keywords):\n    doc = Document(docx_path)\n    text = \" \".join([paragraph.text for paragraph in doc.paragraphs])\n\n    keyword_counts = {}\n    for keyword in keywords:\n        count = text.lower().count(keyword.lower())\n        keyword_counts[keyword] = count\n\n    return keyword_counts\n\n```", "classification": "软件工程"}
{"_id": 172, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个python函数，接收一个路径参数，删除指定路径下的所有文件，如果成功删除则输出\"Successfully delete the folder.\"，否则输出\"Can't delete the folder.\"\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testdelete_folder:\n    def test_delete_folder_1(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        delete_folder(str(d))\n        assert not os.path.exists(str(d))\n\n", "problem": "编写一个python函数，接收一个路径参数，删除指定路径下的所有文件，如果成功删除则输出\"Successfully delete the folder.\"，否则输出\"Can't delete the folder.\"", "testcases": "import shutil\nimport os\n\n\nclass Testdelete_folder:\n    def test_delete_folder_2(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        (d / \"file.txt\").write_text(\"content\")\n        delete_folder(str(d))\n        assert not os.path.exists(str(d / \"file.txt\"))\n\n    def test_delete_folder_3(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        (d / \"file.txt\").write_text(\"content\")\n        (d / \"subsub\").mkdir()\n        delete_folder(str(d / 'subsub'))\n        assert os.path.exists(str(d / \"file.txt\"))\n        assert not os.path.exists(str(d / \"subsub\"))\n\n    def test_delete_folder_4(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        (d / \"file.txt\").write_text(\"content\")\n        (d / \"subsub\").mkdir()\n        (d / \"subsub\" / \"file.txt\").write_text(\"content\")\n        delete_folder(str(d / \"subsub\"))\n        assert not os.path.exists(str(d / \"subsub\" / \"file.txt\"))\n\n    def test_delete_folder_5(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        for i in range(1000):\n            (d / f\"file{i}.txt\").write_text(\"content\")\n        delete_folder(str(d))\n        assert not os.path.exists(str(d / \"file1.txt\"))\n\n    def test_delete_folder_6(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        for i in range(1000):\n            (d / f\"sub{i}\").mkdir()\n        delete_folder(str(d / \"sub1\"))\n        assert os.path.exists(str(d / \"sub2\"))\n        assert not os.path.exists(str(d / \"sub1\"))\n\n    def test_delete_folder_7(self, tmp_path):\n        d = tmp_path / \"sub\"\n        d.mkdir()\n        for i in range(1000):\n            (d / f\"sub{i}\").mkdir()\n            (d / f\"sub{i}\" / \"file.txt\").write_text(\"content\")\n        delete_folder(str(d / \"sub1\"))\n        assert os.path.exists(str(d / \"sub2\" / \"file.txt\"))\n        assert not os.path.exists(str(d / \"sub1\" / \"file.txt\"))", "setup_code": "", "reference_solution": "```python\nimport shutil\nimport os\n\ndef delete_folder(folder_path):\n    try:\n        if os.path.exists(folder_path):\n            if os.path.isdir(folder_path):\n                shutil.rmtree(folder_path)\n                print(f\"Successfully delete the folder.\")\n            else:\n                print(f\"{folder_path} is not a directory\")\n        else:\n            print(f\"Path not exist: {folder_path}\")\n    except Exception as e:\n        print(f\"Can't delete the folder.\")\n\n```", "classification": "软件工程"}
{"_id": 173, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n将一个scipy.sparse.csr_matrix转换为ndarray，并保存在npy文件中，\n其中csr_matrix初始被保存在npz文件中，需要先加载后转换\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcsr_to_numpy:\n    def test_csr_to_numpy_1(self):\n        csr_to_numpy('test1/test.npz', 'test1/test.npy')\n        assert np.array_equal(np.load('test1/test.npy'), np.load('test1/label.npy'))\n\n", "problem": "将一个scipy.sparse.csr_matrix转换为ndarray，并保存在npy文件中，\n其中csr_matrix初始被保存在npz文件中，需要先加载后转换", "testcases": "import numpy as np\nimport scipy.sparse as sp\n\n\nclass Testcsr_to_numpy:\n    def test_csr_to_numpy_2(self):\n        csr_to_numpy('test2/test.npz', 'test2/test.npy')\n        assert np.array_equal(np.load('test2/test.npy'), np.load('test2/label.npy'))\n\n    def test_csr_to_numpy_3(self):\n        csr_to_numpy('test3/test.npz', 'test3/test.npy')\n        assert np.array_equal(np.load('test3/test.npy'), np.load('test3/label.npy'))\n\n    def test_csr_to_numpy_4(self):\n        csr_to_numpy('test4/test.npz', 'test4/test.npy')\n        assert np.array_equal(np.load('test4/test.npy'), np.load('test4/label.npy'))\n\n    def test_csr_to_numpy_5(self):\n        csr_to_numpy('test5/test.npz', 'test5/test.npy')\n        assert np.array_equal(np.load('test5/test.npy'), np.load('test5/label.npy'))\n\n    def test_csr_to_numpy_6(self):\n        csr_to_numpy('test6/test.npz', 'test6/test.npy')\n        assert np.array_equal(np.load('test6/test.npy'), np.load('test6/label.npy'))\n\n    def test_csr_to_numpy_7(self):\n        csr_to_numpy('test7/test.npz', 'test7/test.npy')\n        assert np.array_equal(np.load('test7/test.npy'), np.load('test7/label.npy'))\n\n    def test_csr_to_numpy_8(self):\n        csr_to_numpy('test8/test.npz', 'test8/test.npy')\n        assert np.array_equal(np.load('test8/test.npy'), np.load('test8/label.npy'))\n\n    def test_csr_to_numpy_9(self):\n        csr_to_numpy('test9/test.npz', 'test9/test.npy')\n        assert np.array_equal(np.load('test9/test.npy'), np.load('test9/label.npy'))", "setup_code": "", "reference_solution": "```python\nimport numpy as np\nimport scipy.sparse as sp\n\n\ndef csr_to_numpy(input_file, output_file):\n    input_arr_csr = sp.load_npz(input_file)\n    input_arr = input_arr_csr.toarray()\n    np.save(output_file, input_arr)\n\n```", "classification": "数据科学"}
{"_id": 174, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n多线程拷贝源文件夹到多个目标目录下,要求每个线程处理一部分目标文件夹的拷贝工作，在所有线程结束后，记录结束时间，并输出用时。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcopy_folder:\n    def test_multithread_copy_1(self):\n        multithread_copy(self.source_folder, self.dest_folders[:7])\n        for folder in self.dest_folders[:7]:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n", "problem": "多线程拷贝源文件夹到多个目标目录下,要求每个线程处理一部分目标文件夹的拷贝工作，在所有线程结束后，记录结束时间，并输出用时。", "testcases": "import shutil\nimport os\nimport threading\n\nclass Testcopy_folder:\n    def test_multithread_copy_2(self):\n        multithread_copy(self.source_folder, self.dest_folders[:2])\n        for folder in self.dest_folders[:2]:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n    def test_multithread_copy_3(self):\n        multithread_copy(self.source_folder, self.dest_folders[:3])\n        for folder in self.dest_folders[:3]:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n    def test_multithread_copy_4(self):\n        multithread_copy(self.source_folder, self.dest_folders[:4])\n        for folder in self.dest_folders[:4]:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n    def test_multithread_copy_5(self):\n        multithread_copy(self.source_folder, self.dest_folders[:1])\n        for folder in self.dest_folders[:1]:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n    def test_multithread_copy_6(self):\n        multithread_copy(self.source_folder, self.dest_folders[:10])\n        for folder in self.dest_folders[:10]:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n    def test_multithread_copy_7(self):\n        multithread_copy(self.source_folder, self.dest_folders[:100])\n        for folder in self.dest_folders[:100]:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n    def test_multithread_copy_8(self):\n        multithread_copy(self.source_folder, self.dest_folders[:1000])\n        for folder in self.dest_folders[:1000]:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n    def test_multithread_copy_9(self):\n        multithread_copy(self.source_folder, self.dest_folders)\n        for folder in self.dest_folders:\n            assert os.path.exists(os.path.join(folder, \"test_file.txt\"))\n\n\n    def setup_method(self):\n        self.source_folder = \"source_folder\"\n        self.dest_folders = [f\"dest_folder{i}\" for i in range(5000)]\n        os.mkdir(self.source_folder)\n        for folder in self.dest_folders:\n            if os.path.exists(folder):\n                shutil.rmtree(folder)\n        with open(os.path.join(self.source_folder, \"test_file.txt\"), \"w\") as f:\n            f.write(\"test\")\n\n    def teardown_method(self):\n        shutil.rmtree(self.source_folder)\n        for folder in self.dest_folders:\n            if os.path.exists(folder):\n                shutil.rmtree(folder)\n", "setup_code": "", "reference_solution": "```python\nimport shutil\nimport os\nimport threading\nimport time\n\n\ndef copy_folder(source_folder, dest_folders):\n    for dest_folder in dest_folders:\n        try:\n            if os.path.exists(dest_folder):\n                shutil.rmtree(dest_folder)\n            shutil.copytree(source_folder, dest_folder)\n            print(\"success from {source_folder} to {dest_folder}\")\n        except Exception as e:\n            print(\"copy {source_folder} to {dest_folder} is err:{e}\")\ndef create_thread(source_folder, dest_folders):\n    # 计算每个线程需要拷贝的目标文件夹数量\n    threads_num = len(dest_folders)\n    folders_per_thread = len(dest_folders) // threads_num\n\n    threads = []\n    for i in range(threads_num):\n        start = i * folders_per_thread\n        end = start + folders_per_thread\n        if i == threads_num - 1:\n            end = len(dest_folders)\n        thread = threading.Thread(target=copy_folder, args=(source_folder, dest_folders[start:end]))\n        threads.append(thread)\n    \n    return threads\n    \ndef run(threads):\n    # 记录开始时间\n    start_time = time.time()\n    # 启动所有线程\n    for thread in threads:\n        thread.start()\n    # 等待所有线程结束\n    for thread in threads:\n        thread.join()\n    # 记录结束时间并输出用时\n    end_time = time.time()\n    print(f\"time: {end_time - start_time} 秒\")\n    \n    \ndef multithread_copy(source_folder, dest_folders):\n    threads = create_thread(source_folder, dest_folders)\n    run(threads)\n\n```", "classification": "操作系统"}
{"_id": 175, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n将一个稀疏的ndarray转换成一个scipy.sparse.csr_matrix，并保存在npz文件中，\n其中ndarray初始被保存在npy文件中，需要先加载后转换\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testnumpy_to_csr:\n    def test_case1(self):\n        numpy_to_csr('test1/test.npy', 'test1/test.npz')\n        test_arr = sp.load_npz('test1/test.npz').toarray()\n        label_arr = sp.load_npz('test1/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)\n\n", "problem": "将一个稀疏的ndarray转换成一个scipy.sparse.csr_matrix，并保存在npz文件中，\n其中ndarray初始被保存在npy文件中，需要先加载后转换", "testcases": "import numpy as np\nimport scipy.sparse as sp\n\n\nclass Testnumpy_to_csr:\n    def test_case2(self):\n        numpy_to_csr('test2/test.npy', 'test2/test.npz')\n        test_arr = sp.load_npz('test2/test.npz').toarray()\n        label_arr = sp.load_npz('test2/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)\n\n    def test_case3(self):\n        numpy_to_csr('test3/test.npy', 'test3/test.npz')\n        test_arr = sp.load_npz('test3/test.npz').toarray()\n        label_arr = sp.load_npz('test3/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)\n\n    def test_case4(self):\n        numpy_to_csr('test4/test.npy', 'test4/test.npz')\n        test_arr = sp.load_npz('test4/test.npz').toarray()\n        label_arr = sp.load_npz('test4/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)\n\n    def test_case5(self):\n        numpy_to_csr('test5/test.npy', 'test5/test.npz')\n        test_arr = sp.load_npz('test5/test.npz').toarray()\n        label_arr = sp.load_npz('test5/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)\n\n    def test_case6(self):\n        numpy_to_csr('test6/test.npy', 'test6/test.npz')\n        test_arr = sp.load_npz('test6/test.npz').toarray()\n        label_arr = sp.load_npz('test6/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)\n\n    def test_case7(self):\n        numpy_to_csr('test7/test.npy', 'test7/test.npz')\n        test_arr = sp.load_npz('test7/test.npz').toarray()\n        label_arr = sp.load_npz('test7/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)\n\n    def test_case8(self):\n        numpy_to_csr('test8/test.npy', 'test8/test.npz')\n        test_arr = sp.load_npz('test8/test.npz').toarray()\n        label_arr = sp.load_npz('test8/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)\n\n    def test_case9(self):\n        numpy_to_csr('test9/test.npy', 'test9/test.npz')\n        test_arr = sp.load_npz('test9/test.npz').toarray()\n        label_arr = sp.load_npz('test9/label.npz').toarray()\n        assert np.array_equal(test_arr, label_arr)", "setup_code": "", "reference_solution": "```python\nimport numpy as np\nimport scipy.sparse as sp\n\ndef numpy_to_csr(input_file, output_file):\n    input_arr = np.load(input_file)\n    input_arr_csr = sp.csr_matrix(input_arr)\n    sp.save_npz(output_file, input_arr_csr)\n```", "classification": "数据科学"}
{"_id": 176, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n使用sklearn计算两个矩阵的余弦相似度，\n矩阵A和B的维度相同，初始保存在matrix_A.npy和matrix_B.npy中\n最终结果为相似度矩阵，维度与矩阵A和B相同，保存在cos_sim.npy中\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcalculate_similarity:\n    def test_calculate_similarity_1(self):\n        A = np.array([[1, 2], [3, 4]])\n        B = np.array([[5, 6], [7, 8]])\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n", "problem": "使用sklearn计算两个矩阵的余弦相似度，\n矩阵A和B的维度相同，初始保存在matrix_A.npy和matrix_B.npy中\n最终结果为相似度矩阵，维度与矩阵A和B相同，保存在cos_sim.npy中", "testcases": "import numpy as np\n\n\nclass Testcalculate_similarity:\n    def test_calculate_similarity_2(self):\n        A = np.array([[1, 0], [0, 1]])\n        B = np.array([[0, 1], [1, 0]])\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n    def test_calculate_similarity_3(self):\n        A = np.array([[1, 1], [1, 1]])\n        B = np.array([[1, 1], [1, 1]])\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n    def test_calculate_similarity_4(self):\n        A = np.array([[1, 2, 3], [4, 5, 6]])\n        B = np.array([[7, 8, 9], [10, 11, 12]])\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n    def test_calculate_similarity_5(self):\n        A = np.array([[1, 0, 0], [0, 1, 0]])\n        B = np.array([[0, 0, 1], [0, 1, 0]])\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n    def test_calculate_similarity_6(self):\n        A = np.array([[1, 1, 1], [1, 1, 1]])\n        B = np.array([[1, 1, 1], [1, 1, 1]])\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n    def test_calculate_similarity_7(self):\n        A = np.zeros((1000, 1000))\n        B = np.ones((1000, 1000))\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n    def test_calculate_similarity_8(self):\n        A = np.ones((1000, 1000))\n        B = np.ones((1000, 1000))\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n    def test_calculate_similarity_9(self):\n        A = np.eye(1000)\n        B = np.eye(1000)\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))\n\n    def test_calculate_similarity_10(self):\n        A = np.random.rand(1000, 1000)\n        B = np.random.rand(1000, 1000)\n        np.save('matrix_A.npy', A)\n        np.save('matrix_B.npy', B)\n        calculate_similarity('matrix_A.npy', 'matrix_B.npy', 'cos_sim.npy')\n        result = np.load('cos_sim.npy')\n        assert np.array_equal(result, cosine_similarity(A, B))", "setup_code": "", "reference_solution": "```python\nimport numpy as np\nfrom sklearn.metrics.pairwise import cosine_similarity\n\n\ndef calculate_similarity(file_A, file_B, target_file):\n    A = np.load(file_A)\n    B = np.load(file_B)\n    cos_sim = cosine_similarity(A, B)\n    np.save(target_file, cos_sim)\n\n\n```", "classification": "人工智能"}
{"_id": 177, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n有两个形状为（X，Y，Z）的numpy数组将其装换为tensor类型和单精度浮点类型。将其中一个的形状改变为（X，Z，Y）.计算这两个矩阵的注意力分数。并输出结果。然后将结果写入一个名字为result.txt的文件中。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testprocess_tensor:\n    def test_process_tensor_1(self):\n        array1 = np.ones((3, 9, 5))\n        array2 = np.ones((3, 9, 5))\n        assert torch.all(torch.eq(process_tensor(array1, array2), torch.ones((3, 9, 9))*5))\n\n", "problem": "有两个形状为（X，Y，Z）的numpy数组将其装换为tensor类型和单精度浮点类型。将其中一个的形状改变为（X，Z，Y）.计算这两个矩阵的注意力分数。并输出结果。然后将结果写入一个名字为result.txt的文件中。", "testcases": "import torch\n\nclass Testprocess_tensor:\n    def test_process_tensor_2(self):\n        array1 = np.zeros((3, 9, 5))\n        array2 = np.ones((3, 9, 5))\n        assert torch.all(torch.eq(process_tensor(array1, array2), torch.zeros((3, 9, 9))))\n\n    def test_process_tensor_3(self):\n        array1 = np.ones((3, 9, 5))*2\n        array2 = np.ones((3, 9, 5))*3\n        assert torch.all(torch.eq(process_tensor(array1, array2), torch.ones((3, 9, 9))*30))\n\n    def test_process_tensor_4(self):\n        array1 = np.ones((3, 9, 5))*-1\n        array2 = np.ones((3, 9, 5))*-1\n        assert torch.all(torch.eq(process_tensor(array1, array2), torch.ones((3, 9, 9))*5))\n\n    def test_process_tensor_5(self):\n        array1 = np.ones((3, 9, 5))*-1\n        array2 = np.ones((3, 9, 5))\n        assert torch.all(torch.eq(process_tensor(array1, array2), torch.ones((3, 9, 9))*-5))\n\n    # boundary cases\n    def test_process_tensor_6(self):\n        array1 = np.ones((1, 1, 1))\n        array2 = np.ones((1, 1, 1))\n        assert torch.all(torch.eq(process_tensor(array1, array2), torch.ones((1, 1, 1))))\n\n    def test_process_tensor_7(self):\n        array1 = np.ones((100, 130, 80))\n        array2 = np.ones((100, 130, 80))\n        assert torch.all(torch.eq(process_tensor(array1, array2), torch.ones((100, 130, 130))*80))\n\n    def test_process_tensor_8(self):\n        array1 = np.ones((2, 2, 2))*np.inf\n        array2 = np.ones((2, 2, 2))\n        assert torch.all(torch.eq(process_tensor(array1, array2), torch.ones((2, 2, 2))*np.inf))\n\n    def test_process_tensor_9(self):\n        array1 = np.ones((2, 2, 2))*np.nan\n        array2 = np.ones((2, 2, 2))\n        assert torch.all(torch.isnan(process_tensor(array1, array2)))", "setup_code": "", "reference_solution": "```python\nimport torch\nimport numpy as np\n\n\ndef process_tensor(array1, array2):\n    tensor1 = torch.FloatTensor(array1)\n    tensor2 = torch.FloatTensor(array2)\n    tensor2 = tensor2.permute(0, 2, 1)\n    attention_scores = torch.bmm(tensor1, tensor2)\n    with open('result.txt', 'w') as file:\n        file.write(str(attention_scores))\n    return attention_scores\n\n\narray1 = np.ones((100, 130, 80))\narray2 = np.ones((100, 130, 80))\nprint(process_tensor(array1, array2).shape)\n\n\n```", "classification": "人工智能"}
{"_id": 178, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n用python函数编写欧几里得、曼哈顿、切比雪夫、闵可夫斯基、余弦相似度、汉明距离、Jaccard相似度等距离计算方法。手动编写数据调用这些距离计算函数。输出计算结果。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testeuclidean_distance:\n    def test_euclidean_distance_1(self):\n        assert euclidean_distance((1, 2, 3), (4, 5, 6)) == 5.196152422706632\n        assert manhattan_distance((1, 2, 3), (4, 5, 6)) == 9\n        assert chebyshev_distance((1, 2, 3), (4, 5, 6)) == 3\n        assert minkowski_distance((1, 2, 3), (4, 5, 6), 2) == 6.244997998398398\n        assert cosine_similarity([1, 2, 3], [4, 5, 6]) == 0.9746318461970762\n        assert hamming_distance(\"1010101\", \"1001001\") == 3\n        assert jaccard_similarity({1, 2, 3, 4, 5}, {4, 5, 6, 7, 8}) == 0.25\n\n", "problem": "用python函数编写欧几里得、曼哈顿、切比雪夫、闵可夫斯基、余弦相似度、汉明距离、Jaccard相似度等距离计算方法。手动编写数据调用这些距离计算函数。输出计算结果。", "testcases": "\n\nclass Testeuclidean_distance:\n    def test_euclidean_distance_2(self):\n        assert euclidean_distance((0, 0), (0, 0)) == 0\n        assert manhattan_distance((0, 0), (0, 0)) == 0\n        assert chebyshev_distance((0, 0), (0, 0)) == 0\n        assert minkowski_distance((0, 0), (0, 0), 2) == 1.4142135623730951\n        assert cosine_similarity([0, 1], [0, 1]) == 1\n        assert hamming_distance(\"0000000\", \"0000000\") == 0\n        assert jaccard_similarity({1, 2, 3}, {4, 5, 6}) == 0\n\n    def test_euclidean_distance_3(self):\n        assert euclidean_distance((1, 1), (-1, -1)) == 2.8284271247461903\n        assert manhattan_distance((1, 1), (-1, -1)) == 4\n        assert chebyshev_distance((1, 1), (-1, -1)) == 2\n        assert minkowski_distance((1, 1), (-1, -1), 2) == 2.0\n        assert cosine_similarity([1, 1], [-1, -1]) == -0.9999999999999998\n        assert hamming_distance(\"1111111\", \"0000000\") == 7\n        assert jaccard_similarity({1, 2, 3}, {1, 2, 3}) == 1\n\n    def test_euclidean_distance_4(self):\n        assert euclidean_distance((1, 2, 3, 4), (5, 6, 7, 8)) == 8.0\n        assert manhattan_distance((1, 2, 3, 4), (5, 6, 7, 8)) == 16\n        assert chebyshev_distance((1, 2, 3, 4), (5, 6, 7, 8)) == 4\n        assert minkowski_distance((1, 2, 3, 4), (5, 6, 7, 8), 2) == 18.439088914585774\n        assert cosine_similarity([1, 2, 3, 4], [5, 6, 7, 8]) == 0.9688639316269662\n        assert hamming_distance(\"1010101\", \"0101010\") == 7\n        assert jaccard_similarity({1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}) == 0\n\n    def test_euclidean_distance_5(self):\n        assert euclidean_distance((1, 1, 1, 1), (2, 2, 2, 2)) == 2.0\n        assert manhattan_distance((1, 1, 1, 1), (2, 2, 2, 2)) == 4\n        assert chebyshev_distance((1, 1, 1, 1), (2, 2, 2, 2)) == 1\n        assert minkowski_distance((1, 1, 1, 1), (2, 2, 2, 2), 2) == 2.0\n        assert cosine_similarity([1] * 100, [100] * 100) == 1.0\n        assert hamming_distance(\"1101001\", \"1010110\") == 6\n        assert jaccard_similarity({143, 2, 1234, 4, 5, 23}, {422, 5, 346, 7343, 1234123, 1}) == 0.09090909090909091\n\n    def test_euclidean_distance_6(self):\n        assert euclidean_distance((1, 2, 3, 4, 5), (6, 7, 8, 9, 10)) == 11.180339887498949\n        assert manhattan_distance((1, 2, 3, 4, 5), (6, 7, 8, 9, 10)) == 25\n        assert chebyshev_distance((1, 2, 3, 4, 5), (6, 7, 8, 9, 10)) == 5\n        assert minkowski_distance((1, 2, 3, 4, 5), (6, 7, 8, 9, 10), 2) == 62.489999199871974\n        assert cosine_similarity([1] * 100 + [2] * 100 + [3] * 100, [100] * 300) == 0.9258200997725514\n        assert hamming_distance(\"1100110\", \"0011001\") == 7\n        assert jaccard_similarity({143, 2, 1234, 4, 5, 23, 123}, {1, 2, 3, 4, 5, 6, 7}) == 0.2727272727272727\n", "setup_code": "", "reference_solution": "```python\nimport math\n\ndef euclidean_distance(point1, point2):\n    return math.sqrt(sum((p - q) ** 2 for p, q in zip(point1, point2)))\n\ndef manhattan_distance(point1, point2):\n    return sum(abs(p - q) for p, q in zip(point1, point2))\n\ndef chebyshev_distance(point1, point2):\n    return max(abs(p - q) for p, q in zip(point1, point2))\n\ndef minkowski_distance(point1, point2, p):\n    return math.pow(sum(abs(p - q) ** p for p, q in zip(point1, point2)), 1/p)\n\ndef cosine_similarity(vector1, vector2):\n    dot_product = sum(p * q for p, q in zip(vector1, vector2))\n    norm_vector1 = math.sqrt(sum(p ** 2 for p in vector1))\n    norm_vector2 = math.sqrt(sum(q ** 2 for q in vector2))\n    return dot_product / (norm_vector1 * norm_vector2)\n\n\ndef hamming_distance(string1, string2):\n    return sum(p != q for p, q in zip(string1, string2))\n\ndef jaccard_similarity(set1, set2):\n    intersection_size = len(set1.intersection(set2))\n    union_size = len(set1.union(set2))\n    return intersection_size / union_size\n\n\n\n\n```", "classification": "算法和数据结构"}
{"_id": 179, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n假若有一个size=[N*N]的矩阵，如何将他的对角线以上的值设为零，输出结果矩阵，然后计算剩下的值的加和，并输出加和\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testdiag_zero:\n    def test_diag_zero_1(self):\n        matrix = np.arange(1, 10).reshape(3, 3)\n        assert diag_zero(matrix) == 34\n\n", "problem": "假若有一个size=[N*N]的矩阵，如何将他的对角线以上的值设为零，输出结果矩阵，然后计算剩下的值的加和，并输出加和", "testcases": "\n\nclass Testdiag_zero:\n    def test_diag_zero_2(self):\n        matrix = np.arange(1, 17).reshape(4, 4)\n        assert diag_zero(matrix) == 100\n\n    def test_diag_zero_3(self):\n        matrix = np.arange(1, 26).reshape(5, 5)\n        assert diag_zero(matrix) == 235\n\n    def test_diag_zero_4(self):\n        matrix = np.arange(1, 37).reshape(6, 6)\n        assert diag_zero(matrix) == 476\n\n    def test_diag_zero_5(self):\n        matrix = np.arange(1, 50).reshape(7, 7)\n        assert diag_zero(matrix) == 868\n\n    def test_diag_zero_6(self):\n        matrix = np.arange(1, 65).reshape(8, 8)\n        assert diag_zero(matrix) == 1464\n\n    def test_diag_zero_7(self):\n        matrix = np.ones((1, 1))\n        assert diag_zero(matrix) == 1\n\n    def test_diag_zero_8(self):\n        matrix = np.ones((2, 2))\n        assert diag_zero(matrix) == 3\n\n    def test_diag_zero_9(self):\n        matrix = np.ones((3, 3))\n        assert diag_zero(matrix) == 6\n\n    def test_diag_zero_10(self):\n        matrix = np.ones((4, 4))\n        assert diag_zero(matrix) == 10", "setup_code": "", "reference_solution": "```python\nimport numpy as np\n\ndef diag_zero(matrix):\n    matrix[np.triu_indices(matrix.shape[0], k=1)] = 0\n    sum_remaining_values = np.sum(matrix)\n    return sum_remaining_values\n\nmatrix = np.arange(1, 10).reshape(3, 3)\nprint(diag_zero(matrix))\n\n\n```", "classification": "算法和数据结构"}
{"_id": 180, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n假设有一个size=[N，N]的numpy列表，求数组元素的平均值，让后将大于平均值的元素不变，小于平均值的元素置为1，并将数组展开为一维列表，并输出结果\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testarray_avg:\n    def test_array_avg_1(self):\n        matrix = np.array([[2,1,4,3],[4,5,8,9],[10,2,3,4],[1,14,21,2]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 5.8125\n        assert np.all(flattened_array == np.array([2, 1, 4, 3, 4, 5, 0, 0, 0, 2, 3, 4, 1, 0, 0, 2]))\n\n", "problem": "假设有一个size=[N，N]的numpy列表，求数组元素的平均值，让后将大于平均值的元素不变，小于平均值的元素置为1，并将数组展开为一维列表，并输出结果", "testcases": "\n\nclass Testarray_avg:\n    def test_array_avg_2(self):\n        matrix = np.array([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 1\n        assert np.all(flattened_array == np.array([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]))\n\n    def test_array_avg_3(self):\n        matrix = np.array([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 0\n        assert np.all(flattened_array == np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]))\n\n    def test_array_avg_4(self):\n        matrix = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 8.5\n        assert np.all(flattened_array == np.array([1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0]))\n\n    def test_array_avg_5(self):\n        matrix = np.array([[10,20,30,40],[50,60,70,80],[90,100,110,120],[130,140,150,160]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 85\n        assert np.all(flattened_array == np.array([10, 20, 30, 40, 50, 60, 70, 80,  0,  0,  0,  0,  0,  0,  0,  0]))\n\n    def test_array_avg_6(self):\n        matrix = np.array([[1,2,3,4],[4,3,2,1],[1,2,3,4],[4,3,2,1]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 2.5\n        assert np.all(flattened_array == np.array([1, 2, 0, 0, 0, 0, 2, 1, 1, 2, 0, 0, 0, 0, 2, 1]))\n\n    def test_array_avg_7(self):\n        matrix = np.array([[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 2.5\n        assert np.all(flattened_array == np.array([1, 1, 1, 1, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0]))\n\n    def test_array_avg_8(self):\n        matrix = np.array([[1,1,1,1],[1,1,1,1],[1,1,1,1],[100,100,100,100]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 25.75\n        assert np.all(flattened_array == np.array([1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0]))\n\n    def test_array_avg_9(self):\n        matrix = np.array([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1000,1000,1000,1000]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 250.75\n        assert np.all(flattened_array == np.array([1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0]))\n\n    def test_array_avg_10(self):\n        matrix = np.array([[1,1,1,1],[1,1,1,1],[1,1,1,1],[10000,10000,10000,10000]])\n        mean_value, flattened_array = array_avg(matrix)\n        assert mean_value == 2500.75\n        assert np.all(flattened_array == np.array([1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0]))", "setup_code": "", "reference_solution": "```python\nimport numpy as np\n\n\ndef array_avg(matrix):\n    # 计算数组元素的平均值\n    mean_value = np.mean(matrix)\n\n    # 大于平均值的元素置为零\n    matrix[matrix > mean_value] = 0\n\n    # 将数组展开为一维列表\n    flattened_array = matrix.flatten()\n    return mean_value, flattened_array\n\nmatrix = [[2,1,4,3],[4,5,8,9],[10,2,3,4],[1,14,21,2]]\nmatrix = np.array(matrix)\nprint(array_avg(matrix))\n\n```", "classification": "算法和数据结构"}
{"_id": 181, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n有一个目录下有多个子目录,每个子目录下有不同数量的文件,请使用python编写一个程序,计算这个目录下总共有多少个文件,并打印出来\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcount_files:\n    def test_case1(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"hello.txt\")\n        p.write(\"content\")\n        assert count_files(tmpdir) == 1\n\n", "problem": "有一个目录下有多个子目录,每个子目录下有不同数量的文件,请使用python编写一个程序,计算这个目录下总共有多少个文件,并打印出来", "testcases": "\n\nclass Testcount_files:\n    def test_case2(self, tmpdir):\n        p1 = tmpdir.mkdir(\"sub1\").join(\"hello.txt\")\n        p1.write(\"content\")\n        p2 = tmpdir.mkdir(\"sub2\").join(\"world.txt\")\n        p2.write(\"content\")\n        assert count_files(tmpdir) == 2\n\n    def test_case3(self, tmpdir):\n        p1 = tmpdir.mkdir(\"sub1\").join(\"hello.txt\")\n        p1.write(\"content\")\n        p2 = tmpdir.mkdir(\"sub2\").join(\"world.txt\")\n        p2.write(\"content\")\n        p3 = tmpdir.mkdir(\"sub3\").join(\"file.txt\")\n        p3.write(\"content\")\n        assert count_files(tmpdir) == 3\n\n    def test_case4(self, tmpdir):\n        p1 = tmpdir.mkdir(\"sub1\").join(\"hello.txt\")\n        p1.write(\"content\")\n        p2 = tmpdir.mkdir(\"sub2\").join(\"world.txt\")\n        p2.write(\"content\")\n        assert count_files(tmpdir) == 2\n\n    def test_case5(self, tmpdir):\n        assert count_files(tmpdir) == 0\n\n    def test_case6(self, tmpdir):\n        p1 = tmpdir.mkdir(\"sub1\").join(\"hello.txt\")\n        p1.write(\"content\")\n        p2 = tmpdir.mkdir(\"sub2\").join(\"world.txt\")\n        p2.write(\"content\")\n        p3 = tmpdir.mkdir(\"sub3\").join(\"file.txt\")\n        p3.write(\"content\")\n        p4 = tmpdir.mkdir(\"sub4\").join(\"example.txt\")\n        p4.write(\"content\")\n        assert count_files(tmpdir) == 4\n\n    # Boundary test cases\n    def test_case7(self, tmpdir):\n        for i in range(100):\n            p = tmpdir.mkdir(f\"sub{i}\").join(\"file.txt\")\n            p.write(\"content\")\n        assert count_files(tmpdir) == 100\n\n    def test_case8(self, tmpdir):\n        for i in range(1000):\n            p = tmpdir.mkdir(f\"sub{i}\").join(\"file.txt\")\n            p.write(\"content\")\n        assert count_files(tmpdir) == 1000\n\n    def test_case9(self, tmpdir):\n        for i in range(500):\n            p = tmpdir.mkdir(f\"sub{i}\").join(\"file.txt\")\n            p.write(\"content\")\n        assert count_files(tmpdir) == 500\n\n    def test_case10(self, tmpdir):\n        for i in range(10000):\n            p = tmpdir.mkdir(f\"sub{i}\").join(\"file.txt\")\n            p.write(\"content\")\n        assert count_files(tmpdir) == 10000", "setup_code": "", "reference_solution": "```python\nimport os\n\ndef count_files(dir):\n    count = 0\n    for root, dirs, files in os.walk(dir):\n        count += len(files)\n    return count\n\n```", "classification": "操作系统"}
{"_id": 182, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n使用sklearn库中的PCA对characters进行降维，并查看每个主成分的解释度，\n其中characters是一个pandas.DataFrame，每一行是一个样本，每一列是一个特征，从./characters.csv中导入\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testpac_fit:\n    def test_pac_fit_1(self):\n        df = pd.DataFrame({'A': [1, 2, 3, 4, 5], 'B': [2, 3, 4, 5, 6], 'C': [3, 4, 5, 6, 7]})\n        df.to_csv('test.csv', index=False)\n        assert np.allclose(pac_fit('test.csv'), np.array([1.00000000e+00, 1.23259516e-32, 4.24471989e-95]), atol=1e-7)\n\n", "problem": "使用sklearn库中的PCA对characters进行降维，并查看每个主成分的解释度，\n其中characters是一个pandas.DataFrame，每一行是一个样本，每一列是一个特征，从./characters.csv中导入", "testcases": "import pandas as pd\nfrom sklearn.preprocessing import StandardScaler\nimport numpy as np\n\n\nclass Testpac_fit:\n    def test_pac_fit_2(self):\n        df = pd.DataFrame({'A': [1, 1, 1, 1, 1], 'B': [1, 1, 1, 1, 1], 'C': [1, 1, 1, 1, 1]})\n        df.to_csv('test.csv', index=False)\n        assert np.isnan(pac_fit('test.csv')).all()\n\n    def test_pac_fit_3(self):\n        df = pd.DataFrame({'A': [1, 2, 3, 4, 5], 'B': [5, 4, 3, 2, 1], 'C': [2, 3, 4, 5, 6]})\n        df.to_csv('test.csv', index=False)\n        assert np.allclose(pac_fit('test.csv'), np.array([1.00000000e+00, 1.23259516e-32, 4.24471989e-95]), atol=1e-8)\n\n    def test_pac_fit_4(self):\n        df = pd.DataFrame({'A': [1, 2, 3, 4, 5], 'B': [2, 3, 4, 5, 6], 'C': [3, 4, 5, 6, 7]})\n        df.to_csv('test.csv', index=False)\n        assert np.allclose(pac_fit('test.csv'), np.array([1.00000000e+00, 1.23259516e-32, 4.24471989e-95]), atol=1e-8)\n\n    def test_pac_fit_5(self):\n        df = pd.DataFrame({'A': [1, 2, 3, 4, 5], 'B': [2, 3, 4, 5, 6], 'C': [3, 4, 5, 6, 7]})\n        df.to_csv('test.csv', index=False)\n        assert np.allclose(pac_fit('test.csv'), np.array([1.00000000e+00, 1.23259516e-32, 4.24471989e-95]), atol=1e-8)\n\n    def test_pac_fit_6(self):\n        df = pd.DataFrame({'A': [1, 2, 3, 4, 5], 'B': [2, 3, 4, 5, 6], 'C': [3, 4, 5, 6, 7]})\n        df.to_csv('test.csv', index=False)\n        assert np.allclose(pac_fit('test.csv'), np.array([1.00000000e+00, 1.23259516e-32, 4.24471989e-95]), atol=1e-8)\n\n    def test_pac_fit_7(self):\n        df = pd.DataFrame({'A': [1], 'B': [2], 'C': [3]})\n        df.to_csv('test.csv', index=False)\n        assert np.isnan(pac_fit('test.csv')).all()\n\n    def test_pac_fit_8(self):\n        df = pd.DataFrame({'A': [1, 2], 'B': [2, 3], 'C': [3, 4]})\n        df.to_csv('test.csv', index=False)\n        assert np.allclose(pac_fit('test.csv'), np.array([1.00000000e+00, 2.05432527e-33]), atol=1e-8)\n\n    def test_pac_fit_9(self):\n        df = pd.DataFrame({'A': [1, 2, 3], 'B': [2, 3, 4], 'C': [3, 4, 5]})\n        df.to_csv('test.csv', index=False)\n        assert np.allclose(pac_fit('test.csv'), np.array([1.00000000e+00, 1.23259516e-32, 4.24471989e-95]), atol=1e-8)\n\n    def test_pac_fit_10(self):\n        df = pd.DataFrame({'A': [1, 2, 3, 4], 'B': [2, 3, 4, 5], 'C': [3, 4, 5, 6]})\n        df.to_csv('test.csv', index=False)\n        assert np.allclose(pac_fit('test.csv'), np.array([1.00000000e+00, 1.23259516e-32, 4.24471989e-95]), atol=1e-8)", "setup_code": "", "reference_solution": "```python\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\n\ndef pac_fit(input_file):\n    characters = pd.read_csv(input_file)\n    characters = StandardScaler().fit_transform(characters)\n    pca = PCA().fit(characters)\n    return pca.explained_variance_ratio_\n\n\ndf = pd.DataFrame({'A': [1, 2], 'B': [2, 3], 'C': [3, 4]})\ndf.to_csv('test.csv', index=False)\nprint(pac_fit('test.csv'))\n```", "classification": "人工智能"}
{"_id": 183, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n设计一个备份程序，要求以Python语言编写。程序输入为源路径和目标路径。完成对指定文件夹（例如data文件夹）下的内容的备份。每次备份应包含时间戳，并对备份文件进行压缩。压缩后的备份文件应存储在另一个指定文件夹（例如backup文件夹）下。备份文件夹下可能已经有部分备份文件，当备份文件夹中的总大小超过阈值(MB)时，程序应自动删除最旧的备份文件以释放空间。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testbackup:\n    def test_backup_1(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 1\n\n", "problem": "设计一个备份程序，要求以Python语言编写。程序输入为源路径和目标路径。完成对指定文件夹（例如data文件夹）下的内容的备份。每次备份应包含时间戳，并对备份文件进行压缩。压缩后的备份文件应存储在另一个指定文件夹（例如backup文件夹）下。备份文件夹下可能已经有部分备份文件，当备份文件夹中的总大小超过阈值(MB)时，程序应自动删除最旧的备份文件以释放空间。", "testcases": "import os\nimport shutil\nimport zipfile\nfrom datetime import datetime\nimport time\n\n\nclass Testbackup:\n    def test_backup_2(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.00001)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 0\n\n    def test_backup_3(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 1\n\n    def test_backup_4(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 2\n\n    def test_backup_5(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.00001)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.02)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 1\n\n    def test_backup_6(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 3\n\n    def test_backup_7(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 4\n\n    def test_backup_8(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.000001)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 0\n\n    def test_backup_9(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.01)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 6\n\n    def test_backup_10(self, tmp_path):\n        source_path = tmp_path / \"source\"\n        backup_folder = tmp_path / \"backup\"\n        source_path.mkdir()\n        backup_folder.mkdir()\n        (source_path / \"file1.txt\").write_text(\"Hello, World!\")\n        backup(source_path, backup_folder, max_size_mb=0.000001)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.000001)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.000001)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.000001)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.000001)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.000001)\n        time.sleep(1)\n        backup(source_path, backup_folder, max_size_mb=0.000001)\n        assert len(list(backup_folder.glob(\"*.zip\"))) == 0\n", "setup_code": "", "reference_solution": "```python\nimport os\nimport shutil\nimport zipfile\nfrom datetime import datetime\nimport glob\n\ndef backup(source_path, backup_folder, max_size_mb=10):\n    # 创建备份文件夹\n    if not os.path.exists(backup_folder):\n        os.makedirs(backup_folder)\n\n    # 生成时间戳\n    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')\n\n    # 构建备份文件名\n    backup_filename = f\"backup_{timestamp}.zip\"\n    backup_path = os.path.join(backup_folder, backup_filename)\n\n    # 备份文件夹\n    shutil.make_archive(backup_path[:-4], 'zip', source_path)\n\n    # 获取备份文件夹总大小\n    total_size_mb = sum(os.path.getsize(f) for f in glob.glob(os.path.join(backup_folder, '*.zip'))) / (1024 ** 2)\n\n    # 如果总大小超过设定的阈值，删除最旧的备份文件\n    while total_size_mb > max_size_mb:\n        oldest_backup = min(glob.glob(os.path.join(backup_folder, '*.zip')), key=os.path.getctime)\n        total_size_mb -= os.path.getsize(oldest_backup) / (1024 ** 2)\n        os.remove(oldest_backup)\n\n    print(f\"Backup completed: {backup_path}\")\n```", "classification": "操作系统"}
{"_id": 184, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n请使用python语言，pytorch包，请计算出两组bounding box的iou，\n\n每组bounding box的维度是[N, 4]，代表着N个bounding box，然后4代表着[x, y, w, h]\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testbbox_iou:\n    def test_bbox_iou_1(self):\n        boxes1 = torch.tensor([[10, 20, 30, 40], [30, 40, 50, 60]])\n        boxes2 = torch.tensor([[15, 25, 35, 45], [40, 50, 60, 70]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([0.5914, 0.5238]), atol=1e-4)\n\n", "problem": "请使用python语言，pytorch包，请计算出两组bounding box的iou，\n\n每组bounding box的维度是[N, 4]，代表着N个bounding box，然后4代表着[x, y, w, h]", "testcases": "import torch\n\n\nclass Testbbox_iou:\n    def test_bbox_iou_2(self):\n        boxes1 = torch.tensor([[0, 0, 10, 10]])\n        boxes2 = torch.tensor([[0, 0, 10, 10]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([1.0]), atol=1e-4)\n\n    def test_bbox_iou_3(self):\n        boxes1 = torch.tensor([[0, 0, 10, 10]])\n        boxes2 = torch.tensor([[10, 10, 10, 10]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([0.0]), atol=1e-4)\n\n    def test_bbox_iou_4(self):\n        boxes1 = torch.tensor([[0, 0, 10, 10]])\n        boxes2 = torch.tensor([[5, 5, 10, 10]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([0.1429]), atol=1e-4)\n\n    def test_bbox_iou_5(self):\n        boxes1 = torch.tensor([[0, 0, 10, 10]])\n        boxes2 = torch.tensor([[5, 5, 5, 5]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([0.0526]), atol=1e-4)\n\n    def test_bbox_iou_6(self):\n        boxes1 = torch.tensor([[0, 0, 10, 10]])\n        boxes2 = torch.tensor([[5, 5, 15, 15]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([0.2093]), atol=1e-4)\n\n    def test_bbox_iou_7(self):\n        boxes1 = torch.tensor([[0, 0, 0, 0]])\n        boxes2 = torch.tensor([[0, 0, 0, 0]])\n        assert torch.isnan(bbox_iou(boxes1, boxes2))\n\n    def test_bbox_iou_8(self):\n        boxes1 = torch.tensor([[0, 0, 100, 100]])\n        boxes2 = torch.tensor([[0, 0, 100, 100]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([1.0]), atol=1e-4)\n\n    def test_bbox_iou_9(self):\n        boxes1 = torch.tensor([[0, 0, 100, 100]])\n        boxes2 = torch.tensor([[100, 100, 100, 100]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([0.0]), atol=1e-4)\n\n    def test_bbox_iou_10(self):\n        boxes1 = torch.tensor([[0, 0, 100, 100]])\n        boxes2 = torch.tensor([[50, 50, 100, 100]])\n        assert torch.allclose(bbox_iou(boxes1, boxes2), torch.tensor([0.1429]), atol=1e-4)", "setup_code": "", "reference_solution": "```python\nimport torch\n\ndef bbox_iou(boxes1, boxes2):\n    \"\"\"\n    计算两组对应位置bounding boxes的IoU。\n    \n    参数:\n    boxes1, boxes2: 维度为[N, 4]的tensor，表示bounding boxes，格式为[x, y, w, h]。\n    \n    返回:\n    一个长度为N的tensor，表示boxes1和boxes2中对应box的IoU。\n    \"\"\"\n    assert boxes1.shape == boxes2.shape\n    boxes1_x1 = boxes1[:, 0] - boxes1[:, 2] / 2\n    boxes1_y1 = boxes1[:, 1] - boxes1[:, 3] / 2\n    boxes1_x2 = boxes1[:, 0] + boxes1[:, 2] / 2\n    boxes1_y2 = boxes1[:, 1] + boxes1[:, 3] / 2\n\n    boxes2_x1 = boxes2[:, 0] - boxes2[:, 2] / 2\n    boxes2_y1 = boxes2[:, 1] - boxes2[:, 3] / 2\n    boxes2_x2 = boxes2[:, 0] + boxes2[:, 2] / 2\n    boxes2_y2 = boxes2[:, 1] + boxes2[:, 3] / 2\n\n\n    inter_x1 = torch.max(boxes1_x1, boxes2_x1)\n    inter_y1 = torch.max(boxes1_y1, boxes2_y1)\n    inter_x2 = torch.min(boxes1_x2, boxes2_x2)\n    inter_y2 = torch.min(boxes1_y2, boxes2_y2)\n\n    inter_area = torch.clamp(inter_x2 - inter_x1, min=0) * torch.clamp(inter_y2 - inter_y1, min=0)\n\n\n    boxes1_area = (boxes1_x2 - boxes1_x1) * (boxes1_y2 - boxes1_y1)\n    boxes2_area = (boxes2_x2 - boxes2_x1) * (boxes2_y2 - boxes2_y1)\n\n\n    union_area = boxes1_area + boxes2_area - inter_area\n\n\n    iou = inter_area / union_area\n\n    return iou\n\n\n\n\n```", "classification": "人工智能"}
{"_id": 185, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n我们需要对Nginx服务器的访问日志进行统计，并监控高频率访问的用户。这将帮助我们识别潜在的异常活动、进行性能优化，并及时应对可能的攻击。要求使用python统计nginx日志中每个IP地址的访问次数。将统计结果落到一个data文件夹下的数据文件中，以供进一步分析和审计。\n监控高频率访问的用户，定义高频率的标准为1秒内超过30次访问。\n要求1：\n使用脚本从Nginx访问日志中提取IP地址，并统计每个IP地址的访问次数。\n要求2：高频率访问监控\n标识并记录高频率访问的IP地址，以便后续处理。高频率定义为1秒内超过30次访问。如果该IP是高频异常IP，则将其记录到一个单独的文件中，以便后续分析。\n要求3 数据输出\n将统计结果输出到一个数据文件中，格式包括IP地址和对应的访问次数。这个数据文件将用于进一步分析和审计。\n要求4 文件格式\n所有文件的格式都为JSON文件，其中key为IP地址，value为访问次数\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testnginx_log_analysis:\n    def test_nginx_log_analysis_1(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        nginx_log_file.write(\"192.168.1.1 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 35)\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 35}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 35}\n\n", "problem": "我们需要对Nginx服务器的访问日志进行统计，并监控高频率访问的用户。这将帮助我们识别潜在的异常活动、进行性能优化，并及时应对可能的攻击。要求使用python统计nginx日志中每个IP地址的访问次数。将统计结果落到一个data文件夹下的数据文件中，以供进一步分析和审计。\n监控高频率访问的用户，定义高频率的标准为1秒内超过30次访问。\n要求1：\n使用脚本从Nginx访问日志中提取IP地址，并统计每个IP地址的访问次数。\n要求2：高频率访问监控\n标识并记录高频率访问的IP地址，以便后续处理。高频率定义为1秒内超过30次访问。如果该IP是高频异常IP，则将其记录到一个单独的文件中，以便后续分析。\n要求3 数据输出\n将统计结果输出到一个数据文件中，格式包括IP地址和对应的访问次数。这个数据文件将用于进一步分析和审计。\n要求4 文件格式\n所有文件的格式都为JSON文件，其中key为IP地址，value为访问次数", "testcases": "import re\nfrom collections import defaultdict\n\nclass Testnginx_log_analysis:\n    def test_nginx_log_analysis_2(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        nginx_log_file.write(\"192.168.1.1 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 30)\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 30}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {}\n\n    def test_nginx_log_analysis_3(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        nginx_log_file.write(\"\")\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {}\n\n    def test_nginx_log_analysis_4(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        content = \"192.168.1.1 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 20 + \"192.168.1.2 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 25\n        nginx_log_file.write(content)\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 20, \"192.168.1.2\": 25}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {}\n\n    def test_nginx_log_analysis_5(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        content = \"192.168.1.1 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 31 + \"192.168.1.2 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 31\n        nginx_log_file.write(content)\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 31, \"192.168.1.2\": 31}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 31, \"192.168.1.2\": 31}\n\n    def test_nginx_log_analysis_6(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        nginx_log_file.write(\"192.168.1.1 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 0)\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {}\n\n    def test_nginx_log_analysis_7(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        nginx_log_file.write(\"192.168.1.1 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 1)\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 1}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {}\n\n    def test_nginx_log_analysis_8(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        nginx_log_file.write(\"192.168.1.1 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 100)\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 100}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 100}\n\n    def test_nginx_log_analysis_9(self, tmpdir):\n        nginx_log_file = tmpdir.join(\"nginx.log\")\n        nginx_log_file.write(\"192.168.1.1 - - [01/Jan/2021:00:00:01 +0000] \\\"GET / HTTP/1.1\\\" 200 612\\n\" * 500)\n        statistics_output_file = tmpdir.join(\"statistics.json\")\n        high_frequency_output_file = tmpdir.join(\"high_frequency.json\")\n        nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file)\n        with open(statistics_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 500}\n        with open(high_frequency_output_file, 'r') as f:\n            assert json.load(f) == {\"192.168.1.1\": 500}", "setup_code": "", "reference_solution": "```python\nimport re\nfrom collections import defaultdict\nimport json\n\ndef nginx_log_analysis(nginx_log_file, statistics_output_file, high_frequency_output_file):\n    # 定义一个字典用于存储IP地址访问次数\n    ip_count = defaultdict(int)\n\n    # 定义一个集合用于存储高频率访问的IP地址\n    high_frequency_ips = defaultdict(int)\n    \n    # 定义正则表达式来匹配IP地址\n    ip_pattern = re.compile(r'\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b')\n    \n    # 打开Nginx日志文件并逐行处理\n    with open(nginx_log_file, 'r') as file:\n        for line in file:\n            # 使用正则表达式匹配IP地址\n            match = ip_pattern.search(line)\n            if match:\n                ip_address = match.group(0)\n    \n                # 增加IP地址访问次数\n                ip_count[ip_address] += 1\n    \n                # 判断是否是高频率访问\n                if ip_count[ip_address] > 30:\n                    high_frequency_ips[ip_address] = ip_count[ip_address]\n\n    print(ip_count)\n    # 输出IP地址及其访问次数到统计文件\n    with open(statistics_output_file, 'w') as output:\n        json.dump(ip_count, output, ensure_ascii=False, indent=2)\n    \n    # 输出高频率访问的IP地址到单独的文件\n    with open(high_frequency_output_file, 'w') as output:\n        json.dump(high_frequency_ips, output, ensure_ascii=False, indent=2)\n\n```", "classification": "软件工程"}
{"_id": 186, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n假设有一个同时存储文件和目录的文件系统。\n将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext \n在文本格式中，如下所示(⟶表示制表符)\ndir\n⟶ subdir1\n⟶ ⟶ file1.ext\n⟶ ⟶ subsubdir1\n⟶ subdir2\n⟶ ⟶ subsubdir2\n⟶ ⟶ ⟶ file2.ext\n如果是代码表示，上面的文件系统可以写为 \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" 。'\\n' 和 '\\t' 分别是换行符和制表符\n文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 '/' 连接。上面例子中，指向 file2.ext 的 绝对路径 是 \"dir/subdir2/subsubdir2/file2.ext\" 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和/或空格组成\n给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0\n例如：\n    输入：input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\n    输出：32\n    解释：存在两个文件：\n    \"dir/subdir1/file1.ext\" ，路径长度 21\n    \"dir/subdir2/subsubdir2/file2.ext\" ，路径长度 32\n    返回 32 ，因为这是最长的路径\n提示：\n    1 <= input.length <= 104\n    input 可能包含小写或大写的英文字母，一个换行符 '\\n'，一个制表符 '\\t'，一个点 '.'，一个空格 ' '，和数字。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass TestlengthLongestPath:\n    def test_case1(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\") == 32\n\n", "problem": "假设有一个同时存储文件和目录的文件系统。\n将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext \n在文本格式中，如下所示(⟶表示制表符)\ndir\n⟶ subdir1\n⟶ ⟶ file1.ext\n⟶ ⟶ subsubdir1\n⟶ subdir2\n⟶ ⟶ subsubdir2\n⟶ ⟶ ⟶ file2.ext\n如果是代码表示，上面的文件系统可以写为 \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" 。'\\n' 和 '\\t' 分别是换行符和制表符\n文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 '/' 连接。上面例子中，指向 file2.ext 的 绝对路径 是 \"dir/subdir2/subsubdir2/file2.ext\" 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和/或空格组成\n给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0\n例如：\n    输入：input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\n    输出：32\n    解释：存在两个文件：\n    \"dir/subdir1/file1.ext\" ，路径长度 21\n    \"dir/subdir2/subsubdir2/file2.ext\" ，路径长度 32\n    返回 32 ，因为这是最长的路径\n提示：\n    1 <= input.length <= 104\n    input 可能包含小写或大写的英文字母，一个换行符 '\\n'，一个制表符 '\\t'，一个点 '.'，一个空格 ' '，和数字。", "testcases": "\n\nclass TestlengthLongestPath:\n    def test_case2(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\") == 32\n\n    def test_case3(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\\n\\t\\t\\tfile4.ext\") == 32\n\n    def test_case4(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\\n\\t\\t\\tfile4.ext\\n\\t\\t\\tfile5.ext\") == 32\n\n    def test_case5(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\\n\\t\\t\\tfile4.ext\\n\\t\\t\\tfile5.ext\\n\\t\\t\\tfile6.ext\") == 32\n\n    def test_case6(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\\n\\t\\t\\tfile4.ext\\n\\t\\t\\tfile5.ext\\n\\t\\t\\tfile6.ext\\n\\t\\t\\tfile7.ext\") == 32\n\n    def test_case7(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\\n\\t\\t\\tfile4.ext\\n\\t\\t\\tfile5.ext\\n\\t\\t\\tfile6.ext\\n\\t\\t\\tfile7.ext\\n\\t\\t\\tfile8.ext\") == 32\n\n    def test_case8(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\\n\\t\\t\\tfile4.ext\\n\\t\\t\\tfile5.ext\\n\\t\\t\\tfile6.ext\\n\\t\\t\\tfile7.ext\\n\\t\\t\\tfile8.ext\\n\\t\\t\\tfile9.ext\") == 32\n\n    def test_case9(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\\n\\t\\t\\tfile4.ext\\n\\t\\t\\tfile5.ext\\n\\t\\t\\tfile6.ext\\n\\t\\t\\tfile7.ext\\n\\t\\t\\tfile8.ext\\n\\t\\t\\tfile9.ext\\n\\t\\t\\tfile10.ext\") == 33\n\n    def test_case10(self):\n        assert lengthLongestPath(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\\n\\t\\t\\tfile3.ext\\n\\t\\t\\tfile4.ext\\n\\t\\t\\tfile5.ext\\n\\t\\t\\tfile6.ext\\n\\t\\t\\tfile7.ext\\n\\t\\t\\tfile8.ext\\n\\t\\t\\tfile9.ext\\n\\t\\t\\tfile10.ext\\n\\t\\t\\tfile11.ext\") == 33", "setup_code": "", "reference_solution": "```python\ndef lengthLongestPath(input: str) -> int:\n    st = []\n    ans, i, n = 0, 0, len(input)\n    while i < n:\n        # 检测当前文件的深度\n        depth = 1\n        while i < n and input[i] == '\\t':\n            depth += 1\n            i += 1\n        # 统计当前文件名的长度\n        length, isFile = 0, False\n        while i < n and input[i] != '\\n':\n            if input[i] == '.':\n                isFile = True\n            length += 1\n            i += 1\n        i += 1  # 跳过换行符\n        while len(st) >= depth:\n            st.pop()\n        if st:\n            length += st[-1] + 1\n        if isFile:\n            ans = max(ans, length)\n        else:\n            st.append(length)\n    return ans\n\n\n```", "classification": "算法和数据结构"}
{"_id": 187, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n手动编写数据，演示使用scikit-learn库 (sklearn) 中的K均值（K-means）聚类算法。随机种子为42, 计算输出每个数据样本的结果\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testk_means_clustering:\n    def test_k_means_clustering_1(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [5, 8], [1.5, 1.8], [8, 8], [1, 0.6], [9, 11]])\n        num_clusters = 2\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([1, 0, 1, 0, 1, 0]))\n\n", "problem": "手动编写数据，演示使用scikit-learn库 (sklearn) 中的K均值（K-means）聚类算法。随机种子为42, 计算输出每个数据样本的结果", "testcases": "from sklearn.cluster import KMeans\nimport numpy as np\n\n\nclass Testk_means_clustering:\n    def test_k_means_clustering_2(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [5, 8], [1.5, 1.8], [8, 8], [1, 0.6], [9, 11]])\n        num_clusters = 3\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([0, 1, 0, 1, 0, 2]))\n\n    def test_k_means_clustering_3(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [5, 8], [1.5, 1.8], [8, 8], [1, 0.6], [9, 11]])\n        num_clusters = 1\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([0, 0, 0, 0, 0, 0]))\n\n    def test_k_means_clustering_4(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [5, 8], [1.5, 1.8], [8, 8], [1, 0.6], [9, 11]])\n        num_clusters = 6\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([5, 2, 1, 0, 4, 3]))\n\n    def test_k_means_clustering_5(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]])\n        num_clusters = 2\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([0, 0, 0, 0, 0, 0]))\n\n    def test_k_means_clustering_6(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n        num_clusters = 2\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([1, 1, 1, 0, 0, 0]))\n\n    def test_k_means_clustering_7(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]])\n        num_clusters = 1\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([0, 0, 0, 0, 0, 0]))\n\n    def test_k_means_clustering_8(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]])\n        num_clusters = 6\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([0, 0, 0, 0, 0, 0]))\n\n    def test_k_means_clustering_9(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n        num_clusters = 1\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([0, 0, 0, 0, 0, 0]))\n\n    def test_k_means_clustering_10(self):\n        np.random.seed(0)\n        data = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n        num_clusters = 6\n        assert np.all(k_means_clustering(data, num_clusters) == np.array([4, 1, 2, 0, 5, 3]))", "setup_code": "", "reference_solution": "```python\nfrom sklearn.cluster import KMeans\nimport numpy as np\n\ndef k_means_clustering(data, num_clusters):\n    kmeans = KMeans(n_clusters=num_clusters, random_state=42)\n    kmeans.fit(data)\n    return kmeans.labels_\n\n```", "classification": "人工智能"}
{"_id": 188, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n用python完成对图像的伽马亮度矫正。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testgamma_correction:\n    def test_gamma_correction_1(self):\n        image = cv2.imread('test1/test.jpg', cv2.IMREAD_COLOR)\n        gamma = 1.5\n        corrected_image = gamma_correction(image, gamma)\n        label = cv2.imread('test1/label.png', cv2.IMREAD_COLOR)\n        assert (corrected_image == label).all()\n\n", "problem": "用python完成对图像的伽马亮度矫正。", "testcases": "import cv2\n\nclass Testgamma_correction:\n    def test_gamma_correction_2(self):\n        image = cv2.imread('test2/test.jpg', cv2.IMREAD_COLOR)\n        gamma = 2.0\n        corrected_image = gamma_correction(image, gamma)\n        label = cv2.imread('test2/label.png', cv2.IMREAD_COLOR)\n        assert (corrected_image == label).all()\n\n    def test_gamma_correction_3(self):\n        image = cv2.imread('test3/test.jpg', cv2.IMREAD_COLOR)\n        gamma = 0.5\n        corrected_image = gamma_correction(image, gamma)\n        label = cv2.imread('test3/label.png', cv2.IMREAD_COLOR)\n        assert (corrected_image == label).all()\n\n    def test_gamma_correction_4(self):\n        image = cv2.imread('test4/test.jpg', cv2.IMREAD_COLOR)\n        gamma = 0.1\n        corrected_image = gamma_correction(image, gamma)\n        label = cv2.imread('test4/label.png', cv2.IMREAD_COLOR)\n        assert (corrected_image == label).all()\n\n    def test_gamma_correction_5(self):\n        image = cv2.imread('test5/test.jpg', cv2.IMREAD_COLOR)\n        gamma = 10.0\n        corrected_image = gamma_correction(image, gamma)\n        label = cv2.imread('test5/label.png', cv2.IMREAD_COLOR)\n        assert (corrected_image == label).all()\n", "setup_code": "", "reference_solution": "```python\nimport cv2\nimport numpy as np\n\ndef gamma_correction(image, gamma):\n    # 将图像的亮度值转换为范围在[0, 1]之间的浮点数\n    image = image / 255.0\n    \n    # 对图像进行伽马亮度矫正\n    corrected_image = np.power(image, gamma)\n    \n    # 将亮度值重新缩放到范围[0, 255]\n    corrected_image = np.uint8(corrected_image * 255)\n    \n    return corrected_image\n```", "classification": "软件工程"}
{"_id": 189, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n请帮我写段代码实现下面的需求:有一个目标文件夹root folder中都是type为file folder的文件，每个file folder中都有许多不同type的文件。需要将这些file folder中的所以不同type的文件分别合并成pdf并和合并前的这些文件放在一起。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testmerge_pdfs:\n\n    def test_merge_pdfs_1(self):\n        d = './test1'\n        merge_pdfs(d)\n        page_text = self.readpdf(os.path.join(d, 'sub', \"merged.pdf\"))\n        assert page_text == \"content\"\n\n", "problem": "请帮我写段代码实现下面的需求:有一个目标文件夹root folder中都是type为file folder的文件，每个file folder中都有许多不同type的文件。需要将这些file folder中的所以不同type的文件分别合并成pdf并和合并前的这些文件放在一起。", "testcases": "import pytest\n\nimport os\nfrom PyPDF2 import PdfMerger, PdfReader\n\nclass Testmerge_pdfs:\n    def test_merge_pdfs_2(self):\n        d = './test2'\n        merge_pdfs('./test2')\n        page_text = self.readpdf(os.path.join(d, 'sub', \"merged.pdf\"))\n        assert page_text == \"content1content2content3\"\n\n    def test_merge_pdfs_3(self, tmp_path):\n        d = './test3'\n        merge_pdfs('./test3')\n        page_text = self.readpdf(os.path.join(d, 'sub', \"merged.pdf\"))\n        assert page_text == \"content1 content11content2content3_1\"\n\n    def test_merge_pdfs_4(self, tmp_path):\n        d = './test4'\n        merge_pdfs('./test4')\n        page_text = self.readpdf(os.path.join(d, 'sub', \"merged.pdf\"))\n        assert page_text == 'Today is a good day, I want to try something new. How about you?1 + 1 = 3?\\n' \\\n                            'No! \\n' \\\n                            'Actually #1 + 1 = 3;The weather is so nice today.*/\\n' \\\n                            'Yes, let’s travel together!*/\\n' \\\n                            'Goody goody!*/'\n\n    def test_merge_pdfs_5(self, tmp_path):\n        d = './test5'\n        merge_pdfs('./test5')\n        page_text = self.readpdf(os.path.join(d, 'sub', \"merged.pdf\"))\n        assert page_text == ''\n\n    def test_merge_pdfs_6(self, tmp_path):\n        d = './test6'\n        merge_pdfs('./test6')\n        assert not os.path.exists(os.path.join(d, 'sub1', \"merged.pdf\"))\n        assert not os.path.exists(os.path.join(d, 'sub2', \"merged.pdf\"))\n\n    def test_merge_pdfs_7(self, tmp_path):\n        d = './test7'\n        merge_pdfs('./test7')\n        page_text1 = self.readpdf(os.path.join(d, 'sub1', \"merged.pdf\"))\n        page_text2 = self.readpdf(os.path.join(d, 'sub2', \"merged.pdf\"))\n        assert page_text1 == \"!@#$%^&*()\\n~`'/.,<>\\\\[]#include\\n        int main(\"\n        assert page_text2 == 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa#include\\n    int main('\n\n    def test_merge_pdfs_8(self, tmp_path):\n        d = './test8'\n        merge_pdfs('./test8')\n        page_text1 = self.readpdf(os.path.join(d, 'sub1', \"merged.pdf\"))\n        page_text11 = self.readpdf(os.path.join(d, 'sub1', 'sub11', \"merged.pdf\"))\n        page_text2 = self.readpdf(os.path.join(d, 'sub2', \"merged.pdf\"))\n        assert page_text1 == \"!@#$%^&*()\\n~`'/.,<>\\\\[]#include\\n        int main(\"\n        assert page_text11 == \"!@#$%^&*()\\n~`'/.,<>\\\\[]#include\\n        int main(\"\n        assert page_text2 == 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa#include\\n    int main('\n        assert not os.path.exists(os.path.join(d, 'sub1', 'sub12', \"merged.pdf\"))\n        assert not os.path.exists(os.path.join(d, 'sub2', 'sub21', \"merged.pdf\"))\n\n    def readpdf(self, file_path):\n        with open(file_path, 'rb') as pdf_file:\n            pdf_reader = PdfReader(pdf_file)\n            total_pages = len(pdf_reader.pages)\n            page_text = ''\n            for page_num in range(total_pages):\n                page = pdf_reader.pages[page_num]\n                page_text += page.extract_text().strip()\n        os.remove(file_path)\n        return page_text", "setup_code": "", "reference_solution": "```python\n\nimport os\nfrom PyPDF2 import PdfMerger\n\n# 定义一个函数来合并PDF文件\ndef merge_pdfs(root_dir):\n    def merge(files, output):\n        merger = PdfMerger()\n        for pdf in files:\n            merger.append(pdf)\n        merger.write(output)\n        merger.close()\n\n    # 遍历文件夹\n    for root, dirs, files in os.walk(root_dir):\n        pdf_files = [f for f in files if f.endswith(\".pdf\")]\n        if pdf_files:  # 如果存在PDF文件\n            output = os.path.join(root, \"merged.pdf\")  # 输出文件名\n            full_pdf_files = [os.path.join(root, f) for f in pdf_files]  # 获取完整路径\n            full_pdf_files = sorted(full_pdf_files)\n            merge(full_pdf_files, output)  # 合并PDF文件\n\n\n\n\n\n\n\n```", "classification": "软件工程"}
{"_id": 190, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n给定CSV文件的内容作为csv_contents，返回最早和最老条目之间的日期差（以天为单位）。\n\nCSV文件以标题行开始，其中至少包含一个名为Date的列。\n\n如果需要，可以提供pandas库。请向我展示与此问题相关的代码。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcalculate_date_difference:\n    def test_calculate_date_difference_1(self):\n        csv_contents = \"Date\\n2020-01-01\\n2020-01-02\\n2020-01-03\"\n        assert calculate_date_difference(csv_contents) == 2\n\n", "problem": "给定CSV文件的内容作为csv_contents，返回最早和最老条目之间的日期差（以天为单位）。\n\nCSV文件以标题行开始，其中至少包含一个名为Date的列。\n\n如果需要，可以提供pandas库。请向我展示与此问题相关的代码。", "testcases": "import pytest\n\nimport pandas as pd\nfrom io import StringIO\n\nclass Testcalculate_date_difference:\n    def test_calculate_date_difference_2(self):\n        csv_contents = \"Date\\n2020-01-01\\n2020-01-01\\n2020-01-01\"\n        assert calculate_date_difference(csv_contents) == 0\n\n    def test_calculate_date_difference_3(self):\n        csv_contents = \"Date\\n2020-01-01\\n2020-12-31\"\n        assert calculate_date_difference(csv_contents) == 365\n\n    def test_calculate_date_difference_4(self):\n        csv_contents = \"Date\\n2020-01-01\\n2021-01-01\"\n        assert calculate_date_difference(csv_contents) == 366\n\n    def test_calculate_date_difference_5(self):\n        csv_contents = \"Date,Value\\n\" \\\n                       \"2024-01-01,100\\n\" \\\n                       \"2024-02-15,110\\n\" \\\n                       \"2024-03-10,120\\n\"\n\n        assert calculate_date_difference(csv_contents) == 69\n\n    def test_calculate_date_difference_6(self):\n        csv_contents = \"Date,date,DATE\\n\" \\\n                       \"2020-01-01,100,2020-01-01\\n\" \\\n                       \"2020-02-15,110,2020-01-02\\n\" \\\n                       \"2020-03-10,120,2020-01-02\\n\"\n        assert calculate_date_difference(csv_contents) == 69\n\n    def test_calculate_date_difference_7(self):\n        csv_contents = \"Date\\n2020-01-01\"\n        assert calculate_date_difference(csv_contents) == 0\n\n    def test_calculate_date_difference_8(self):\n        csv_contents = \"Date\\n2020-01-01\\n2020-01-01\"\n        assert calculate_date_difference(csv_contents) == 0\n\n    def test_calculate_date_difference_9(self):\n        csv_contents = \"Date\\n2020-01-01\\n2021-01-02\\n2022-01-03\\n2023-01-04\\n2024-01-05\\n2025-01-06\"\n        assert calculate_date_difference(csv_contents) == 1832\n\n    def test_calculate_date_difference_10(self):\n        csv_contents = \"Date\\n2020-01-01\\n2022-01-02\\n2022-01-03\\n2023-01-04\\n2023-01-05\\n2021-01-06\\n2021-01-07\"\n        assert calculate_date_difference(csv_contents) == 1100", "setup_code": "", "reference_solution": "```python\n\nimport pandas as pd\nfrom io import StringIO\n\ndef calculate_date_difference(csv_contents):\n    # Read the CSV contents into a pandas DataFrame\n    df = pd.read_csv(StringIO(csv_contents))\n\n    # Convert the 'Date' column to datetime\n    df['Date'] = pd.to_datetime(df['Date'])\n\n    # Calculate the difference in days between the earliest and latest date\n    date_difference = (df['Date'].max() - df['Date'].min()).days\n\n    return date_difference\n\n\n```", "classification": "数据科学"}
{"_id": 191, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n我现在有一个文件夹file_path，文件夹里有一些文件，文件是成对出现，例如mix_7560000_content_document.bin\n和 mix_7560000_content_document.idx 是一对文件。现在我要将这个文件夹的文件复制到多个子文件夹，每个子文件夹包含10对数据，每个新文件夹后面还加上sub加数字的后缀。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcopy_files:\n    def test_copy_files_1(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(20):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub1\"))) == 20\n\n", "problem": "我现在有一个文件夹file_path，文件夹里有一些文件，文件是成对出现，例如mix_7560000_content_document.bin\n和 mix_7560000_content_document.idx 是一对文件。现在我要将这个文件夹的文件复制到多个子文件夹，每个子文件夹包含10对数据，每个新文件夹后面还加上sub加数字的后缀。", "testcases": "import pytest\n\nimport os\nimport shutil\n\nclass Testcopy_files:\n    def test_copy_files_2(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(30):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub1\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub2\"))) == 20\n\n    def test_copy_files_3(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(10):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 20\n\n    def test_copy_files_4(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(5):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 10\n\n    def test_copy_files_5(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(0):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert os.path.exists(os.path.join(dest, \"sub0\")) == False\n\n    def test_copy_files_6(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(41):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub1\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub2\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub4\"))) == 2\n\n    def test_copy_files_7(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(1):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 2\n\n    def test_copy_files_8(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(100):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub1\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub2\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub3\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub4\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub9\"))) == 20\n        assert os.path.exists(os.path.join(dest, \"sub10\")) == False\n\n    def test_copy_files_9(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(11):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub1\"))) == 2\n\n    def test_copy_files_10(self, tmpdir):\n        source = tmpdir.mkdir(\"source\")\n        dest = tmpdir.mkdir(\"dest\")\n        for i in range(21):\n            open(os.path.join(source, f\"mix_{i}_content_document.bin\"), 'a').close()\n            open(os.path.join(source, f\"mix_{i}_content_document.idx\"), 'a').close()\n        copy_files(str(source), str(dest))\n        assert len(os.listdir(os.path.join(dest, \"sub0\"))) == 20\n        assert len(os.listdir(os.path.join(dest, \"sub2\"))) == 2", "setup_code": "", "reference_solution": "```python\n\nimport os\nimport shutil\n\ndef copy_files(file_path, dest_path, pairs_per_folder=10):\n    files = os.listdir(file_path)\n    files.sort()\n    pairs = zip(files[::2], files[1::2])\n    for i, pair in enumerate(pairs):\n        sub_folder = os.path.join(dest_path, 'sub{}'.format(i // pairs_per_folder))\n        os.makedirs(sub_folder, exist_ok=True)\n        for file in pair:\n            shutil.copy(os.path.join(file_path, file), sub_folder)\n\n# 使用方法\n# copy_files('/path/to/source/folder', '/path/to/destination/folder')\n\n\n```", "classification": "操作系统"}
{"_id": 192, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n如何将含有类似 ```html  ```，```css  ```，```python  ```，```javascript  ```，```golang  ```这样内容的一段字符串，将上面的字符串替换成<pre><code class=\"language-html\">...</code></pre>，<pre><code class=\"language-css\">...</code></pre>，<pre><code class=\"language-python\">...</code></pre>，<pre><code class=\"language-javascript\">...</code></pre>，<pre><code class=\"language-golang\">...</code></pre>这样的字符串。请使用python代码\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testreplace_code_block:\n    def test_replace_code_block_1(self):\n        assert replace_code_block('```html ```') == '<pre><code class=\"language-html\"></code></pre>'\n", "problem": "如何将含有类似 ```html  ```，```css  ```，```python  ```，```javascript  ```，```golang  ```这样内容的一段字符串，将上面的字符串替换成<pre><code class=\"language-html\">...</code></pre>，<pre><code class=\"language-css\">...</code></pre>，<pre><code class=\"language-python\">...</code></pre>，<pre><code class=\"language-javascript\">...</code></pre>，<pre><code class=\"language-golang\">...</code></pre>这样的字符串。请使用python代码", "testcases": "import pytest\n\nimport re\n\nclass Testreplace_code_block:\n    def test_replace_code_block_2(self):\n        assert replace_code_block('```css 1```') == '<pre><code class=\"language-css\">1</code></pre>'\n    def test_replace_code_block_3(self):\n        assert replace_code_block('```python```') == '<pre><code class=\"language-python\"></code></pre>'\n    def test_replace_code_block_4(self):\n        assert replace_code_block('```javascript __main__```') == '<pre><code class=\"language-javascript\">__main__</code></pre>'\n    def test_replace_code_block_5(self):\n        assert replace_code_block('```golang \\'\\'```') == '<pre><code class=\"language-golang\">\\'\\'</code></pre>'\n    def test_replace_code_block_6(self):\n        assert replace_code_block('```html css python``` ```javascript ``````golang') == '<pre><code class=\"language-html\">css python</code></pre> <pre><code class=\"language-javascript\"></code></pre>```golang'\n    def test_replace_code_block_7(self):\n        assert replace_code_block('') == ''\n    def test_replace_code_block_8(self):\n        assert replace_code_block('```htmlhtml```') == '```htmlhtml```'\n    def test_replace_code_block_9(self):\n        assert replace_code_block('```html```') == '<pre><code class=\"language-html\"></code></pre>'\n    def test_replace_code_block_10(self):\n        assert replace_code_block('html pythonpython golanggolang') == 'html pythonpython golanggolang'", "setup_code": "", "reference_solution": "```python\n\nimport re\n\ndef replace_code_block(text):\n    # 定义一个字典，将代码块标记映射到相应的HTML类\n    languages = {\n        \"html\": \"language-html\",\n        \"css\": \"language-css\",\n        \"python\": \"language-python\",\n        \"javascript\": \"language-javascript\",\n        \"golang\": \"language-golang\"\n    }\n\n    # 对于每种语言，使用正则表达式查找和替换相应的代码块\n    for lang, html_class in languages.items():\n        # 构建正则表达式模式\n        pattern = rf\"```{lang}\\b\\s*(.*?)\\s*```\"\n        # 替换文本\n        replacement = rf'<pre><code class=\"{html_class}\">\\1</code></pre>'\n        # 应用替换\n        text = re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    return text\n\n\n\n```", "classification": "前端开发"}
{"_id": 193, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n你还记得我问过关于用Excel计算ET Penman Montith的问题，你建议用Python会更容易吗？\n\n因为我对编程环境不太熟悉，你能告诉我如何用Python一步一步计算ET吗？\n\n或者你能帮我写个代码吗？\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcalculate_et:\n    def test_calculate_et_1(self):\n        assert np.isclose(calculate_et(0.5, 100, 20, 0.5, 25, 2, 50, 30), 57.25573474907341, atol=1e-5)\n\n", "problem": "你还记得我问过关于用Excel计算ET Penman Montith的问题，你建议用Python会更容易吗？\n\n因为我对编程环境不太熟悉，你能告诉我如何用Python一步一步计算ET吗？\n\n或者你能帮我写个代码吗？", "testcases": "import pytest\nimport numpy as np\n\nclass Testcalculate_et:\n    def test_calculate_et_2(self):\n        assert np.isclose(calculate_et(0.7, 150, 30, 0.6, 30, 3, 60, 40), 73.850780893989, atol=1e-5)\n\n    def test_calculate_et_3(self):\n        assert np.isclose(calculate_et(0.6, 120, 25, 0.7, 28, 2.5, 55, 35), 67.49718353071117, atol=1e-5)\n\n    def test_calculate_et_4(self):\n        assert np.isclose(calculate_et(0.8, 180, 35, 0.8, 32, 3.5, 70, 45), 99.48486561488258, atol=1e-5)\n\n    def test_calculate_et_5(self):\n        assert np.isclose(calculate_et(0.9, 200, 40, 0.9, 35, 4, 80, 50), 123.78849721706865, atol=1e-5)\n\n    def test_calculate_et_6(self):\n        assert np.isclose(calculate_et(1, 220, 45, 1, 38, 4.5, 90, 55), 149.34498055254454, atol=1e-5)\n\n    def test_calculate_et_7(self):\n        assert np.isclose(calculate_et(0, 0, 0, 0, 0, 0, 0, 0), 0, atol=1e-5)\n\n    def test_calculate_et_8(self):\n        assert np.isclose(calculate_et(1, 1, 1, 1, 1, 1, 1, 1), 0, atol=1e-5)\n\n    def test_calculate_et_9(self):\n        assert np.isclose(calculate_et(100, 100, 100, 100, 100, 100, 100, 100), 0, atol=1e-5)\n\n    def test_calculate_et_10(self):\n        assert np.isclose(calculate_et(-1, -1, -1, -1, -1, -1, -1, -1), 0, atol=1e-5)\n\n", "setup_code": "", "reference_solution": "```python\n\ndef calculate_et(delta, rn, g, gamma, t, u2, es, ea):\n    numerator = 0.408 * delta * (rn - g) + gamma * (900 / (t + 273)) * u2 * (es - ea)\n    denominator = delta + gamma * (1 + 0.34 * u2)\n    if denominator == 0:\n        return 0\n    et = numerator / denominator\n\n    print(et)\n    return et\n\n\n```", "classification": "数据科学"}
{"_id": 194, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\npython etree 如何判断 p标签文本下面有 strong 或 em 标签？\n    <p>\n        3131\n        <strong>AAAA</strong>\n        <strong>BBB</strong>\n        <strong>CCC</strong>\n    </p>\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testhas_strong_or_em:\n    def test_has_strong_or_em_1(self):\n        html = \"\"\"\n        <p>\n            3131\n            <strong>AAAA</strong>\n            <strong>BBB</strong>\n            <strong>CCC</strong>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == True\n\n", "problem": "python etree 如何判断 p标签文本下面有 strong 或 em 标签？\n    <p>\n        3131\n        <strong>AAAA</strong>\n        <strong>BBB</strong>\n        <strong>CCC</strong>\n    </p>", "testcases": "import pytest\n\nfrom lxml import etree\n\nclass Testhas_strong_or_em:\n    def test_has_strong_or_em_2(self):\n        html = \"\"\"\n        <p>\n            3131\n            <em>AAAA</em>\n            <em>BBB</em>\n            <em>CCC</em>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == True\n\n    def test_has_strong_or_em_3(self):\n        html = \"\"\"\n        <p>\n            3131\n            <strong>AAAA</strong>\n            <em>BBB</em>\n            <strong>CCC</strong>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == True\n\n    def test_has_strong_or_em_4(self):\n        html = \"\"\"\n        <p>\n            3131\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == False\n\n    def test_has_strong_or_em_5(self):\n        html = \"\"\"\n        <p>\n            3131\n            <div>AAAA</div>\n            <div>BBB</div>\n            <div>CCC</div>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == False\n\n    def test_has_strong_or_em_6(self):\n        html = \"\"\"\n        <p>\n            3131\n            <strong></strong>\n            <em></em>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == True\n\n    def test_has_strong_or_em_7(self):\n        html = \"\"\"\n        <p>\n            3131\n            <strong>AAAA</strong>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == True\n\n    def test_has_strong_or_em_8(self):\n        html = \"\"\"\n        <p>\n            3131\n            <em>AAAA</em>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == True\n\n    def test_has_strong_or_em_9(self):\n        html = \"\"\"\n        <p>\n            3131\n            <strong>AAAA</strong>\n            <em>BBB</em>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == True\n\n    def test_has_strong_or_em_10(self):\n        html = \"\"\"\n        <p>\n            3131\n            <strong>AAAA</strong>\n            <strong>BBB</strong>\n            <em>CCC</em>\n        </p>\n        \"\"\"\n        root = etree.fromstring(html)\n        assert has_strong_or_em(root) == True\n", "setup_code": "", "reference_solution": "```python\n\nfrom lxml import etree\n\nhtml = \"\"\"\n<p>\n    3131\n    <strong>AAAA</strong>\n    <strong>BBB</strong>\n    <strong>CCC</strong>\n</p>\n\"\"\"\n\nroot = etree.fromstring(html)\n\ndef has_strong_or_em(tag):\n    if tag.find('strong') is not None or tag.find('em') is not None:\n        return True\n    return False\n\nfor p in root.iter('p'):\n    if has_strong_or_em(p):\n        print(\"P tag has strong or em tag\")\n    else:\n        print(\"P tag does not have strong or em tag\")\n\n\n```", "classification": "前端开发"}
{"_id": 195, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n如何在pandas表的行中展平字典格式，每个键值对占据一行？这个字典可能是嵌套的，通过“.”连接不同级别的键？\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testflatten_dict_to_rows:\n    def test_flatten_dict_to_rows_1(self):\n        dt = {'A': ['foo', 'bar'], 'B': [{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A', 1: 'B'}, 'Value': {0: ['foo', 'bar'], 1: [{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]}})\n        pd.testing.assert_frame_equal(result, expected)\n\n", "problem": "如何在pandas表的行中展平字典格式，每个键值对占据一行？这个字典可能是嵌套的，通过“.”连接不同级别的键？", "testcases": "import pytest\n\nimport pandas as pd\n\nclass Testflatten_dict_to_rows:\n    def test_flatten_dict_to_rows_2(self):\n        dt = {'A': ['foo', 'bar', 'baz'], 'B': {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A', 1: 'B.a', 2: 'B.b', 3: 'B.c', 4: 'B.d', 5: 'B.e', 6: 'B.f'}, 'Value': {0: ['foo', 'bar', 'baz'], 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_flatten_dict_to_rows_3(self):\n        dt = {'A': ['foo'], 'B': {'a': 1, 'b': [2, 3]}}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A', 1: 'B.a', 2: 'B.b'}, 'Value': {0: ['foo'], 1: 1, 2: [2, 3]}})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_flatten_dict_to_rows_4(self):\n        dt = {'A': {'A.1': 2, 'A.2': {'A.3': 'A.3.1'}}, 'B': {'a': 1}, 'C': {'b': 2}}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A.A.1', 1: 'A.A.2.A.3', 2: 'B.a', 3: 'C.b'}, 'Value': {0: 2, 1: 'A.3.1', 2: 1, 3: 2}})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_flatten_dict_to_rows_5(self):\n        dt = {'A': ['foo', 'bar'], 'B': {'a': [1, {'a': 3, 'b': 4}]}}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A', 1: 'B.a'}, 'Value': {0: ['foo', 'bar'], 1: [1, {'a': 3, 'b': 4}]}})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_flatten_dict_to_rows_6(self):\n        dt = {'A': ['foo', 'bar'], 'B': {\"C\": [{'a': 1, 'b': 2}, {'c': 3, 'd': 4, 'e': 5}]}}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A', 1: 'B.C'}, 'Value': {0: ['foo', 'bar'], 1: [{'a': 1, 'b': 2}, {'c': 3, 'd': 4, 'e': 5}]}})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_flatten_dict_to_rows_7(self):\n        dt = {'A': [], 'B': []}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A', 1: 'B'}, 'Value': {0: [], 1: []}})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_flatten_dict_to_rows_8(self):\n        dt = {'A': ['foo'], 'B': [{}]}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A', 1: 'B'}, 'Value': {0: ['foo'], 1: [{}]}})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_flatten_dict_to_rows_9(self):\n        dt = {'A': ['foo'], 'C': {}}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {0: 'A', 1: 'C'}, 'Value': {0: ['foo'], 1: {}}})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_flatten_dict_to_rows_10(self):\n        dt = {}\n        result = flatten_dict_to_rows(dt)\n        expected = pd.DataFrame({'Key': {}, 'Value': {}})\n        pd.testing.assert_frame_equal(result, expected, check_dtype=False, check_index_type=False)", "setup_code": "", "reference_solution": "```python\n\nimport pandas as pd\n\ndef flatten_dict_to_rows(d):\n    def flatten_dict(d, parent_key='', sep='.'):\n        items = []\n        for k, v in d.items():\n            new_key = f\"{parent_key}{sep}{k}\" if parent_key else k\n            if isinstance(v, dict):\n                if not v:\n                    items.append((new_key, {}))\n                else:\n                    items.extend(flatten_dict(v, new_key, sep=sep).items())\n            else:\n                items.append((new_key, v))\n        return dict(items)\n\n    flat_dict = flatten_dict(d)\n\n    # Convert the flattened dictionary to a pandas DataFrame\n    df = pd.DataFrame(list(flat_dict.items()), columns=['Key', 'Value'])\n    print(df.to_dict())\n    return df\n\n\n```", "classification": "数据科学"}
{"_id": 196, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n21.给定一个MAC地址，判断该MAC地址是否在某给定的MAC地址段中，是输出TRUE，否输出FALSE举例:\n输入1:B4:AD:A3:31:£2:44，B4:AB:A3:31:£2:44-84:AE:A3:31:E2:44输出:TRUE\n输入2:B4:AD:A3:31:£2:44，B4:AD:A3:31:£2:46-B4:AD:A3:31:E2:4A输出:FALSE\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testis_mac_in_range:\n\n    def test_is_mac_in_range_1(self):\n        assert is_mac_in_range('B4:AD:A3:31:E2:44', 'B4:AB:A3:31:E2:44-84:AE:A3:31:E2:44') == False\n\n", "problem": "21.给定一个MAC地址，判断该MAC地址是否在某给定的MAC地址段中，是输出TRUE，否输出FALSE举例:\n输入1:B4:AD:A3:31:£2:44，B4:AB:A3:31:£2:44-84:AE:A3:31:E2:44输出:TRUE\n输入2:B4:AD:A3:31:£2:44，B4:AD:A3:31:£2:46-B4:AD:A3:31:E2:4A输出:FALSE", "testcases": "\n\nclass Testis_mac_in_range:\n    def test_is_mac_in_range_2(self):\n        assert is_mac_in_range('B4:AD:A3:31:E2:44', 'B4:AD:A3:31:E2:46-B4:AD:A3:31:E2:4A') == False\n\n    def test_is_mac_in_range_3(self):\n        assert is_mac_in_range('00:00:00:00:00:00', '00:00:00:00:00:00-FF:FF:FF:FF:FF:FF') == True\n\n    def test_is_mac_in_range_4(self):\n        assert is_mac_in_range('FF:FF:FF:FF:FF:FF', '00:00:00:00:00:00-FF:FF:FF:FF:FF:FF') == True\n\n    def test_is_mac_in_range_5(self):\n        assert is_mac_in_range('00:00:00:00:00:01', '00:00:00:00:00:00-00:00:00:00:00:02') == True\n\n    def test_is_mac_in_range_6(self):\n        assert is_mac_in_range('00:00:00:00:00:03', '00:00:00:00:00:00-00:00:00:00:00:02') == False\n\n    def test_is_mac_in_range_7(self):\n        assert is_mac_in_range('00:00:00:00:00:00', '00:00:00:00:00:01-00:00:00:00:00:02') == False\n\n    def test_is_mac_in_range_8(self):\n        assert is_mac_in_range('00:00:00:00:00:02', '00:00:00:00:00:01-00:00:00:00:00:02') == True\n\n    def test_is_mac_in_range_9(self):\n        assert is_mac_in_range('00:00:00:00:00:00', '00:00:00:00:00:00-00:00:00:00:00:00') == True\n\n    def test_is_mac_in_range_10(self):\n        assert is_mac_in_range('FF:FF:FF:FF:FF:FF', '00:00:00:00:00:00-00:00:00:00:00:00') == False", "setup_code": "", "reference_solution": "```python\n\ndef is_mac_in_range(mac, mac_range):\n    def mac_to_hex(mac_str):\n        return mac_str.replace(':', '').replace('-', '').upper()\n\n    # 解析MAC地址范围\n    start_mac_str, end_mac_str = mac_range.split('-')\n    start_mac = int(mac_to_hex(start_mac_str), 16)\n    end_mac = int(mac_to_hex(end_mac_str), 16)\n    mac_val = int(mac_to_hex(mac), 16)\n\n    # 判断MAC地址是否在范围内\n    return start_mac <= mac_val <= end_mac\n\n\n```", "classification": "软件工程"}
{"_id": 197, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个Python代码，该代码直接使用包含2个常数相位元素和3个电阻器的分数阶模型来估算18650锂离子电池的安时容量。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testfractional_order_model:\n    def test_fractional_order_model_1(self):\n        time_data = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n        current_data = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]))\n        assert round(popt[0], 2) == 0\n\n", "problem": "编写一个Python代码，该代码直接使用包含2个常数相位元素和3个电阻器的分数阶模型来估算18650锂离子电池的安时容量。", "testcases": "import pytest\n\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\nclass Testfractional_order_model:\n    def test_fractional_order_model_2(self):\n        time_data = np.array([0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20])\n        current_data = np.array([0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [2.0, 2.0, 2.0, 2.0, 2.0, 2.0]))\n        assert round(popt[0], 2) == 1.21\n\n    def test_fractional_order_model_3(self):\n        time_data = np.array([0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30])\n        current_data = np.array([0, 0.3, 0.6, 0.9, 1.2, 1.5, 1.8, 2.1, 2.4, 2.7, 3.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [3.0, 3.0, 3.0, 3.0, 3.0, 3.0]))\n        assert round(popt[0], 2) == 1.95\n\n    def test_fractional_order_model_4(self):\n        time_data = np.array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40])\n        current_data = np.array([0, 0.4, 0.8, 1.2, 1.6, 2.0, 2.4, 2.8, 3.2, 3.6, 4.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [4.0, 4.0, 4.0, 4.0, 4.0, 4.0]))\n        assert round(popt[0], 2) == 2.64\n\n    def test_fractional_order_model_5(self):\n        time_data = np.array([0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50])\n        current_data = np.array([0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [5.0, 5.0, 5.0, 5.0, 5.0, 5.0]))\n        assert round(popt[0], 2) == 3.33\n\n    def test_fractional_order_model_6(self):\n        time_data = np.array([0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60])\n        current_data = np.array([0, 0.6, 1.2, 1.8, 2.4, 3.0, 3.6, 4.2, 4.8, 5.4, 6.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [6.0, 6.0, 6.0, 6.0, 6.0, 6.0]))\n        assert round(popt[0], 2) == 4.0\n\n    def test_fractional_order_model_7(self):\n        time_data = np.array([0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70])\n        current_data = np.array([0, 0.7, 1.4, 2.1, 2.8, 3.5, 4.2, 4.9, 5.6, 6.3, 7.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [7.0, 7.0, 7.0, 7.0, 7.0, 7.0]))\n        assert round(popt[0], 2) == 4.67\n\n    def test_fractional_order_model_8(self):\n        time_data = np.array([0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80])\n        current_data = np.array([0, 0.8, 1.6, 2.4, 3.2, 4.0, 4.8, 5.6, 6.4, 7.2, 8.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [8.0, 8.0, 8.0, 8.0, 8.0, 8.0]))\n        assert round(popt[0], 2) == 5.34\n\n    def test_fractional_order_model_9(self):\n        time_data = np.array([0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90])\n        current_data = np.array([0, 0.9, 1.8, 2.7, 3.6, 4.5, 5.4, 6.3, 7.2, 8.1, 9.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [9.0, 9.0, 9.0, 9.0, 9.0, 9.0]))\n        assert round(popt[0], 2) == 6.01\n\n    def test_fractional_order_model_10(self):\n        time_data = np.array([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])\n        current_data = np.array([0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])\n        popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [10.0, 10.0, 10.0, 10.0, 10.0, 10.0]))\n        assert round(popt[0], 2) == 6.68\n", "setup_code": "", "reference_solution": "```python\n\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\n# Define the fractional order model with 2 constant phase elements and 3 resistors\ndef fractional_order_model(t, Q, R1, R2, R3, n1, n2):\n    return Q * (1 - (1 / (R1 * (t ** n1) + 1)) - (1 / (R2 * (t ** n2) + 1)) - (1 / R3))\n\n# # Sample time and current data\n# time_data = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n# current_data = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\n#\n# # Fit the model to the data\n# popt, pcov = curve_fit(fractional_order_model, time_data, current_data, bounds=(0, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]))\n# print(len(popt))\n# # The estimated battery capacity in Amp hour is the first parameter of the model\n# estimated_capacity_Ah = popt[0]\n#\n# print(\"Estimated battery capacity: {:.2f} Ah\".format(estimated_capacity_Ah))\n\n\n```", "classification": "软件工程"}
{"_id": 198, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\npython求解：设二次函数 p(x)=ax^2+bx+c过点(x_i,y_i) for i=1, 2, 3. 求a，b，c的值。\n例如过这三个点(-1,1),(0,-1),(2,7)，则可以得到一个线性方程组，使用numpy.linalg中solve函数解方程即可。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testsolve_quadratic:\n    def test_solve_quadratic_1(self):\n        points = [(0,0),(1,1),(2,4)]\n        assert np.allclose(solve_quadratic(points), [1, 0, 0])\n\n", "problem": "python求解：设二次函数 p(x)=ax^2+bx+c过点(x_i,y_i) for i=1, 2, 3. 求a，b，c的值。\n例如过这三个点(-1,1),(0,-1),(2,7)，则可以得到一个线性方程组，使用numpy.linalg中solve函数解方程即可。", "testcases": "import pytest\n\nimport numpy as np\n\nclass Testsolve_quadratic:\n    def test_solve_quadratic_2(self):\n        points = [(1,1),(2,4),(3,9)]\n        assert np.allclose(solve_quadratic(points), [1, 0, 0])\n\n    def test_solve_quadratic_3(self):\n        points = [(-1,1),(0,-1),(2,7)]\n        assert np.allclose(solve_quadratic(points), [2, 0, -1])\n\n    def test_solve_quadratic_4(self):\n        points = [(0,0),(1,3),(2,12)]\n        assert np.allclose(solve_quadratic(points), [3, 0, 0])\n\n    def test_solve_quadratic_5(self):\n        points = [(1,6),(2,11),(3,18)]\n        assert np.allclose(solve_quadratic(points), [1, 2, 3])\n\n    def test_solve_quadratic_6(self):\n        points = [(2,14),(3,21),(4,30)]\n        assert np.allclose(solve_quadratic(points), [1, 2, 6])\n\n    def test_solve_quadratic_7(self):\n        points = [(0,0),(1,0),(2,0)]\n        assert np.allclose(solve_quadratic(points), [0, 0, 0])\n\n    def test_solve_quadratic_8(self):\n        points = [(1,1),(2,1),(3,1)]\n        assert np.allclose(solve_quadratic(points), [0, 0, 1])\n\n    def test_solve_quadratic_9(self):\n        points = [(0,0),(0,0),(0,0)]\n        with pytest.raises(np.linalg.LinAlgError):\n            solve_quadratic(points)\n\n    def test_solve_quadratic_10(self):\n        points = [(1,1),(1,1),(1,1)]\n        with pytest.raises(np.linalg.LinAlgError):\n            solve_quadratic(points)", "setup_code": "", "reference_solution": "```python\n\nimport numpy as np\n\ndef solve_quadratic(points):\n    # Create matrix A using a list comprehension\n    A = np.array([[x**2, x, 1] for x, y in points])\n    # Create vector b\n    b = np.array([y for x, y in points])\n    # Use numpy.linalg.solve to solve for [a, b, c]\n    coefficients = np.linalg.solve(A, b)\n\n    return coefficients\n\n```", "classification": "算法和数据结构"}
{"_id": 199, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n编写一个函数，获取4个字符串表示的2个IP范围，并告诉我这些IP范围是否重叠\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testcheck_ip_overlap:\n    def test_check_ip_overlap_1(self):\n        assert check_ip_overlap('192.168.1.0/24', '192.168.2.0/24') == False\n\n", "problem": "编写一个函数，获取4个字符串表示的2个IP范围，并告诉我这些IP范围是否重叠", "testcases": "import pytest\n\nimport ipaddress\n\nclass Testcheck_ip_overlap:\n    def test_check_ip_overlap_2(self):\n        assert check_ip_overlap('192.168.1.0/24', '192.168.1.0/24') == True\n\n    def test_check_ip_overlap_3(self):\n        assert check_ip_overlap('10.0.0.0/8', '10.0.0.0/16') == True\n\n    def test_check_ip_overlap_4(self):\n        assert check_ip_overlap('172.16.0.0/12', '192.168.0.0/16') == False\n\n    def test_check_ip_overlap_5(self):\n        assert check_ip_overlap('172.16.0.0/12', '172.16.0.0/16') == True\n\n    def test_check_ip_overlap_6(self):\n        assert check_ip_overlap('10.0.0.0/8', '172.16.0.0/12') == False\n\n    def test_check_ip_overlap_7(self):\n        assert check_ip_overlap('0.0.0.0/0', '192.168.1.0/24') == True\n\n    def test_check_ip_overlap_8(self):\n        assert check_ip_overlap('0.0.0.0/0', '0.0.0.0/0') == True\n\n    def test_check_ip_overlap_9(self):\n        assert check_ip_overlap('255.255.255.255/32', '255.255.255.255/32') == True\n\n    def test_check_ip_overlap_10(self):\n        assert check_ip_overlap('255.255.255.255/32', '0.0.0.0/0') == True", "setup_code": "", "reference_solution": "```python\n\nimport ipaddress\n\ndef check_ip_overlap(ip_range1, ip_range2):\n    ip_net1 = ipaddress.ip_network(ip_range1)\n    ip_net2 = ipaddress.ip_network(ip_range2)\n\n    return ip_net1.overlaps(ip_net2)\n\n\n\n```", "classification": "算法和数据结构"}
{"_id": 200, "prompt": "你的任务是生成python代码来解决以下问题，生成的代码必须位于代码块```python和```之间，最多只允许有一个代码块：\n我想编写一个Python程序来重命名文件夹中的文件。\n请删除所有字母，只保留数字。\n\n你需要遵循以下测试用例中测试函数体中的函数名或类名, 生成的代码中不允许包含任何测例：\nclass Testrename_files_in_folder:\n    def test_rename_files_in_folder_1(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file123abc.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/123.txt')\n\n", "problem": "我想编写一个Python程序来重命名文件夹中的文件。\n请删除所有字母，只保留数字。", "testcases": "import pytest\n\nimport os\nimport re\n\nclass Testrename_files_in_folder:\n    def test_rename_files_in_folder_2(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file456def.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/456.txt')\n\n    def test_rename_files_in_folder_3(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file789ghi.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/789.txt')\n\n    def test_rename_files_in_folder_4(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file101112jkl.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/101112.txt')\n\n    def test_rename_files_in_folder_5(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file131415mno.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/131415.txt')\n\n    def test_rename_files_in_folder_6(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file161718pqr.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/161718.txt')\n\n    def test_rename_files_in_folder_7(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/.txt')\n\n    def test_rename_files_in_folder_8(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file123.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/123.txt')\n\n    def test_rename_files_in_folder_9(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file_1.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/_1.txt')\n\n    def test_rename_files_in_folder_10(self, tmpdir):\n        p = tmpdir.mkdir(\"sub\").join(\"file1234567890.abc-1.txt\")\n        p.write(\"content\")\n        rename_files_in_folder(str(tmpdir) + '/sub/')\n        assert os.path.isfile(str(tmpdir) + '/sub/1234567890.-1.txt')", "setup_code": "", "reference_solution": "```python\n\nimport os\nimport re\n\ndef rename_files_in_folder(folder_path):\n    for filename in os.listdir(folder_path):\n        file_type = filename.split('.')[-1]\n        new_filename = re.sub(\"[A-Za-z]\", \"\", filename[:-len(file_type)]) + file_type\n        os.rename(os.path.join(folder_path, filename), os.path.join(folder_path, new_filename))\n\n# Call the function with the path to the folder\n# rename_files_in_folder('/path/to/your/folder')\n\n\n```", "classification": "操作系统"}
